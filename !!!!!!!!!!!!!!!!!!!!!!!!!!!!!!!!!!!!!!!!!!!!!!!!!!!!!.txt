version: '3.8'

services:
  postgresql-test:
    image: postgres:14-alpine
    environment:
      - POSTGRES_DB=testdb
      - POSTGRES_USER=test
      - POSTGRES_PASSWORD=test
    ports:
      - "5433:5432"
    networks:
      - test-network

  rabbitmq-test:
    image: rabbitmq:3.12-management
    environment:
      - RABBITMQ_DEFAULT_USER=guest
      - RABBITMQ_DEFAULT_PASS=guest
    ports:
      - "5673:5672"
      - "15673:15672"
    networks:
      - test-network

  redis-test:
    image: redis:7-alpine
    ports:
      - "6380:6379"
    networks:
      - test-network

networks:
  test-network:
    driver: bridge

version: '3.8'

services:
  postgresql:
    image: postgres:14-alpine
    environment:
      POSTGRES_DB: notifications
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./src/main/resources/db/migration:/docker-entrypoint-initdb.d
    networks:
      - notification-network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 10s
      timeout: 5s
      retries: 5

  rabbitmq:
    image: rabbitmq:3.12-management
    environment:
      RABBITMQ_DEFAULT_USER: guest
      RABBITMQ_DEFAULT_PASS: guest
    ports:
      - "5672:5672"
      - "15672:15672"
    volumes:
      - rabbitmq_data:/var/lib/rabbitmq
    networks:
      - notification-network
    healthcheck:
      test: ["CMD", "rabbitmq-diagnostics", "check_running"]
      interval: 10s
      timeout: 5s
      retries: 5

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    networks:
      - notification-network
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 3s
      retries: 5

  mailhog:
    image: mailhog/mailhog
    ports:
      - "1025:1025"
      - "8025:8025"
    networks:
      - notification-network

  notification-service:
    build: .
    ports:
      - "8080:8080"
    environment:
      SPRING_PROFILES_ACTIVE: docker
      SPRING_RABBITMQ_HOST: rabbitmq
      SPRING_REDIS_HOST: redis
      SPRING_DATASOURCE_URL: jdbc:postgresql://postgresql:5432/notifications
      SPRING_DATASOURCE_USERNAME: postgres
      SPRING_DATASOURCE_PASSWORD: password
      SPRING_MAIL_HOST: mailhog
      SPRING_MAIL_PORT: 1025
      JAVA_OPTS: "-Xms512m -Xmx1024m -XX:+UseG1GC -Djava.security.egd=file:/dev/./urandom"
    depends_on:
      postgresql:
        condition: service_healthy
      redis:
        condition: service_healthy
      rabbitmq:
        condition: service_healthy
    networks:
      - notification-network
    volumes:
      - ./logs:/app/logs
      - ./attachments:/app/attachments
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/manage/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s

  prometheus:
    image: prom/prometheus
    ports:
      - "9090:9090"
    volumes:
      - ./monitoring/prometheus.yml:/etc/prometheus/prometheus.yml
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--web.enable-lifecycle'
    networks:
      - notification-network

  grafana:
    image: grafana/grafana
    ports:
      - "3000:3000"
    environment:
      GF_SECURITY_ADMIN_PASSWORD: admin
      GF_INSTALL_PLUGINS: grafana-clock-panel,grafana-simple-json-datasource
    volumes:
      - ./monitoring/grafana/dashboards:/var/lib/grafana/dashboards
      - ./monitoring/grafana/provisioning:/etc/grafana/provisioning
      - grafana_data:/var/lib/grafana
    networks:
      - notification-network

volumes:
  postgres_data:
  rabbitmq_data:
  redis_data:
  grafana_data:

networks:
  notification-network:
    driver: bridge

version: '3.8'

services:
  postgresql:
    image: postgres:14
    environment:
      POSTGRES_DB: notifications
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 10s
      timeout: 5s
      retries: 5

  redis:
    image: redis:6-alpine
    ports:
      - "6379:6379"
    command: redis-server --appendonly yes
    volumes:
      - redis_data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 3s
      retries: 5

  rabbitmq:
    image: rabbitmq:3-management
    environment:
      RABBITMQ_DEFAULT_USER: guest
      RABBITMQ_DEFAULT_PASS: guest
    ports:
      - "5672:5672"
      - "15672:15672"
    healthcheck:
      test: ["CMD", "rabbitmqctl", "status"]
      interval: 10s
      timeout: 5s
      retries: 5

  mailhog:
    image: mailhog/mailhog
    ports:
      - "1025:1025"
      - "8025:8025"

  notification-service:
    build: .
    ports:
      - "8080:8080"
    environment:
      SPRING_PROFILES_ACTIVE: docker
      SPRING_RABBITMQ_HOST: rabbitmq
      SPRING_REDIS_HOST: redis
      SPRING_DATASOURCE_URL: jdbc:postgresql://postgresql:5432/notifications
      SPRING_DATASOURCE_USERNAME: postgres
      SPRING_DATASOURCE_PASSWORD: password
      SPRING_MAIL_HOST: mailhog
      SPRING_MAIL_PORT: 1025
    depends_on:
      postgresql:
        condition: service_healthy
      redis:
        condition: service_healthy
      rabbitmq:
        condition: service_healthy
      mailhog:
        condition: service_started
    deploy:
      replicas: 3

  prometheus:
    image: prom/prometheus
    ports:
      - "9090:9090"
    volumes:
      - ./monitoring/prometheus.yml:/etc/prometheus/prometheus.yml
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'

  grafana:
    image: grafana/grafana
    ports:
      - "3000:3000"
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=admin
    volumes:
      - ./monitoring/grafana/dashboards:/var/lib/grafana/dashboards
      - ./monitoring/grafana/provisioning:/etc/grafana/provisioning

volumes:
  postgres_data:
  redis_data:

FROM eclipse-temurin:17-jre-jammy

# Set working directory
WORKDIR /app

# Create non-root user
RUN groupadd -r spring && useradd -r -g spring spring
RUN chown -R spring:spring /app
USER spring

# Copy JAR file
COPY target/notification-service-*.jar app.jar

# Create directories for logs and attachments
RUN mkdir -p logs attachments

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=60s --retries=3 \
    CMD curl -f http://localhost:8080/manage/health || exit 1

# Expose port
EXPOSE 8080

# JVM options (—É–±—Ä–∞–ª–∏ MaxPermSize)
ENV JAVA_OPTS="-Xms512m -Xmx1024m -XX:MaxMetaspaceSize=256m -XX:+UseG1GC -XX:MaxGCPauseMillis=200 -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/app/logs -Djava.security.egd=file:/dev/./urandom"

# Run application
ENTRYPOINT ["sh", "-c", "java $JAVA_OPTS -jar app.jar"]

apiVersion: v1
kind: ConfigMap
metadata:
  name: notification-service-config
  namespace: notification
data:
  application.yml: |
    spring:
      application:
        name: notification-service
      rabbitmq:
        host: rabbitmq
        port: 5672
      redis:
        host: redis
        port: 6379
      datasource:
        url: jdbc:postgresql://postgresql:5432/notifications
      jpa:
        hibernate:
          ddl-auto: validate
    management:
      endpoints:
        web:
          exposure:
            include: health,metrics,prometheus
      endpoint:
        health:
          show-details: always
    notification:
      retry:
        max-attempts: 3
      rate-limit:
        requests-per-minute: 1000

apiVersion: apps/v1
kind: Deployment
metadata:
  name: notification-service
  namespace: notification
spec:
  replicas: 3
  selector:
    matchLabels:
      app: notification-service
  template:
    metadata:
      labels:
        app: notification-service
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "8080"
        prometheus.io/path: "/actuator/prometheus"
    spec:
      containers:
        - name: notification-service
          image: notification-service:latest
          ports:
            - containerPort: 8080
          env:
            - name: SPRING_PROFILES_ACTIVE
              value: "kubernetes"
            - name: SPRING_RABBITMQ_HOST
              value: "rabbitmq"
            - name: SPRING_REDIS_HOST
              value: "redis"
            - name: SPRING_DATASOURCE_URL
              value: "jdbc:postgresql://postgresql:5432/notifications"
            - name: JAVA_OPTS
              value: "-Xms512m -Xmx1024m -XX:+UseG1GC"
          resources:
            requests:
              memory: "512Mi"
              cpu: "250m"
            limits:
              memory: "1024Mi"
              cpu: "500m"
          livenessProbe:
            httpGet:
              path: /actuator/health/liveness
              port: 8080
            initialDelaySeconds: 60
            periodSeconds: 30
          readinessProbe:
            httpGet:
              path: /actuator/health/readiness
              port: 8080
            initialDelaySeconds: 30
            periodSeconds: 20
          volumeMounts:
            - name: logs-volume
              mountPath: /app/logs
            - name: attachments-volume
              mountPath: /app/attachments
      volumes:
        - name: logs-volume
          emptyDir: {}
        - name: attachments-volume
          emptyDir: {}
      imagePullSecrets:
        - name: registry-credentials

apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: notification-service-hpa
  namespace: notification
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: notification-service
  minReplicas: 2
  maxReplicas: 10
  metrics:
    - type: Resource
      resource:
        name: cpu
        target:
          type: Utilization
          averageUtilization: 70
    - type: Resource
      resource:
        name: memory
        target:
          type: Utilization
          averageUtilization: 80
  behavior:
    scaleDown:
      stabilizationWindowSeconds: 300
      policies:
        - type: Percent
          value: 50
          periodSeconds: 60
    scaleUp:
      stabilizationWindowSeconds: 60
      policies:
        - type: Percent
          value: 100
          periodSeconds: 60

apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: notification-service-ingress
  namespace: notification
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    nginx.ingress.kubernetes.io/proxy-body-size: "10m"
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
spec:
  tls:
    - hosts:
        - notifications.example.com
      secretName: notification-service-tls
  rules:
    - host: notifications.example.com
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: notification-service
                port:
                  number: 8080
          - path: /actuator/health
            pathType: Prefix
            backend:
              service:
                name: notification-service
                port:
                  number: 8080
          - path: /v3/api-docs
            pathType: Prefix
            backend:
              service:
                name: notification-service
                port:
                  number: 8080

apiVersion: v1
kind: Namespace
metadata:
  name: notification
  labels:
    name: notification
    environment: production

apiVersion: v1
kind: Secret
metadata:
  name: notification-service-secrets
  namespace: notification
type: Opaque
data:
  spring-datasource-username: cG9zdGdyZXM= # postgres
  spring-datasource-password: cGFzc3dvcmQ= # password
  smtp-username: eW91ci1lbWFpbEBnbWFpbC5jb20= # your-email@gmail.com
  smtp-password: eW91ci1hcHAta2V5 # your-app-key
  jwt-secret: bXlTZWNyZXRLZXlteVNlY3JldEtleW15U2VjcmV0S2V5bXlTZWNyZXRLZXk= # base64 encoded secret

apiVersion: v1
kind: Service
metadata:
  name: notification-service
  namespace: notification
  labels:
    app: notification-service
spec:
  selector:
    app: notification-service
  ports:
    - name: http
      port: 8080
      targetPort: 8080
      protocol: TCP
    - name: metrics
      port: 8081
      targetPort: 8081
      protocol: TCP
  type: ClusterIP
---
apiVersion: v1
kind: Service
metadata:
  name: notification-service-external
  namespace: notification
  labels:
    app: notification-service
spec:
  selector:
    app: notification-service
  ports:
    - name: http
      port: 80
      targetPort: 8080
      protocol: TCP
  type: LoadBalancer

#!/bin/bash

set -e

# Configuration
BACKUP_DIR="./backups"
DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_FILE="redis_backup_$DATE.rdb"

echo "Starting Redis backup..."

# Create backup directory if it doesn't exist
mkdir -p "$BACKUP_DIR"

# Check if Redis is running
if ! redis-cli ping > /dev/null 2>&1; then
    echo "Error: Redis is not running or not accessible"
    exit 1
fi

# Create backup
echo "Creating Redis backup..."
redis-cli SAVE

# Find Redis data directory
REDIS_DIR=$(redis-cli config get dir | tail -n 1)
DUMP_FILE="$REDIS_DIR/dump.rdb"

if [ ! -f "$DUMP_FILE" ]; then
    echo "Error: Redis dump file not found at $DUMP_FILE"
    exit 1
fi

# Copy backup file
cp "$DUMP_FILE" "$BACKUP_DIR/$BACKUP_FILE"

# Compress backup
echo "Compressing backup..."
gzip "$BACKUP_DIR/$BACKUP_FILE"

# Clean up old backups (keep last 30 days)
find "$BACKUP_DIR" -name "redis_backup_*.rdb.gz" -mtime +30 -delete

echo "Redis backup completed: $BACKUP_DIR/$BACKUP_FILE.gz"

# Display backup information
echo "Backup size: $(du -h "$BACKUP_DIR/$BACKUP_FILE.gz" | cut -f1)"
echo "Available backups:"
ls -la "$BACKUP_DIR"/redis_backup_*.rdb.gz

#!/bin/bash

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Configuration
APP_NAME="notification-service"
VERSION="${1:-1.0.0}"
DOCKER_REGISTRY="${DOCKER_REGISTRY:-your-registry}"
NAMESPACE="${NAMESPACE:-notification}"
ENVIRONMENT="${ENVIRONMENT:-production}"
KUBE_CONTEXT="${KUBE_CONTEXT:-production-cluster}"

# Logging functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Validation functions
validate_environment() {
    log_info "Validating environment..."

    # Check required tools
    command -v docker >/dev/null 2>&1 || { log_error "Docker is required but not installed"; exit 1; }
    command -v kubectl >/dev/null 2>&1 || { log_error "kubectl is required but not installed"; exit 1; }
    command -v mvn >/dev/null 2>&1 || { log_error "Maven is required but not installed"; exit 1; }

    # Check Kubernetes context
    if ! kubectl config current-context >/dev/null 2>&1; then
        log_error "No Kubernetes context configured"
        exit 1
    fi

    log_info "Current Kubernetes context: $(kubectl config current-context)"
}

check_dependencies() {
    log_info "Checking cluster dependencies..."

    # Check if namespace exists
    if ! kubectl get namespace "$NAMESPACE" >/dev/null 2>&1; then
        log_warning "Namespace $NAMESPACE does not exist, creating..."
        kubectl create namespace "$NAMESPACE"
    fi

    # Check for required secrets
    if ! kubectl get secret -n "$NAMESPACE" notification-service-secrets >/dev/null 2>&1; then
        log_error "Required secret 'notification-service-secrets' not found in namespace $NAMESPACE"
        log_error "Please create the secret using: kubectl apply -f k8s/secret.yaml"
        exit 1
    fi
}

build_application() {
    log_info "Building application..."

    # Run tests
    log_info "Running tests..."
    if ! ./mvnw clean test; then
        log_error "Tests failed! Aborting deployment."
        exit 1
    fi

    # Build JAR
    log_info "Building JAR file..."
    if ! ./mvnw clean package -DskipTests; then
        log_error "Build failed!"
        exit 1
    fi

    log_success "Application built successfully"
}

build_docker_image() {
    log_info "Building Docker image..."

    local image_tag="$DOCKER_REGISTRY/$APP_NAME:$VERSION"
    local latest_tag="$DOCKER_REGISTRY/$APP_NAME:latest"

    # Build image
    if ! docker build -t "$image_tag" .; then
        log_error "Docker build failed!"
        exit 1
    fi

    # Tag as latest
    docker tag "$image_tag" "$latest_tag"

    log_success "Docker image built: $image_tag"
}

push_docker_image() {
    log_info "Pushing Docker image to registry..."

    local image_tag="$DOCKER_REGISTRY/$APP_NAME:$VERSION"
    local latest_tag="$DOCKER_REGISTRY/$APP_NAME:latest"

    # Check if we're logged in to registry
    if ! docker info | grep -q "$DOCKER_REGISTRY"; then
        log_warning "Not logged in to $DOCKER_REGISTRY, attempting to login..."
        if [ -n "$DOCKER_USERNAME" ] && [ -n "$DOCKER_PASSWORD" ]; then
            echo "$DOCKER_PASSWORD" | docker login -u "$DOCKER_USERNAME" --password-stdin "$DOCKER_REGISTRY"
        else
            log_error "Docker registry credentials not provided"
            exit 1
        fi
    fi

    # Push images
    if ! docker push "$image_tag"; then
        log_error "Failed to push image $image_tag"
        exit 1
    fi

    if ! docker push "$latest_tag"; then
        log_error "Failed to push image $latest_tag"
        exit 1
    fi

    log_success "Docker images pushed successfully"
}

deploy_kubernetes() {
    log_info "Deploying to Kubernetes..."

    # Apply configuration in order
    log_info "Applying Kubernetes manifests..."

    # Namespace (if not exists)
    kubectl apply -f k8s/namespace.yaml

    # ConfigMap
    kubectl apply -f k8s/configmap.yaml -n "$NAMESPACE"

    # Secret (should already exist, but verify)
    if [ -f "k8s/secret.yaml" ]; then
        kubectl apply -f k8s/secret.yaml -n "$NAMESPACE"
    fi

    # Deployment
    log_info "Updating deployment image..."
    kubectl set image deployment/"$APP_NAME" "$APP_NAME=$DOCKER_REGISTRY/$APP_NAME:$VERSION" -n "$NAMESPACE" --record

    # Wait for rollout
    log_info "Waiting for rollout to complete..."
    if ! kubectl rollout status deployment/"$APP_NAME" -n "$NAMESPACE" --timeout=600s; then
        log_error "Deployment rollout failed!"

        # Show rollout history
        log_info "Rollout history:"
        kubectl rollout history deployment/"$APP_NAME" -n "$NAMESPACE"

        # Show pod status for debugging
        log_info "Current pod status:"
        kubectl get pods -n "$NAMESPACE" -l app="$APP_NAME"

        exit 1
    fi

    log_success "Kubernetes deployment completed successfully"
}

run_health_checks() {
    log_info "Running health checks..."

    local retries=30
    local count=0

    # Get service URL
    local service_url=$(kubectl get service -n "$NAMESPACE" "$APP_NAME" -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
    if [ -z "$service_url" ]; then
        service_url=$(kubectl get service -n "$NAMESPACE" "$APP_NAME" -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
    fi

    if [ -z "$service_url" ]; then
        log_warning "Cannot determine service URL, using port-forward for health check"
        # Use port-forward for health check
        kubectl port-forward -n "$NAMESPACE" deployment/"$APP_NAME" 8080:8080 &
        local pf_pid=$!
        sleep 5

        while [ $count -lt $retries ]; do
            if curl -s -f http://localhost:8080/actuator/health >/dev/null 2>&1; then
                kill $pf_pid
                log_success "Health check passed"
                return 0
            fi
            count=$((count + 1))
            sleep 10
            log_info "Health check attempt $count/$retries..."
        done

        kill $pf_pid
    else
        # Use actual service URL
        while [ $count -lt $retries ]; do
            if curl -s -f "http://$service_url/actuator/health" >/dev/null 2>&1; then
                log_success "Health check passed"
                return 0
            fi
            count=$((count + 1))
            sleep 10
            log_info "Health check attempt $count/$retries..."
        done
    fi

    log_error "Health check failed after $retries attempts"
    return 1
}

cleanup() {
    log_info "Cleaning up..."

    # Remove local Docker images to save space
    docker rmi "$DOCKER_REGISTRY/$APP_NAME:$VERSION" 2>/dev/null || true
    docker rmi "$DOCKER_REGISTRY/$APP_NAME:latest" 2>/dev/null || true

    log_info "Cleanup completed"
}

main() {
    log_info "Starting deployment of $APP_NAME version $VERSION to $ENVIRONMENT"
    log_info "Registry: $DOCKER_REGISTRY, Namespace: $NAMESPACE"

    # Execute deployment steps
    validate_environment
    check_dependencies
    build_application
    build_docker_image
    push_docker_image
    deploy_kubernetes
    run_health_checks
    cleanup

    log_success "Deployment completed successfully! üöÄ"

    # Show deployment info
    log_info "Deployment information:"
    kubectl get deployment,svc,pods -n "$NAMESPACE" -l app="$APP_NAME"
}

# Handle script interruption
trap 'log_error "Deployment interrupted"; exit 1' INT TERM

# Run main function
main "$@"

#!/bin/bash

set -e

# Configuration
SERVICE_URL="http://localhost:8080"
MAX_ATTEMPTS=30
ATTEMPT=0

echo "Waiting for notification service to be healthy..."

while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
    if curl -s -f "$SERVICE_URL/actuator/health" > /dev/null 2>&1; then
        echo "Service is healthy!"
        exit 0
    fi

    echo "Attempt $((ATTEMPT + 1))/$MAX_ATTEMPTS failed. Retrying in 5 seconds..."
    sleep 5
    ATTEMPT=$((ATTEMPT + 1))
done

echo "Service failed to become healthy within the expected time."
exit 1

#!/bin/bash

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Configuration
DB_HOST="${DB_HOST:-localhost}"
DB_PORT="${DB_PORT:-5432}"
DB_NAME="${DB_NAME:-notifications}"
DB_USER="${DB_USER:-postgres}"
DB_PASSWORD="${DB_PASSWORD:-}"
FLYWAY_ACTION="${1:-migrate}" # migrate, info, validate, repair

# Logging functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

validate_environment() {
    log_info "Validating environment..."

    # Check required tools
    command -v psql >/dev/null 2>&1 || { log_error "PostgreSQL client (psql) is required but not installed"; exit 1; }
    command -v mvn >/dev/null 2>&1 || { log_error "Maven is required but not installed"; exit 1; }

    # Check database password
    if [ -z "$DB_PASSWORD" ]; then
        log_error "Database password is required. Set DB_PASSWORD environment variable."
        exit 1
    fi

    # Export password for psql
    export PGPASSWORD="$DB_PASSWORD"
}

wait_for_database() {
    log_info "Waiting for database to be ready..."

    local max_attempts=30
    local attempt=1

    while [ $attempt -le $max_attempts ]; do
        if psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" -c '\q' 2>/dev/null; then
            log_success "Database is ready!"
            return 0
        fi

        log_info "Database is unavailable - attempt $attempt/$max_attempts - sleeping 5 seconds..."
        sleep 5
        attempt=$((attempt + 1))
    done

    log_error "Database is not ready after $max_attempts attempts"
    exit 1
}

check_database_connection() {
    log_info "Checking database connection..."

    if ! psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" -c 'SELECT version();' >/dev/null 2>&1; then
        log_error "Cannot connect to database $DB_NAME at $DB_HOST:$DB_PORT"
        log_error "Please check your database configuration and credentials"
        exit 1
    fi

    log_success "Database connection successful"
}

create_database_if_not_exists() {
    log_info "Checking if database exists..."

    if ! psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" -c '\q' 2>/dev/null; then
        log_warning "Database $DB_NAME does not exist, attempting to create..."

        # Connect to postgres database to create new database
        if psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "postgres" -c "CREATE DATABASE $DB_NAME;" 2>/dev/null; then
            log_success "Database $DB_NAME created successfully"
        else
            log_error "Failed to create database $DB_NAME"
            exit 1
        fi
    else
        log_success "Database $DB_NAME already exists"
    fi
}

check_flyway_metadata() {
    log_info "Checking Flyway metadata..."

    if psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" -c "SELECT table_name FROM information_schema.tables WHERE table_name = 'flyway_schema_history';" | grep -q "flyway_schema_history"; then
        log_success "Flyway metadata table exists"
        return 0
    else
        log_warning "Flyway metadata table does not exist (this is normal for new databases)"
        return 1
    fi
}

run_flyway_action() {
    local action="$1"
    local flyway_command="flyway:$action"

    log_info "Running Flyway $action..."

    case $action in
        "migrate")
            log_info "Applying database migrations..."
            ;;
        "info")
            log_info "Showing migration information..."
            ;;
        "validate")
            log_info "Validating migrations..."
            ;;
        "repair")
            log_info "Repairing Flyway metadata..."
            ;;
        "clean")
            log_warning "WARNING: This will destroy all database objects!"
            read -p "Are you sure you want to continue? (y/N): " -n 1 -r
            echo
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                log_info "Clean operation cancelled"
                exit 0
            fi
            ;;
    esac

    # Run Flyway command
    if ./mvnw -q "$flyway_command" \
        -Dflyway.url="jdbc:postgresql://$DB_HOST:$DB_PORT/$DB_NAME" \
        -Dflyway.user="$DB_USER" \
        -Dflyway.password="$DB_PASSWORD" \
        -Dflyway.locations="filesystem:src/main/resources/db/migration"; then
        log_success "Flyway $action completed successfully"
    else
        log_error "Flyway $action failed"
        exit 1
    fi
}

show_migration_info() {
    log_info "Current migration status:"

    psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" << EOF
SELECT
    installed_rank,
    version,
    description,
    type,
    script,
    installed_by,
    installed_on,
    execution_time,
    success
FROM flyway_schema_history
ORDER BY installed_rank;
EOF
}

show_database_info() {
    log_info "Database information:"

    echo "Database: $DB_NAME"
    echo "Host: $DB_HOST:$DB_PORT"
    echo "User: $DB_USER"

    # Show table counts
    log_info "Table statistics:"
    psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" -c "
    SELECT
        table_name,
        (SELECT count(*) FROM notifications.\"\" || table_name || \"\") as row_count
    FROM information_schema.tables
    WHERE table_schema = 'public'
    AND table_type = 'BASE TABLE'
    ORDER BY table_name;" 2>/dev/null || log_warning "Could not retrieve table statistics"
}

backup_database() {
    local backup_dir="./backups"
    local timestamp=$(date +%Y%m%d_%H%M%S)
    local backup_file="backup_${DB_NAME}_${timestamp}.sql"

    log_info "Creating database backup..."

    mkdir -p "$backup_dir"

    if pg_dump -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" > "$backup_dir/$backup_file"; then
        log_success "Backup created: $backup_dir/$backup_file"

        # Compress backup
        gzip "$backup_dir/$backup_file"
        log_success "Backup compressed: $backup_dir/$backup_file.gz"

        # Clean up old backups (keep last 7)
        find "$backup_dir" -name "backup_${DB_NAME}_*.sql.gz" -type f | sort -r | tail -n +8 | xargs rm -f
    else
        log_error "Backup failed!"
        exit 1
    fi
}

main() {
    log_info "Starting database migration process"
    log_info "Database: $DB_NAME, Host: $DB_HOST:$DB_PORT, Action: $FLYWAY_ACTION"

    # Validate environment
    validate_environment

    # Wait for database
    wait_for_database

    # Check connection
    check_database_connection

    # Create database if needed
    create_database_if_not_exists

    # Create backup before destructive operations
    if [ "$FLYWAY_ACTION" = "migrate" ] || [ "$FLYWAY_ACTION" = "clean" ]; then
        backup_database
    fi

    # Run Flyway action
    run_flyway_action "$FLYWAY_ACTION"

    # Show migration info for migrate action
    if [ "$FLYWAY_ACTION" = "migrate" ]; then
        show_migration_info
        show_database_info
    fi

    log_success "Database migration process completed successfully! ‚úÖ"
}

# Handle script interruption
trap 'log_error "Migration interrupted"; exit 1' INT TERM

# Run main function
main "$@"

# Cleanup
unset PGPASSWORD

#!/bin/bash

# –°–∫—Ä–∏–ø—Ç –¥–ª—è –∑–∞–ø—É—Å–∫–∞ PostgreSQL –≤ Docker
echo "Starting PostgreSQL in Docker..."

docker run --name notification-postgres \
  -e POSTGRES_DB=notifications \
  -e POSTGRES_USER=postgres \
  -e POSTGRES_PASSWORD=password \
  -p 5432:5432 \
  -d postgres:14-alpine

echo "PostgreSQL started on port 5432"
echo "Database: notifications"
echo "Username: postgres"
echo "Password: password"

package com.notificationservice.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Profile;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.JavaMailSenderImpl;

@Configuration
@Profile("dev")
public class DevMailConfig {

    @Bean
    public JavaMailSender javaMailSender() {
        JavaMailSenderImpl mailSender = new JavaMailSenderImpl();
        // –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –¥–ª—è –∑–∞–≥–ª—É—à–∫–∏ - –Ω–∏—á–µ–≥–æ –Ω–µ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º
        mailSender.setHost("localhost");
        mailSender.setPort(1025);

        return mailSender;
    }
}

package com.notificationservice.config;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.security.Keys;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.filter.OncePerRequestFilter;

import javax.crypto.SecretKey;
import java.io.IOException;
import java.util.List;
import java.util.stream.Collectors;

@Slf4j
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    @Value("${jwt.secret:defaultSecretKeyForDevelopmentOnlyChangeInProduction}")
    private String jwtSecret;

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain) throws ServletException, IOException {

        String header = request.getHeader("Authorization");

        if (header == null || !header.startsWith("Bearer ")) {
            filterChain.doFilter(request, response);
            return;
        }

        String token = header.substring(7);

        try {
            SecretKey secretKey = Keys.hmacShaKeyFor(jwtSecret.getBytes());

            Claims claims = Jwts.parserBuilder()
                    .setSigningKey(secretKey)
                    .build()
                    .parseClaimsJws(token)
                    .getBody();

            String username = claims.getSubject();

            @SuppressWarnings("unchecked")
            List<String> roles = claims.get("roles", List.class);

            List<SimpleGrantedAuthority> authorities = roles.stream()
                    .map(SimpleGrantedAuthority::new)
                    .collect(Collectors.toList());

            UsernamePasswordAuthenticationToken authentication =
                    new UsernamePasswordAuthenticationToken(username, null, authorities);

            SecurityContextHolder.getContext().setAuthentication(authentication);

        } catch (Exception e) {
            log.error("JWT authentication failed: {}", e.getMessage());
            SecurityContextHolder.clearContext();
        }

        filterChain.doFilter(request, response);
    }
}

package com.notificationservice.config;

import io.micrometer.core.instrument.MeterRegistry;
import org.springframework.boot.actuate.autoconfigure.metrics.MeterRegistryCustomizer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class MonitoringConfig {

    @Bean
    public MeterRegistryCustomizer<MeterRegistry> metricsCommonTags() {
        return registry -> registry.config()
                .commonTags("application", "notification-service")
                .commonTags("environment", System.getenv().getOrDefault("ENVIRONMENT", "development"));
    }
}

package com.notificationservice.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.annotation.Scheduled;

import com.notificationservice.service.EnhancedEmailService;

import lombok.RequiredArgsConstructor;

@Configuration
@RequiredArgsConstructor
public class MultipleSmtpConfig {

    private final EnhancedEmailService enhancedEmailService;

    @Scheduled(fixedRate = 300000) // 5 minutes
    public void refreshEmailProviders() {
        enhancedEmailService.refreshProviders();
    }
}

package com.notificationservice.config;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.info.Contact;
import io.swagger.v3.oas.models.info.License;
import io.swagger.v3.oas.models.security.SecurityScheme;
import io.swagger.v3.oas.models.security.SecurityRequirement;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class OpenApiConfig {

    @Bean
    public OpenAPI notificationServiceOpenAPI() {
        return new OpenAPI()
                .info(new Info()
                        .title("Notification Service API")
                        .description("Microservice for handling email and push notifications")
                        .version("v1.0.0")
                        .contact(new Contact()
                                .name("Development Team")
                                .email("dev@company.com"))
                        .license(new License()
                                .name("Apache 2.0")
                                .url("http://springdoc.org")))
                .addSecurityItem(new SecurityRequirement().addList("bearerAuth"))
                .components(new io.swagger.v3.oas.models.Components()
                        .addSecuritySchemes("bearerAuth", new SecurityScheme()
                                .name("bearerAuth")
                                .type(SecurityScheme.Type.HTTP)
                                .scheme("bearer")
                                .bearerFormat("JWT")));
    }
}

package com.notificationservice.config;

import org.springframework.amqp.core.*;
import org.springframework.amqp.rabbit.config.RetryInterceptorBuilder;
import org.springframework.amqp.rabbit.config.SimpleRabbitListenerContainerFactory;
import org.springframework.amqp.rabbit.connection.CachingConnectionFactory;
import org.springframework.amqp.rabbit.connection.ConnectionFactory;
import org.springframework.amqp.rabbit.core.RabbitAdmin;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.amqp.rabbit.retry.RejectAndDontRequeueRecoverer;
import org.springframework.amqp.support.converter.Jackson2JsonMessageConverter;
import org.springframework.amqp.support.converter.MessageConverter;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.retry.interceptor.RetryOperationsInterceptor;

@Configuration
public class RabbitMQConfig {

    @Value("${spring.rabbitmq.host:localhost}")
    private String host;

    @Value("${spring.rabbitmq.port:5672}")
    private int port;

    @Value("${spring.rabbitmq.username:guest}")
    private String username;

    @Value("${spring.rabbitmq.password:guest}")
    private String password;

    public static final String NOTIFICATION_QUEUE = "notification.queue";
    public static final String NOTIFICATION_DLQ = "notification.dlq";
    public static final String NOTIFICATION_EXCHANGE = "notification.exchange";
    public static final String NOTIFICATION_DLQ_EXCHANGE = "notification.dlq.exchange";
    public static final String NOTIFICATION_ROUTING_KEY = "notification.routing.key";
    public static final String NOTIFICATION_DLQ_ROUTING_KEY = "notification.dlq.routing.key";

    // –î–æ–±–∞–≤–ª—è–µ–º –Ω–µ–¥–æ—Å—Ç–∞—é—â–∏–µ –∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã
    public static final String EMAIL_QUEUE = "email.queue";
    public static final String PUSH_QUEUE = "push.queue";
    public static final String EMAIL_ROUTING_KEY = "email.routing.key";
    public static final String PUSH_ROUTING_KEY = "push.routing.key";

    @Bean
    public ConnectionFactory connectionFactory() {
        CachingConnectionFactory connectionFactory = new CachingConnectionFactory();
        connectionFactory.setHost(host);
        connectionFactory.setPort(port);
        connectionFactory.setUsername(username);
        connectionFactory.setPassword(password);
        connectionFactory.setChannelCacheSize(25);
        return connectionFactory;
    }

    @Bean
    public RabbitTemplate rabbitTemplate(ConnectionFactory connectionFactory) {
        RabbitTemplate rabbitTemplate = new RabbitTemplate(connectionFactory);
        rabbitTemplate.setMessageConverter(jsonMessageConverter());
        rabbitTemplate.setChannelTransacted(true);
        rabbitTemplate.setReplyTimeout(60000);
        rabbitTemplate.setReceiveTimeout(60000);
        return rabbitTemplate;
    }

    @Bean
    public RabbitAdmin rabbitAdmin(ConnectionFactory connectionFactory) {
        return new RabbitAdmin(connectionFactory);
    }

    @Bean
    public MessageConverter jsonMessageConverter() {
        return new Jackson2JsonMessageConverter();
    }

    @Bean
    public Queue notificationQueue() {
        return QueueBuilder.durable(NOTIFICATION_QUEUE)
                .withArgument("x-dead-letter-exchange", NOTIFICATION_DLQ_EXCHANGE)
                .withArgument("x-dead-letter-routing-key", NOTIFICATION_DLQ_ROUTING_KEY)
                .build();
    }

    @Bean
    public Queue notificationDLQ() {
        return QueueBuilder.durable(NOTIFICATION_DLQ).build();
    }

    // –î–æ–±–∞–≤–ª—è–µ–º –æ—á–µ—Ä–µ–¥–∏ –¥–ª—è email –∏ push
    @Bean
    public Queue emailQueue() {
        return QueueBuilder.durable(EMAIL_QUEUE)
                .withArgument("x-dead-letter-exchange", NOTIFICATION_DLQ_EXCHANGE)
                .withArgument("x-dead-letter-routing-key", NOTIFICATION_DLQ_ROUTING_KEY)
                .build();
    }

    @Bean
    public Queue pushQueue() {
        return QueueBuilder.durable(PUSH_QUEUE)
                .withArgument("x-dead-letter-exchange", NOTIFICATION_DLQ_EXCHANGE)
                .withArgument("x-dead-letter-routing-key", NOTIFICATION_DLQ_ROUTING_KEY)
                .build();
    }

    @Bean
    public DirectExchange notificationExchange() {
        return new DirectExchange(NOTIFICATION_EXCHANGE);
    }

    @Bean
    public DirectExchange notificationDLQExchange() {
        return new DirectExchange(NOTIFICATION_DLQ_EXCHANGE);
    }

    @Bean
    public Binding notificationBinding(Queue notificationQueue, DirectExchange notificationExchange) {
        return BindingBuilder.bind(notificationQueue)
                .to(notificationExchange)
                .with(NOTIFICATION_ROUTING_KEY);
    }

    @Bean
    public Binding notificationDLQBinding(Queue notificationDLQ, DirectExchange notificationDLQExchange) {
        return BindingBuilder.bind(notificationDLQ)
                .to(notificationDLQExchange)
                .with(NOTIFICATION_DLQ_ROUTING_KEY);
    }

    // –î–æ–±–∞–≤–ª—è–µ–º –±–∏–Ω–¥–∏–Ω–≥–∏ –¥–ª—è email –∏ push
    @Bean
    public Binding emailBinding(Queue emailQueue, DirectExchange notificationExchange) {
        return BindingBuilder.bind(emailQueue)
                .to(notificationExchange)
                .with(EMAIL_ROUTING_KEY);
    }

    @Bean
    public Binding pushBinding(Queue pushQueue, DirectExchange notificationExchange) {
        return BindingBuilder.bind(pushQueue)
                .to(notificationExchange)
                .with(PUSH_ROUTING_KEY);
    }

    @Bean
    public RetryOperationsInterceptor retryInterceptor() {
        return RetryInterceptorBuilder.stateless()
                .maxAttempts(3)
                .backOffOptions(1000, 2.0, 10000)
                .recoverer(new RejectAndDontRequeueRecoverer())
                .build();
    }

    @Bean
    public SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory(ConnectionFactory connectionFactory) {
        SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();
        factory.setConnectionFactory(connectionFactory);
        factory.setMessageConverter(jsonMessageConverter());
        factory.setConcurrentConsumers(3);
        factory.setMaxConcurrentConsumers(10);
        factory.setPrefetchCount(1);
        factory.setDefaultRequeueRejected(false);
        factory.setAdviceChain(retryInterceptor());
        return factory;
    }
}

package com.notificationservice.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.connection.RedisStandaloneConfiguration;
import org.springframework.data.redis.connection.jedis.JedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.StringRedisSerializer;

@Configuration
public class RedisConfig {

    @Value("${spring.redis.host:localhost}")
    private String redisHost;

    @Value("${spring.redis.port:6379}")
    private int redisPort;

    @Value("${spring.redis.password:}")
    private String redisPassword;

    @Bean
    public RedisConnectionFactory redisConnectionFactory() {
        RedisStandaloneConfiguration config = new RedisStandaloneConfiguration();
        config.setHostName(redisHost);
        config.setPort(redisPort);
        if (!redisPassword.isEmpty()) {
            config.setPassword(redisPassword);
        }
        return new JedisConnectionFactory(config);
    }

    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory connectionFactory) {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(connectionFactory);
        template.setKeySerializer(new StringRedisSerializer());
        template.setValueSerializer(new GenericJackson2JsonRedisSerializer());
        template.setHashKeySerializer(new StringRedisSerializer());
        template.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());
        template.setEnableTransactionSupport(true);
        template.afterPropertiesSet();
        return template;
    }
}

package com.notificationservice.config;

import io.github.resilience4j.circuitbreaker.CircuitBreakerConfig;
import io.github.resilience4j.circuitbreaker.CircuitBreakerRegistry;
import io.github.resilience4j.retry.RetryConfig;
import io.github.resilience4j.retry.RetryRegistry;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.time.Duration;

@Configuration
public class Resilience4jConfig {

    @Bean
    public CircuitBreakerRegistry circuitBreakerRegistry() {
        CircuitBreakerConfig config = CircuitBreakerConfig.custom()
                .failureRateThreshold(50)
                .slowCallRateThreshold(50)
                .slowCallDurationThreshold(Duration.ofSeconds(5))
                .waitDurationInOpenState(Duration.ofSeconds(10))
                .permittedNumberOfCallsInHalfOpenState(3)
                .minimumNumberOfCalls(10)
                .slidingWindowType(CircuitBreakerConfig.SlidingWindowType.COUNT_BASED)
                .slidingWindowSize(20)
                .build();

        return CircuitBreakerRegistry.of(config);
    }

    @Bean
    public RetryRegistry retryRegistry() {
        RetryConfig config = RetryConfig.custom()
                .maxAttempts(3)
                .waitDuration(Duration.ofSeconds(2))
                .retryExceptions(Exception.class)
                .ignoreExceptions(IllegalArgumentException.class)
                .build();

        return RetryRegistry.of(config);
    }
}

package com.notificationservice.config;

import org.springframework.boot.web.client.RestTemplateBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestTemplate;

import java.time.Duration;

@Configuration
public class RestTemplateConfig {

    @Bean
    public RestTemplate restTemplate(RestTemplateBuilder builder) {
        return builder
                .setConnectTimeout(Duration.ofSeconds(10))
                .setReadTimeout(Duration.ofSeconds(30))
                .build();
    }
}

package com.notificationservice.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.annotation.EnableScheduling;

@Configuration
@EnableScheduling
public class SchedulingConfig {
    // Scheduling is enabled for retry mechanisms and cleanup tasks
}

package com.notificationservice.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
                .csrf(csrf -> csrf.disable())
                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .authorizeHttpRequests(authz -> authz
                        // Public endpoints
                        .requestMatchers("/manage/health/**").permitAll()
                        .requestMatchers("/actuator/**").permitAll()
                        .requestMatchers("/v3/api-docs/**", "/swagger-ui/**", "/swagger-ui.html").permitAll()
                        .requestMatchers("/h2-console/**").permitAll()

                        // Protected endpoints - require authentication
                        .requestMatchers("/api/v1/notifications/**").authenticated()
                        .requestMatchers("/api/v1/templates/**").authenticated()
                        .requestMatchers("/api/v1/analytics/**").authenticated()
                        .requestMatchers("/api/v1/bulk/**").authenticated()
                        .requestMatchers("/api/v1/retry/**").authenticated()

                        .anyRequest().authenticated()
                );

        // For H2 console in development
        http.headers(headers -> headers
                .frameOptions(frameOptions -> frameOptions.disable())
        );

        return http.build();
    }
}

package com.notificationservice.controller;

import com.notificationservice.dto.NotificationStats;
import com.notificationservice.service.AnalyticsService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDate;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/analytics")
@RequiredArgsConstructor
@Tag(name = "Analytics", description = "API for notification analytics and statistics")
public class AnalyticsController {

    private final AnalyticsService analyticsService;

    @GetMapping("/stats")
    @Operation(summary = "Get notification statistics for a date range")
    public ResponseEntity<NotificationStats> getStats(
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate startDate,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate endDate) {

        NotificationStats stats = analyticsService.getNotificationStats(startDate, endDate);
        return ResponseEntity.ok(stats);
    }

    @GetMapping("/daily-count")
    @Operation(summary = "Get daily notification counts")
    public ResponseEntity<Map<LocalDate, Long>> getDailyCount(
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate startDate,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate endDate) {

        Map<LocalDate, Long> dailyCounts = analyticsService.getDailyNotificationCount(startDate, endDate);
        return ResponseEntity.ok(dailyCounts);
    }

    @GetMapping("/top-recipients")
    @Operation(summary = "Get top notification recipients")
    public ResponseEntity<Map<String, Long>> getTopRecipients(
            @RequestParam(defaultValue = "10") int limit) {

        Map<String, Long> topRecipients = analyticsService.getTopRecipients(limit);
        return ResponseEntity.ok(topRecipients);
    }

    @GetMapping("/failure-reasons")
    @Operation(summary = "Get failure reasons statistics")
    public ResponseEntity<Map<String, Long>> getFailureReasons() {
        Map<String, Long> failureReasons = analyticsService.getFailureReasons();
        return ResponseEntity.ok(failureReasons);
    }

    @GetMapping("/avg-processing-time")
    @Operation(summary = "Get average processing time")
    public ResponseEntity<Double> getAverageProcessingTime() {
        double avgTime = analyticsService.getAverageProcessingTime();
        return ResponseEntity.ok(avgTime);
    }
}

package com.notificationservice.controller;

import com.notificationservice.service.AttachmentService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/attachments")
@RequiredArgsConstructor
@Slf4j
@Tag(name = "Attachments", description = "API for managing email attachments")
public class AttachmentController {

    private final AttachmentService attachmentService;

    @PostMapping("/upload")
    @Operation(summary = "Upload an attachment")
    public ResponseEntity<Map<String, String>> uploadAttachment(@RequestParam("file") MultipartFile file) {
        try {
            String fileId = attachmentService.saveAttachment(file);

            Map<String, String> response = new HashMap<>();
            response.put("fileId", fileId);
            response.put("message", "File uploaded successfully");
            response.put("originalFilename", file.getOriginalFilename());
            response.put("size", String.valueOf(file.getSize()));

            return ResponseEntity.ok(response);

        } catch (IOException e) {
            log.error("Failed to upload attachment: {}", e.getMessage());
            Map<String, String> errorResponse = new HashMap<>();
            errorResponse.put("error", "Failed to upload file: " + e.getMessage());
            return ResponseEntity.badRequest().body(errorResponse);
        }
    }

    @GetMapping("/{fileId}")
    @Operation(summary = "Download an attachment")
    public ResponseEntity<byte[]> downloadAttachment(@PathVariable String fileId) {
        try {
            byte[] fileContent = attachmentService.getAttachment(fileId);

            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(MediaType.APPLICATION_OCTET_STREAM);
            headers.setContentDispositionFormData("attachment", fileId);

            return ResponseEntity.ok()
                    .headers(headers)
                    .body(fileContent);

        } catch (IOException e) {
            log.error("Failed to download attachment {}: {}", fileId, e.getMessage());
            return ResponseEntity.notFound().build();
        }
    }

    @DeleteMapping("/{fileId}")
    @Operation(summary = "Delete an attachment")
    public ResponseEntity<Map<String, String>> deleteAttachment(@PathVariable String fileId) {
        try {
            attachmentService.deleteAttachment(fileId);

            Map<String, String> response = new HashMap<>();
            response.put("message", "File deleted successfully");
            response.put("fileId", fileId);

            return ResponseEntity.ok(response);

        } catch (IOException e) {
            log.error("Failed to delete attachment {}: {}", fileId, e.getMessage());
            Map<String, String> errorResponse = new HashMap<>();
            errorResponse.put("error", "Failed to delete file: " + e.getMessage());
            return ResponseEntity.badRequest().body(errorResponse);
        }
    }

    @GetMapping("/{fileId}/info")
    @Operation(summary = "Get attachment information")
    public ResponseEntity<Map<String, String>> getAttachmentInfo(@PathVariable String fileId) {
        try {
            String info = attachmentService.getAttachmentInfo(fileId);

            Map<String, String> response = new HashMap<>();
            response.put("fileId", fileId);
            response.put("info", info != null ? info : "File not found");

            return ResponseEntity.ok(response);

        } catch (IOException e) {
            log.error("Failed to get attachment info {}: {}", fileId, e.getMessage());
            Map<String, String> errorResponse = new HashMap<>();
            errorResponse.put("error", "Failed to get file info: " + e.getMessage());
            return ResponseEntity.badRequest().body(errorResponse);
        }
    }
}

package com.notificationservice.controller;

import com.notificationservice.dto.BulkEmailRequest;
import com.notificationservice.dto.NotificationResponse;
import com.notificationservice.service.BulkNotificationService;
import io.github.resilience4j.ratelimiter.annotation.RateLimiter;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.concurrent.CompletableFuture;

@Slf4j
@RestController
@RequestMapping("/api/notifications/bulk")
@RequiredArgsConstructor
public class BulkNotificationController {

    private final BulkNotificationService bulkNotificationService;

    @PostMapping("/email")
    @RateLimiter(name = "bulkEmailRateLimit")
    public ResponseEntity<List<NotificationResponse>> sendBulkEmails(
            @Valid @RequestBody BulkEmailRequest request) {

        log.info("Received bulk email request for {} recipients", request.getEmails().size());

        List<NotificationResponse> responses = bulkNotificationService.sendBulkEmails(request);

        return ResponseEntity.ok(responses);
    }

    @PostMapping("/email/async")
    @RateLimiter(name = "bulkEmailRateLimit")
    public CompletableFuture<ResponseEntity<List<NotificationResponse>>> sendBulkEmailsAsync(
            @Valid @RequestBody BulkEmailRequest request) {

        log.info("Received async bulk email request for {} recipients", request.getEmails().size());

        return bulkNotificationService.sendBulkEmailsAsync(request)
                .thenApply(ResponseEntity::ok);
    }

    @GetMapping("/health")
    public ResponseEntity<String> health() {
        return ResponseEntity.ok("Bulk notification service is healthy");
    }
}

package com.notificationservice.controller;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.actuate.health.Health;
import org.springframework.boot.actuate.health.HealthComponent;
import org.springframework.boot.actuate.health.HealthEndpoint;
import org.springframework.boot.actuate.health.Status;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.HashMap;
import java.util.Map;

@RestController
@RequestMapping("/manage/health")
@RequiredArgsConstructor
@Slf4j
@Tag(name = "Health", description = "Health check endpoints")
public class HealthController {

    private final HealthEndpoint healthEndpoint;

    @GetMapping
    @Operation(summary = "Get application health status")
    public ResponseEntity<Map<String, Object>> getHealth() {
        try {
            HealthComponent healthComponent = healthEndpoint.health();
            Map<String, Object> response = new HashMap<>();
            response.put("status", healthComponent.getStatus().getCode());

            // –î–ª—è HealthComponent –∏—Å–ø–æ–ª—å–∑—É–µ–º –¥—Ä—É–≥–æ–π –ø–æ–¥—Ö–æ–¥ - –±–µ–∑ getComponents()
            if (healthComponent instanceof Health) {
                Health health = (Health) healthComponent;
                // –í–º–µ—Å—Ç–æ getComponents() –∏—Å–ø–æ–ª—å–∑—É–µ–º getDetails()
                response.put("details", health.getDetails());
            } else {
                response.put("details", Map.of("message", "Application is running"));
            }

            if (healthComponent.getStatus() == Status.UP) {
                return ResponseEntity.ok(response);
            } else {
                return ResponseEntity.status(503).body(response);
            }
        } catch (Exception e) {
            log.error("Health check failed", e);
            Map<String, Object> errorResponse = new HashMap<>();
            errorResponse.put("status", "DOWN");
            errorResponse.put("error", e.getMessage());
            return ResponseEntity.status(503).body(errorResponse);
        }
    }

    @GetMapping("/readiness")
    @Operation(summary = "Get application readiness status")
    public ResponseEntity<Map<String, Object>> getReadiness() {
        return getHealthStatus("readiness");
    }

    @GetMapping("/liveness")
    @Operation(summary = "Get application liveness status")
    public ResponseEntity<Map<String, Object>> getLiveness() {
        return getHealthStatus("liveness");
    }

    private ResponseEntity<Map<String, Object>> getHealthStatus(String probeType) {
        try {
            HealthComponent healthComponent = healthEndpoint.healthForPath(probeType);
            Map<String, Object> response = new HashMap<>();
            response.put("status", healthComponent.getStatus().getCode());
            response.put("type", probeType);

            if (healthComponent.getStatus() == Status.UP) {
                return ResponseEntity.ok(response);
            } else {
                return ResponseEntity.status(503).body(response);
            }
        } catch (Exception e) {
            log.error("{} probe failed", probeType, e);
            Map<String, Object> errorResponse = new HashMap<>();
            errorResponse.put("status", "DOWN");
            errorResponse.put("type", probeType);
            errorResponse.put("error", e.getMessage());
            return ResponseEntity.status(503).body(errorResponse);
        }
    }

    @GetMapping("/info")
    @Operation(summary = "Get application info")
    public ResponseEntity<Map<String, String>> getInfo() {
        Map<String, String> info = new HashMap<>();
        info.put("name", "Notification Service");
        info.put("version", "1.0.0");
        info.put("status", "operational");
        info.put("timestamp", java.time.LocalDateTime.now().toString());
        return ResponseEntity.ok(info);
    }

    @GetMapping("/simple")
    @Operation(summary = "Simple health check")
    public ResponseEntity<Map<String, String>> simpleHealth() {
        Map<String, String> response = new HashMap<>();
        response.put("status", "UP");
        response.put("service", "notification-service");
        response.put("timestamp", java.time.LocalDateTime.now().toString());
        return ResponseEntity.ok(response);
    }
}

package com.notificationservice.controller;

import com.notificationservice.dto.EmailRequest;
import com.notificationservice.dto.NotificationResponse;
import com.notificationservice.dto.PushRequest;
import com.notificationservice.entity.Notification;
import com.notificationservice.service.NotificationService;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/v1/notifications")
@RequiredArgsConstructor
@Slf4j
@Tag(name = "Notifications", description = "API for sending notifications")
public class NotificationController {

    private final NotificationService notificationService;

    @PostMapping("/email")
    public ResponseEntity<NotificationResponse> sendEmail(@Valid @RequestBody EmailRequest emailRequest) {
        log.info("Received email request for: {}", emailRequest.getTo());
        NotificationResponse response = notificationService.sendEmail(emailRequest);
        return ResponseEntity.ok(response);
    }

    @PostMapping("/push")
    public ResponseEntity<NotificationResponse> sendPush(@Valid @RequestBody PushRequest pushRequest) {
        log.info("Received push request for user: {}", pushRequest.getUserId());
        NotificationResponse response = notificationService.sendPush(pushRequest);
        return ResponseEntity.ok(response);
    }

    @GetMapping("/{id}")
    public ResponseEntity<Notification> getNotificationStatus(@PathVariable String id) {
        Notification notification = notificationService.getNotificationStatus(id);
        return ResponseEntity.ok(notification);
    }

    // Fallback methods
    public ResponseEntity<NotificationResponse> sendEmailFallback(EmailRequest request, Exception e) {
        log.error("Email service fallback triggered for: {}", request.getTo(), e);
        NotificationResponse response = NotificationResponse.error(
                null, "EMAIL", request.getTo(), "Service temporarily unavailable. Please try again later."
        );
        return ResponseEntity.ok(response);
    }

    public ResponseEntity<NotificationResponse> sendPushFallback(PushRequest request, Exception e) {
        log.error("Push service fallback triggered for user: {}", request.getUserId(), e);
        NotificationResponse response = NotificationResponse.error(
                null, "PUSH", request.getUserId(), "Service temporarily unavailable. Please try again later."
        );
        return ResponseEntity.ok(response);
    }
}

package com.notificationservice.controller;

import com.notificationservice.entity.Notification;
import com.notificationservice.service.RetryService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/v1/retry")
@RequiredArgsConstructor
@Slf4j
@Tag(name = "Retry", description = "API for manual retry operations")
public class RetryController {

    private final RetryService retryService;

    @PostMapping("/{notificationId}")
    @Operation(summary = "Retry a failed notification")
    public ResponseEntity<Void> retryNotification(@PathVariable String notificationId) {
        log.info("Manual retry requested for notification: {}", notificationId);

        retryService.retryFailedNotification(notificationId);

        return ResponseEntity.accepted().build();
    }

    @PostMapping("/failed")
    @Operation(summary = "Retry all failed notifications")
    public ResponseEntity<Void> retryAllFailed() {
        log.info("Manual retry requested for all failed notifications");

        List<Notification> failedNotifications = retryService.getNotificationsForRetry();

        for (Notification notification : failedNotifications) {
            retryService.retryFailedNotification(notification.getId());
        }

        return ResponseEntity.accepted().build();
    }

    @GetMapping("/failed")
    @Operation(summary = "Get all failed notifications eligible for retry")
    public ResponseEntity<List<Notification>> getFailedNotifications() {
        List<Notification> failedNotifications = retryService.getNotificationsForRetry();
        return ResponseEntity.ok(failedNotifications);
    }
}

package com.notificationservice.controller;

import com.notificationservice.entity.NotificationTemplate;
import com.notificationservice.service.TemplateService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/v1/templates")
@RequiredArgsConstructor
@Tag(name = "Templates", description = "API for managing notification templates")
public class TemplateController {

    private final TemplateService templateService;

    @GetMapping
    @Operation(summary = "Get all templates")
    public ResponseEntity<List<NotificationTemplate>> getAllTemplates() {
        // –î–æ–±–∞–≤–ª—è–µ–º –º–µ—Ç–æ–¥ –≤ TemplateService –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π
        List<NotificationTemplate> templates = templateService.findAllTemplates();
        return ResponseEntity.ok(templates);
    }

    @GetMapping("/{id}")
    @Operation(summary = "Get template by ID")
    public ResponseEntity<NotificationTemplate> getTemplate(@PathVariable String id) {
        return ResponseEntity.ok(templateService.getTemplate(id));
    }

    @PostMapping
    @Operation(summary = "Create new template")
    public ResponseEntity<NotificationTemplate> createTemplate(@Valid @RequestBody NotificationTemplate template) {
        return ResponseEntity.ok(templateService.createTemplate(template));
    }

    @PutMapping("/{id}")
    @Operation(summary = "Update template")
    public ResponseEntity<NotificationTemplate> updateTemplate(
            @PathVariable String id,
            @Valid @RequestBody NotificationTemplate template) {
        return ResponseEntity.ok(templateService.updateTemplate(id, template));
    }

    @DeleteMapping("/{id}")
    @Operation(summary = "Delete template")
    public ResponseEntity<Void> deleteTemplate(@PathVariable String id) {
        templateService.deleteTemplate(id); // –î–æ–±–∞–≤–ª—è–µ–º –º–µ—Ç–æ–¥ –≤ TemplateService
        return ResponseEntity.ok().build();
    }

    @PostMapping("/{id}/cache/evict")
    @Operation(summary = "Evict template cache")
    public ResponseEntity<Void> evictTemplateCache(@PathVariable String id) {
        templateService.evictTemplateCache(id); // –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ –Ω–∞–∑–≤–∞–Ω–∏–µ –º–µ—Ç–æ–¥–∞
        return ResponseEntity.ok().build();
    }
}

package com.notificationservice.dto;

import lombok.Data;
import jakarta.validation.Valid;
import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.NotNull;
import java.util.List;

@Data
public class BulkEmailRequest {

    @NotEmpty(message = "Emails list cannot be empty")
    private List<@Valid EmailRequest> emails;

    @NotNull
    private Priority priority = Priority.NORMAL;

    public enum Priority {
        LOW, NORMAL, HIGH
    }
}

package com.notificationservice.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class BulkProcessingStats {
    private int totalProcessed = 0;
    private int successCount = 0;
    private int failureCount = 0;
    private LocalDateTime startTime;
    private LocalDateTime endTime;
    private long processingTimeMs = 0;

    public double getSuccessRate() {
        return totalProcessed > 0 ? (successCount * 100.0) / totalProcessed : 0.0;
    }

    public void complete() {
        this.endTime = LocalDateTime.now();
        if (this.startTime != null) {
            this.processingTimeMs = java.time.Duration.between(startTime, endTime).toMillis();
        }
    }
}

package com.notificationservice.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Map;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class EmailRequest {

    public enum Priority {
        LOW, NORMAL, HIGH
    }

    @NotBlank(message = "Recipient email is required")
    @Email(message = "Invalid email format")
    private String to;

    @NotBlank(message = "Subject is required")
    private String subject;

    @NotBlank(message = "Message content is required")
    private String message;

    private String templateId;

    private Map<String, Object> templateVariables;

    @Email(message = "Invalid CC email format")
    private String cc;

    @Email(message = "Invalid BCC email format")
    private String bcc;

    private Map<String, String> attachments;

    @NotNull(message = "Priority is required")
    private Priority priority = Priority.NORMAL;

    // Validation method
    public boolean isValid() {
        return to != null && !to.trim().isEmpty() &&
                subject != null && !subject.trim().isEmpty() &&
                message != null && !message.trim().isEmpty();
    }
}

package com.notificationservice.dto;

import com.fasterxml.jackson.annotation.JsonInclude;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@JsonInclude(JsonInclude.Include.NON_NULL)
public class NotificationResponse {
    private String id;
    private String type;
    private String status;
    private String recipient;
    private String subject;
    private String message;
    private LocalDateTime createdAt;
    private LocalDateTime sentAt;
    private String errorMessage;
    private Boolean success;

    public static NotificationResponse success(String id, String type, String recipient, String subject, String message) {
        return NotificationResponse.builder()
                .id(id)
                .type(type)
                .status("SENT")
                .recipient(recipient)
                .subject(subject)
                .message(message)
                .success(true)
                .createdAt(LocalDateTime.now())
                .sentAt(LocalDateTime.now())
                .build();
    }

    public static NotificationResponse pending(String id, String type, String recipient, String subject) {
        return NotificationResponse.builder()
                .id(id)
                .type(type)
                .status("PENDING")
                .recipient(recipient)
                .subject(subject)
                .success(true)
                .createdAt(LocalDateTime.now())
                .build();
    }

    public static NotificationResponse failed(String id, String type, String recipient, String subject, String errorMessage) {
        return NotificationResponse.builder()
                .id(id)
                .type(type)
                .status("FAILED")
                .recipient(recipient)
                .subject(subject)
                .errorMessage(errorMessage)
                .success(false)
                .createdAt(LocalDateTime.now())
                .build();
    }

    // –£–±—Ä–∞—Ç—å –¥—É–±–ª–∏—Ä—É—é—â–∏–π –º–µ—Ç–æ–¥ error, –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ç–æ–ª—å–∫–æ failed
    public static NotificationResponse error(String id, String type, String recipient, String errorMessage) {
        return failed(id, type, recipient, null, errorMessage);
    }

    public boolean isSuccess() {
        return Boolean.TRUE.equals(success);
    }
}

package com.notificationservice.dto;

import lombok.*;

import java.time.LocalDateTime;
import java.util.Map;

@Getter
@Setter
@Data
@NoArgsConstructor
@AllArgsConstructor
public class NotificationStats {
    private int totalNotifications;
    private double successRate;
    private Map<String, Long> notificationsByType;
    private Map<String, Long> notificationsByStatus;
    private LocalDateTime periodStart;
    private LocalDateTime periodEnd;
    private long averageProcessingTimeMs;

    public long getSuccessfulCount() {
        return notificationsByStatus.getOrDefault("SENT", 0L);
    }

    public long getFailedCount() {
        return notificationsByStatus.getOrDefault("FAILED", 0L);
    }

    public long getPendingCount() {
        return notificationsByStatus.getOrDefault("PENDING", 0L);
    }
}

// Priority.java
package com.notificationservice.dto;

public enum Priority {
    LOW, NORMAL, HIGH
}

package com.notificationservice.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Pattern;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class PushRequest {

    public enum Priority {
        LOW, NORMAL, HIGH
    }

    @NotBlank(message = "User ID is required")
    private String userId;

    @NotBlank(message = "Title is required")
    private String title;

    @NotBlank(message = "Message is required")
    private String message;

    @NotNull(message = "Priority is required")
    private Priority priority = Priority.NORMAL;

    @Pattern(regexp = "ANDROID|IOS|ALL", message = "Platform must be ANDROID, IOS or ALL")
    private String platform = "ALL";
}

package com.notificationservice.entity;

import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.LocalDateTime;

@Getter
@Setter
@Entity
@Table(name = "email_providers")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class EmailProvider {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private String id;

    @Column(nullable = false, unique = true)
    private String name;

    @Column(nullable = false)
    private String host;

    @Column(nullable = false)
    private Integer port;

    @Column(nullable = false)
    private String username;

    @Column(nullable = false)
    private String password;

    @Column(name = "from_email", nullable = false)
    private String fromEmail;

    @Column(name = "from_name")
    private String fromName;

    @Column(nullable = false)
    private Boolean active = true;

    @Column(nullable = false)
    private Integer priority = 1;

    @Column(name = "daily_limit", nullable = false)
    private Integer dailyLimit = 1000;

    @Column(name = "current_usage", nullable = false)
    private Integer currentUsage = 0;

    @Column(name = "max_connection_pool_size")
    private Integer maxConnectionPoolSize = 5;

    @Column(name = "connection_timeout")
    private Integer connectionTimeout = 5000;

    @Column(name = "timeout")
    private Integer timeout = 5000;

    @Column(name = "use_ssl")
    private Boolean useSsl = false;

    @Column(name = "use_tls")
    private Boolean useTls = true;

    @Column(name = "last_used")
    private LocalDateTime lastUsed;

    @Column(name = "last_reset")
    private LocalDateTime lastReset;

    @CreationTimestamp
    @Column(name = "created_at", updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    @Column(name = "created_by")
    private String createdBy;

    @PrePersist
    public void setInitialValues() {
        if (this.lastReset == null) {
            this.lastReset = LocalDateTime.now();
        }
        validate();
    }

    @PreUpdate
    public void validate() {
        if (priority < 1) {
            throw new IllegalArgumentException("Priority must be at least 1");
        }
        if (dailyLimit < 0) {
            throw new IllegalArgumentException("Daily limit cannot be negative");
        }
        if (currentUsage < 0) {
            throw new IllegalArgumentException("Current usage cannot be negative");
        }
        if (port < 1 || port > 65535) {
            throw new IllegalArgumentException("Port must be between 1 and 65535");
        }
    }

    public boolean isAvailable() {
        return active && currentUsage < dailyLimit;
    }

    public double getUsagePercentage() {
        if (dailyLimit == 0) return 0.0;
        return (currentUsage * 100.0) / dailyLimit;
    }

    public boolean needsReset() {
        return lastReset == null || lastReset.toLocalDate().isBefore(LocalDateTime.now().toLocalDate());
    }

    public void incrementUsage() {
        this.currentUsage++;
        this.lastUsed = LocalDateTime.now();
    }

    public void resetUsage() {
        this.currentUsage = 0;
        this.lastReset = LocalDateTime.now();
    }
}

package com.notificationservice.entity;

import jakarta.persistence.*;
import lombok.Data;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.LocalDateTime;

@Data
@Entity
@Table(name = "notifications")
public class Notification {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private String id;

    @Column(nullable = false, length = 50)
    private String type;

    @Column(nullable = false, length = 50)
    private String status = "PENDING";

    @Column(nullable = false, length = 255)
    private String recipient;

    @Column(length = 500)
    private String subject;

    @Column(columnDefinition = "TEXT")
    private String message;

    @Column(name = "template_id", length = 36)
    private String templateId;

    @Column(name = "error_message", columnDefinition = "TEXT")
    private String errorMessage;

    @Column(name = "retry_count")
    private int retryCount = 0;

    @Column(length = 20)
    private String priority = "NORMAL";

    @CreationTimestamp
    @Column(name = "created_at", updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    @Column(name = "sent_at")
    private LocalDateTime sentAt;

    @Column(name = "processing_time")
    private Long processingTime;

    // –î–æ–±–∞–≤–ª—è–µ–º –ø–æ–ª–µ title –¥–ª—è push —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π
    @Column(length = 500)
    private String title;

    @PrePersist
    protected void onCreate() {
        if (createdAt == null) {
            createdAt = LocalDateTime.now();
        }
        if (status == null) {
            status = "PENDING";
        }
        if (priority == null) {
            priority = "NORMAL";
        }
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }
}

package com.notificationservice.entity;

import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.LocalDateTime;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Getter
@Setter
@Entity
@Table(name = "notification_templates")
public class NotificationTemplate {
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private String id;

    @Column(nullable = false, unique = true)
    private String name;

    @Column(nullable = false)
    private String type; // EMAIL, PUSH

    @Column(nullable = false, columnDefinition = "TEXT")
    private String subject;

    @Column(nullable = false, columnDefinition = "TEXT")
    private String content;

    @Column(name = "variables", columnDefinition = "TEXT")
    private String variables; // JSON array of variable names

    @Column(nullable = false)
    private String version = "1.0";

    @Column(nullable = false)
    private boolean active = true;

    @CreationTimestamp
    @Column(name = "created_at", updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    @Column(name = "created_by")
    private String createdBy;

    @PreUpdate
    public void preUpdate() {
        this.updatedAt = LocalDateTime.now();
    }
}

package com.notificationservice.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.LocalDateTime;

@Entity
@Table(name = "users")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private String id;

    @Column(unique = true)
    private String email;

    @Column(name = "push_token", length = 500)
    private String pushToken;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private Platform platform;

    @Column(name = "device_id")
    private String deviceId;

    @Column(nullable = false)
    private Boolean active = true;

    @Column(name = "preferences", columnDefinition = "TEXT")
    private String preferences; // JSON string for user preferences

    @Column(name = "timezone")
    private String timezone;

    @Column(name = "language")
    private String language = "en";

    @Column(name = "last_notification_at")
    private LocalDateTime lastNotificationAt;

    @Column(name = "notification_count")
    private Integer notificationCount = 0;

    @CreationTimestamp
    @Column(name = "created_at", updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    @Column(name = "last_seen_at")
    private LocalDateTime lastSeenAt;

    @Version
    private Long version;

    public enum Platform {
        IOS("iOS"),
        ANDROID("Android"),
        WEB("Web"),
        UNKNOWN("Unknown");

        private final String displayName;

        Platform(String displayName) {
            this.displayName = displayName;
        }

        public String getDisplayName() {
            return displayName;
        }

        public static Platform fromString(String platform) {
            if (platform == null) return UNKNOWN;

            try {
                return Platform.valueOf(platform.toUpperCase());
            } catch (IllegalArgumentException e) {
                return UNKNOWN;
            }
        }
    }

    @PrePersist
    @PreUpdate
    public void validate() {
        if (platform == null) {
            platform = Platform.UNKNOWN;
        }
        if (notificationCount == null) {
            notificationCount = 0;
        }
        if (language == null) {
            language = "en";
        }
    }

    public boolean canReceivePush() {
        return active && pushToken != null && !pushToken.trim().isEmpty();
    }

    public boolean canReceiveEmail() {
        return active && email != null && !email.trim().isEmpty();
    }

    public void incrementNotificationCount() {
        if (this.notificationCount == null) {
            this.notificationCount = 0;
        }
        this.notificationCount++;
        this.lastNotificationAt = LocalDateTime.now();
    }

    public void updateLastSeen() {
        this.lastSeenAt = LocalDateTime.now();
    }

    public boolean isRecentlyActive() {
        return lastSeenAt != null &&
                lastSeenAt.isAfter(LocalDateTime.now().minusDays(7));
    }

    public String getPlatformDisplayName() {
        return platform.getDisplayName();
    }

    // Helper methods for preferences (assuming JSON format)
    public void setEmailPreference(boolean enabled) {
        // Implementation for updating email preferences in JSON
    }

    public void setPushPreference(boolean enabled) {
        // Implementation for updating push preferences in JSON
    }

    public boolean getEmailPreference() {
        // Default to true if preferences not set
        return true;
    }

    public boolean getPushPreference() {
        // Default to true if preferences not set
        return true;
    }
}

package com.notificationservice.exception;

import java.io.Serial;

public class EmailSendingException extends NotificationException {

    @Serial
    private static final long serialVersionUID = 1012320433731299010L;

    public EmailSendingException(String message) {
        super(message);
    }

    public EmailSendingException(String message, Throwable cause) {
        super(message, cause);
    }
}

package com.notificationservice.exception;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.http.converter.HttpMessageNotReadableException;
import org.springframework.validation.BindingResult;
import org.springframework.validation.FieldError;
import org.springframework.web.HttpMediaTypeNotSupportedException;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.context.request.WebRequest;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler {

    @ExceptionHandler(NotificationNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleNotificationNotFoundException(
            NotificationNotFoundException ex, WebRequest request) {
        log.warn("Notification not found: {}", ex.getMessage());

        ErrorResponse errorResponse = ErrorResponse.builder()
                .timestamp(LocalDateTime.now())
                .status(HttpStatus.NOT_FOUND.value())
                .error("Notification Not Found")
                .message(ex.getMessage())
                .path(request.getDescription(false).replace("uri=", ""))
                .build();

        return new ResponseEntity<>(errorResponse, HttpStatus.NOT_FOUND);
    }

    @ExceptionHandler(NotificationException.class)
    public ResponseEntity<ErrorResponse> handleNotificationException(
            NotificationException ex, WebRequest request) {
        log.warn("Notification error: {}", ex.getMessage());

        ErrorResponse errorResponse = ErrorResponse.builder()
                .timestamp(LocalDateTime.now())
                .status(HttpStatus.BAD_REQUEST.value())
                .error("Notification Error")
                .message(ex.getMessage())
                .path(request.getDescription(false).replace("uri=", ""))
                .build();

        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    @ExceptionHandler(TemplateNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleTemplateNotFoundException(
            TemplateNotFoundException ex, WebRequest request) {
        log.warn("Template not found: {}", ex.getMessage());

        ErrorResponse errorResponse = ErrorResponse.builder()
                .timestamp(LocalDateTime.now())
                .status(HttpStatus.NOT_FOUND.value())
                .error("Template Not Found")
                .message(ex.getMessage())
                .path(request.getDescription(false).replace("uri=", ""))
                .build();

        return new ResponseEntity<>(errorResponse, HttpStatus.NOT_FOUND);
    }

    @ExceptionHandler(EmailSendingException.class)
    public ResponseEntity<ErrorResponse> handleEmailSendingException(
            EmailSendingException ex, WebRequest request) {
        log.error("Email sending error: {}", ex.getMessage());

        ErrorResponse errorResponse = ErrorResponse.builder()
                .timestamp(LocalDateTime.now())
                .status(HttpStatus.INTERNAL_SERVER_ERROR.value())
                .error("Email Sending Failed")
                .message(ex.getMessage())
                .path(request.getDescription(false).replace("uri=", ""))
                .build();

        return new ResponseEntity<>(errorResponse, HttpStatus.INTERNAL_SERVER_ERROR);
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleValidationExceptions(
            MethodArgumentNotValidException ex, WebRequest request) {
        log.warn("Validation error: {}", ex.getMessage());

        BindingResult bindingResult = ex.getBindingResult();
        Map<String, String> details = new HashMap<>();

        // –ò—Å–ø–æ–ª—å–∑—É–µ–º getFieldErrors() –≤–º–µ—Å—Ç–æ getAllErrors()
        for (FieldError fieldError : bindingResult.getFieldErrors()) {
            details.put(fieldError.getField(), fieldError.getDefaultMessage());
        }

        ErrorResponse errorResponse = ErrorResponse.builder()
                .timestamp(LocalDateTime.now())
                .status(HttpStatus.BAD_REQUEST.value())
                .error("Validation Failed")
                .message("Request validation failed")
                .path(request.getDescription(false).replace("uri=", ""))
                .details(details)
                .build();

        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    @ExceptionHandler(HttpMessageNotReadableException.class)
    public ResponseEntity<ErrorResponse> handleHttpMessageNotReadableException(
            HttpMessageNotReadableException ex, WebRequest request) {
        log.warn("Invalid request body: {}", ex.getMessage());

        ErrorResponse errorResponse = ErrorResponse.builder()
                .timestamp(LocalDateTime.now())
                .status(HttpStatus.BAD_REQUEST.value())
                .error("Invalid Request")
                .message("Request body is invalid or missing")
                .path(request.getDescription(false).replace("uri=", ""))
                .build();

        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    @ExceptionHandler(HttpMediaTypeNotSupportedException.class)
    public ResponseEntity<ErrorResponse> handleHttpMediaTypeNotSupportedException(
            HttpMediaTypeNotSupportedException ex, WebRequest request) {
        log.warn("Unsupported media type: {}", ex.getMessage());

        ErrorResponse errorResponse = ErrorResponse.builder()
                .timestamp(LocalDateTime.now())
                .status(HttpStatus.UNSUPPORTED_MEDIA_TYPE.value())
                .error("Unsupported Media Type")
                .message("Content type is not supported")
                .path(request.getDescription(false).replace("uri=", ""))
                .build();

        return new ResponseEntity<>(errorResponse, HttpStatus.UNSUPPORTED_MEDIA_TYPE);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGlobalException(
            Exception ex, WebRequest request) {
        log.error("Unexpected error: {}", ex.getMessage(), ex);

        ErrorResponse errorResponse = ErrorResponse.builder()
                .timestamp(LocalDateTime.now())
                .status(HttpStatus.INTERNAL_SERVER_ERROR.value())
                .error("Internal Server Error")
                .message("An unexpected error occurred")
                .path(request.getDescription(false).replace("uri=", ""))
                .build();

        return new ResponseEntity<>(errorResponse, HttpStatus.INTERNAL_SERVER_ERROR);
    }

    // Inner class for error response
    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class ErrorResponse {
        private LocalDateTime timestamp;
        private int status;
        private String error;
        private String message;
        private String path;
        private Map<String, String> details;
    }
}

package com.notificationservice.exception;

public class NotificationException extends RuntimeException {

    public NotificationException(String message) {
        super(message);
    }

    public NotificationException(String message, Throwable cause) {
        super(message, cause);
    }
}

package com.notificationservice.exception;

import java.io.Serial;

public class NotificationNotFoundException extends NotificationException {

    @Serial
    private static final long serialVersionUID = 7263063305795869240L;

    public NotificationNotFoundException(String message) {
        super(message);
    }

    public NotificationNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }
}

package com.notificationservice.exception;

public class TemplateNotFoundException extends NotificationException {

    public TemplateNotFoundException(String message) {
        super(message);
    }

    public TemplateNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }
}

package com.notificationservice.messaging;

import com.notificationservice.entity.Notification;
import com.notificationservice.repository.NotificationRepository;
import com.notificationservice.service.*;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.context.annotation.Profile;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.concurrent.TimeUnit;

@Profile("!dev") // –ó–∞–ø—É—Å–∫–∞–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –≤ –ù–ï-dev –ø—Ä–æ—Ñ–∏–ª—è—Ö
@Service
@RequiredArgsConstructor
@Slf4j
public class EnhancedNotificationConsumer {

    private final NotificationRepository notificationRepository;
    private final EmailService emailService;
    private final PushService pushService;
    private final MetricsService metricsService;

    @RabbitListener(queues = "${rabbitmq.queue.notification:notification.queue}")
    @Transactional
    public void processNotification(String notificationId) {
        long startTime = System.currentTimeMillis();
        String notificationType = "UNKNOWN";

        try {
            log.info("Processing notification: {}", notificationId);

            Notification notification = notificationRepository.findById(notificationId)
                    .orElseThrow(() -> new RuntimeException("Notification not found: " + notificationId));

            notificationType = notification.getType();

            if (!"PENDING".equals(notification.getStatus())) {
                log.warn("Notification {} is not in PENDING state: {}", notificationId, notification.getStatus());
                return;
            }

            processNotificationInternal(notification);
            metricsService.recordNotificationStatus(notificationType, "SUCCESS");

        } catch (Exception e) {
            log.error("Failed to process notification {}: {}", notificationId, e.getMessage());
            metricsService.recordNotificationStatus(notificationType, "FAILED");
            throw new RuntimeException("Notification processing failed", e);
        } finally {
            long processingTime = System.currentTimeMillis() - startTime;
            recordProcessingTime(notificationType, processingTime);
        }
    }

    @RabbitListener(queues = "${rabbitmq.queue.email:email.queue}")
    @Transactional
    public void processEmailNotification(String notificationId) {
        processSpecificNotification(notificationId, "EMAIL");
    }

    @RabbitListener(queues = "${rabbitmq.queue.push:push.queue}")
    @Transactional
    public void processPushNotification(String notificationId) {
        processSpecificNotification(notificationId, "PUSH");
    }

    private void processSpecificNotification(String notificationId, String expectedType) {
        long startTime = System.currentTimeMillis();

        try {
            log.info("Processing {} notification: {}", expectedType, notificationId);

            Notification notification = notificationRepository.findById(notificationId)
                    .orElseThrow(() -> new RuntimeException("Notification not found: " + notificationId));

            if (!expectedType.equals(notification.getType())) {
                log.warn("Notification {} is not {} type: {}", notificationId, expectedType, notification.getType());
                return;
            }

            if (!"PENDING".equals(notification.getStatus())) {
                log.warn("Notification {} is not in PENDING state: {}", notificationId, notification.getStatus());
                return;
            }

            processNotificationInternal(notification);
            metricsService.recordNotificationStatus(expectedType, "SUCCESS");

        } catch (Exception e) {
            log.error("Failed to process {} notification {}: {}", expectedType, notificationId, e.getMessage());
            metricsService.recordNotificationStatus(expectedType, "FAILED");
            throw new RuntimeException(expectedType + " notification processing failed", e);
        } finally {
            long processingTime = System.currentTimeMillis() - startTime;
            recordProcessingTime(expectedType, processingTime);
        }
    }

    private void processNotificationInternal(Notification notification) {
        try {
            switch (notification.getType()) {
                case "EMAIL":
                    emailService.sendEmail(notification);
                    metricsService.recordEmailSent();
                    break;
                case "PUSH":
                    pushService.sendPush(notification);
                    metricsService.recordPushSent();
                    break;
                default:
                    throw new RuntimeException("Unknown notification type: " + notification.getType());
            }

            notification.setStatus("SENT");
            notification.setSentAt(LocalDateTime.now());
            notificationRepository.save(notification);

            log.info("Successfully processed {} notification: {}",
                    notification.getType(), notification.getId());

        } catch (Exception e) {
            handleProcessingFailure(notification, e);
            throw e;
        }
    }

    private void handleProcessingFailure(Notification notification, Exception e) {
        notification.setStatus("FAILED");
        notification.setErrorMessage(e.getMessage());
        notification.setRetryCount(notification.getRetryCount() + 1);
        notificationRepository.save(notification);

        if ("EMAIL".equals(notification.getType())) {
            metricsService.recordEmailFailed();
            metricsService.recordNotificationRetry("EMAIL");
        } else if ("PUSH".equals(notification.getType())) {
            metricsService.recordPushFailed();
            metricsService.recordNotificationRetry("PUSH");
        }

        log.error("Failed to process {} notification {}: {}",
                notification.getType(), notification.getId(), e.getMessage());
    }

    private void recordProcessingTime(String notificationType, long processingTimeMillis) {
        if ("EMAIL".equals(notificationType)) {
            metricsService.recordEmailProcessingTime(processingTimeMillis, TimeUnit.MILLISECONDS);
        } else if ("PUSH".equals(notificationType)) {
            metricsService.recordPushProcessingTime(processingTimeMillis, TimeUnit.MILLISECONDS);
        }
        log.debug("{} notification processing time: {} ms", notificationType, processingTimeMillis);
    }

    @RabbitListener(queues = "${rabbitmq.queue.dlq:notification.dlq}")
    public void handleDeadLetterMessage(String notificationId) {
        log.error("Received message in DLQ: {}", notificationId);

        try {
            Notification notification = notificationRepository.findById(notificationId).orElse(null);
            if (notification != null) {
                notification.setStatus("FAILED_PERMANENTLY");
                notificationRepository.save(notification);

                metricsService.recordNotificationStatus(notification.getType(), "PERMANENT_FAILURE");
                log.warn("Notification {} permanently failed and moved to DLQ", notificationId);
            }
        } catch (Exception e) {
            log.error("Failed to handle DLQ message {}: {}", notificationId, e.getMessage());
        }
    }
}

package com.notificationservice.messaging;

import com.notificationservice.service.NotificationService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.context.annotation.Profile;
import org.springframework.stereotype.Component;

@Profile("!dev") // –ó–∞–ø—É—Å–∫–∞–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –≤ –ù–ï-dev –ø—Ä–æ—Ñ–∏–ª—è—Ö
@Component
@RequiredArgsConstructor
@Slf4j
public class NotificationConsumer {

    private final NotificationService notificationService;

    @RabbitListener(queues = "${rabbitmq.queue.notification:notification.queue}")
    public void processNotification(String notificationId) {
        try {
            log.info("Processing notification from queue: {}", notificationId);
            notificationService.processNotification(notificationId);
            log.info("Successfully processed notification: {}", notificationId);
        } catch (Exception e) {
            log.error("Failed to process notification {}: {}", notificationId, e.getMessage());
            throw new RuntimeException("Notification processing failed", e);
        }
    }

    @RabbitListener(queues = "${rabbitmq.queue.dlq:notification.dlq}")
    public void processFailedNotification(String notificationId) {
        try {
            log.warn("Processing failed notification from DLQ: {}", notificationId);
            // Additional logic for handling failed notifications
            // Could include sending alerts, logging to external system, etc.
            log.error("Notification {} has failed multiple times and moved to DLQ", notificationId);
        } catch (Exception e) {
            log.error("Failed to process DLQ notification {}: {}", notificationId, e.getMessage());
        }
    }
}

package com.notificationservice.repository;

import com.notificationservice.entity.EmailProvider;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface EmailProviderRepository extends JpaRepository<EmailProvider, String> {

    List<EmailProvider> findByActiveTrue();

    List<EmailProvider> findByActiveTrueOrderByPriorityAsc();

    @Query("SELECT ep FROM EmailProvider ep WHERE ep.active = true AND ep.currentUsage < ep.dailyLimit ORDER BY ep.priority ASC")
    List<EmailProvider> findAvailableProviders();

    @Query("SELECT ep FROM EmailProvider ep WHERE ep.active = true AND ep.currentUsage < ep.dailyLimit ORDER BY ep.priority ASC, ep.currentUsage ASC")
    List<EmailProvider> findBestAvailableProviders();

    Optional<EmailProvider> findByName(String name);

    @Query("SELECT ep FROM EmailProvider ep WHERE ep.lastUsed IS NOT NULL ORDER BY ep.lastUsed DESC")
    List<EmailProvider> findRecentlyUsedProviders();

    @Modifying
    @Query("UPDATE EmailProvider ep SET ep.currentUsage = 0, ep.lastReset = CURRENT_TIMESTAMP WHERE ep.lastReset < CURRENT_DATE")
    int resetDailyUsage();

    @Modifying
    @Query("UPDATE EmailProvider ep SET ep.currentUsage = ep.currentUsage + :count WHERE ep.id = :providerId")
    int incrementUsage(@Param("providerId") String providerId, @Param("count") int count);

    @Query("SELECT COUNT(ep) FROM EmailProvider ep WHERE ep.active = true AND ep.currentUsage < ep.dailyLimit")
    long countAvailableProviders();

    @Query("SELECT ep FROM EmailProvider ep WHERE ep.dailyLimit > 0 AND ep.currentUsage >= ep.dailyLimit")
    List<EmailProvider> findExhaustedProviders();
}

package com.notificationservice.repository;

import com.notificationservice.entity.Notification;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;

@Repository
public interface NotificationRepository extends JpaRepository<Notification, String> {

    List<Notification> findByStatus(String status);

    List<Notification> findByRecipient(String recipient);

    List<Notification> findByType(String type);

    long countByStatus(String status);

    List<Notification> findByStatusAndRetryCountLessThan(String status, int maxRetryCount);

    // –ú–µ—Ç–æ–¥—ã –¥–ª—è AnalyticsService
    List<Notification> findByCreatedAtBetween(LocalDateTime start, LocalDateTime end);

    @Query("SELECT AVG(n.processingTime) FROM Notification n WHERE n.processingTime IS NOT NULL")
    Double findAverageProcessingTime();

    @Query("SELECT DATE(n.createdAt) as date, COUNT(n) as count " +
            "FROM Notification n " +
            "WHERE n.createdAt BETWEEN :start AND :end " +
            "GROUP BY DATE(n.createdAt) " +
            "ORDER BY date")
    List<Object[]> getDailyCountByDateRange(@Param("start") LocalDateTime start,
                                            @Param("end") LocalDateTime end);

    @Query("SELECT n.recipient, COUNT(n) as count " +
            "FROM Notification n " +
            "GROUP BY n.recipient " +
            "ORDER BY count DESC " +
            "LIMIT :limit")
    List<Object[]> findTopRecipients(@Param("limit") int limit);

    @Query("SELECT n.errorMessage, COUNT(n) as count " +
            "FROM Notification n " +
            "WHERE n.errorMessage IS NOT NULL " +
            "GROUP BY n.errorMessage " +
            "ORDER BY count DESC")
    List<Object[]> findFailureReasons();

    @Query("SELECT n.type, COUNT(n) as count " +
            "FROM Notification n " +
            "GROUP BY n.type")
    List<Object[]> countByType();

    @Query("SELECT n.status, COUNT(n) as count " +
            "FROM Notification n " +
            "GROUP BY n.status")
    List<Object[]> countByStatusGroup();

    @Query("SELECT n.priority, COUNT(n) as count " +
            "FROM Notification n " +
            "WHERE n.priority IS NOT NULL " +
            "GROUP BY n.priority")
    List<Object[]> countByPriority();

    // –ú–µ—Ç–æ–¥ –¥–ª—è RetryService
    List<Notification> findByStatusAndCreatedAtBefore(String status, LocalDateTime dateTime);

}

package com.notificationservice.repository;

import com.notificationservice.entity.NotificationTemplate;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface TemplateRepository extends JpaRepository<NotificationTemplate, String> {

    // Basic CRUD operations are provided by JpaRepository

    // Find template by name
    Optional<NotificationTemplate> findByName(String name);

    // Find templates by type
    List<NotificationTemplate> findByType(String type);

    // Find active templates
    List<NotificationTemplate> findByActiveTrue();

    // Find active templates by type
    List<NotificationTemplate> findByTypeAndActiveTrue(String type);

    // Find templates by name containing (case-insensitive)
    List<NotificationTemplate> findByNameContainingIgnoreCase(String name);

    // Find templates by active status and type
    List<NotificationTemplate> findByActiveAndType(Boolean active, String type);

    // Find templates created by specific user
    List<NotificationTemplate> findByCreatedBy(String createdBy);

    // Find templates with version greater than specified
    List<NotificationTemplate> findByVersionGreaterThan(String version);

    // Custom query to find templates by type and active status with sorting
    @Query("SELECT nt FROM NotificationTemplate nt WHERE nt.type = :type AND nt.active = :active ORDER BY nt.name ASC")
    List<NotificationTemplate> findByTypeAndActiveOrderByName(@Param("type") String type, @Param("active") boolean active);

    // Custom query to find templates with specific variable
    @Query("SELECT nt FROM NotificationTemplate nt WHERE nt.variables LIKE %:variable%")
    List<NotificationTemplate> findByVariable(@Param("variable") String variable);

    // Count templates by type
    @Query("SELECT COUNT(nt) FROM NotificationTemplate nt WHERE nt.type = :type")
    long countByType(@Param("type") String type);

    // Count active templates by type
    @Query("SELECT COUNT(nt) FROM NotificationTemplate nt WHERE nt.type = :type AND nt.active = true")
    long countActiveByType(@Param("type") String type);

    // Find latest templates (ordered by updated date)
    @Query("SELECT nt FROM NotificationTemplate nt ORDER BY nt.updatedAt DESC")
    List<NotificationTemplate> findLatestTemplates();

    // Find templates updated after specific date
    List<NotificationTemplate> findByUpdatedAtAfter(java.time.LocalDateTime date);

    // Find templates by multiple types
    @Query("SELECT nt FROM NotificationTemplate nt WHERE nt.type IN :types")
    List<NotificationTemplate> findByTypes(@Param("types") List<String> types);

    // Find templates by name pattern and type
    @Query("SELECT nt FROM NotificationTemplate nt WHERE nt.name LIKE %:namePattern% AND nt.type = :type")
    List<NotificationTemplate> findByNamePatternAndType(@Param("namePattern") String namePattern, @Param("type") String type);

    // Update template active status
    @Modifying
    @Query("UPDATE NotificationTemplate nt SET nt.active = :active, nt.updatedAt = CURRENT_TIMESTAMP WHERE nt.id = :id")
    int updateActiveStatus(@Param("id") String id, @Param("active") boolean active);

    // Update template version (—É–ø—Ä–æ—â–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è)
    @Modifying
    @Query("UPDATE NotificationTemplate nt SET nt.version = :version, nt.updatedAt = CURRENT_TIMESTAMP WHERE nt.id = :id")
    int updateVersion(@Param("id") String id, @Param("version") String version);

    // –£–î–ê–õ–ò–¢–ï —ç—Ç–æ—Ç –º–µ—Ç–æ–¥ - –æ–Ω –≤—ã–∑—ã–≤–∞–µ—Ç –æ—à–∏–±–∫—É
    // @Modifying
    // @Query("UPDATE NotificationTemplate nt SET nt.version = CONCAT(SPLIT_PART(nt.version, '.', 1), '.', (SPLIT_PART(nt.version, '.', 2)::integer + 1)::text), nt.updatedAt = CURRENT_TIMESTAMP WHERE nt.id = :id")
    // int incrementMinorVersion(@Param("id") String id);

    // Bulk update active status by type
    @Modifying
    @Query("UPDATE NotificationTemplate nt SET nt.active = :active, nt.updatedAt = CURRENT_TIMESTAMP WHERE nt.type = :type")
    int updateActiveStatusByType(@Param("type") String type, @Param("active") boolean active);

    // Find duplicate templates (same name, different ID)
    @Query("SELECT nt1 FROM NotificationTemplate nt1 WHERE EXISTS (SELECT 1 FROM NotificationTemplate nt2 WHERE nt2.name = nt1.name AND nt2.id != nt1.id)")
    List<NotificationTemplate> findDuplicateTemplates();

    // Get template usage statistics
    @Query(value = """
        SELECT 
            nt.type as templateType,
            COUNT(n.id) as usageCount
        FROM notification_templates nt
        LEFT JOIN notifications n ON nt.id = n.template_id
        WHERE nt.active = true
        GROUP BY nt.type
        ORDER BY usageCount DESC
        """, nativeQuery = true)
    List<Object[]> getTemplateUsageStatistics();

    // Find templates with no associated notifications
    @Query("SELECT nt FROM NotificationTemplate nt WHERE nt.id NOT IN (SELECT DISTINCT n.templateId FROM Notification n WHERE n.templateId IS NOT NULL)")
    List<NotificationTemplate> findUnusedTemplates();

    // Search templates by multiple criteria
    @Query("""
        SELECT nt FROM NotificationTemplate nt WHERE 
        (:name IS NULL OR nt.name LIKE %:name%) AND
        (:type IS NULL OR nt.type = :type) AND
        (:active IS NULL OR nt.active = :active) AND
        (:createdBy IS NULL OR nt.createdBy = :createdBy)
        ORDER BY nt.updatedAt DESC
        """)
    List<NotificationTemplate> searchTemplates(
            @Param("name") String name,
            @Param("type") String type,
            @Param("active") Boolean active,
            @Param("createdBy") String createdBy
    );

    // Find templates that need version update (based on content changes)
    @Query("SELECT nt FROM NotificationTemplate nt WHERE nt.updatedAt > nt.createdAt AND nt.version = '1.0'")
    List<NotificationTemplate> findTemplatesNeedingVersionUpdate();

    // Get template count by status
    @Query("SELECT nt.active, COUNT(nt) FROM NotificationTemplate nt GROUP BY nt.active")
    List<Object[]> countTemplatesByActiveStatus();

    // Find templates with specific content pattern
    @Query("SELECT nt FROM NotificationTemplate nt WHERE nt.content LIKE %:contentPattern%")
    List<NotificationTemplate> findByContentPattern(@Param("contentPattern") String contentPattern);

    // Update template content and increment version (—É–ø—Ä–æ—â–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è)
    @Modifying
    @Query("""
        UPDATE NotificationTemplate nt 
        SET nt.content = :content, 
            nt.subject = :subject,
            nt.updatedAt = CURRENT_TIMESTAMP 
        WHERE nt.id = :id
        """)
    int updateTemplateContent(
            @Param("id") String id,
            @Param("content") String content,
            @Param("subject") String subject
    );

    // Find templates with specific variables (JSON array contains)
    @Query(value = """
        SELECT * FROM notification_templates nt 
        WHERE nt.variables LIKE CONCAT('%', :variable, '%')
        """, nativeQuery = true)
    List<NotificationTemplate> findByVariablesContaining(@Param("variable") String variable);
}

package com.notificationservice.repository;

import com.notificationservice.entity.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

@Repository
public interface UserRepository extends JpaRepository<User, String> {

    Optional<User> findByEmail(String email);

    List<User> findByActiveTrue();

    List<User> findByPlatformAndActiveTrue(User.Platform platform);

    @Query("SELECT u FROM User u WHERE u.pushToken IS NOT NULL AND u.active = true")
    List<User> findUsersWithPushTokens();

    Optional<User> findByDeviceId(String deviceId);

    List<User> findByPushTokenNotNullAndActiveTrue();

    @Query("SELECT u FROM User u WHERE u.platform = :platform AND u.pushToken IS NOT NULL AND u.active = true")
    List<User> findUsersWithPushTokensByPlatform(@Param("platform") User.Platform platform);

    @Query("SELECT u FROM User u WHERE u.email IS NOT NULL AND u.active = true")
    List<User> findUsersWithEmail();

    @Query("SELECT u FROM User u WHERE u.lastSeenAt >= :since AND u.active = true")
    List<User> findActiveUsersSince(@Param("since") LocalDateTime since);

    @Modifying
    @Query("UPDATE User u SET u.pushToken = :pushToken, u.updatedAt = CURRENT_TIMESTAMP WHERE u.id = :userId")
    int updatePushToken(@Param("userId") String userId, @Param("pushToken") String pushToken);

    @Modifying
    @Query("UPDATE User u SET u.lastSeenAt = CURRENT_TIMESTAMP WHERE u.id = :userId")
    int updateLastSeen(@Param("userId") String userId);

    @Query("SELECT COUNT(u) FROM User u WHERE u.active = true AND u.pushToken IS NOT NULL")
    long countUsersWithPushEnabled();

    @Query("SELECT COUNT(u) FROM User u WHERE u.active = true AND u.email IS NOT NULL")
    long countUsersWithEmailEnabled();

    List<User> findByLastSeenAtBeforeAndActiveTrue(LocalDateTime date);

    @Query("SELECT u.platform, COUNT(u) FROM User u WHERE u.active = true GROUP BY u.platform")
    List<Object[]> countUsersByPlatform();
}

package com.notificationservice.service;

import com.notificationservice.dto.NotificationStats;
import com.notificationservice.entity.Notification;
import com.notificationservice.repository.NotificationRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Service
@RequiredArgsConstructor
@Slf4j
public class AnalyticsService {

    private final NotificationRepository notificationRepository;

    public NotificationStats getNotificationStats(LocalDate startDate, LocalDate endDate) {
        LocalDateTime start = startDate.atStartOfDay();
        LocalDateTime end = endDate.plusDays(1).atStartOfDay();

        List<Notification> notifications = notificationRepository.findByCreatedAtBetween(start, end);

        NotificationStats stats = new NotificationStats();
        stats.setTotalNotifications(notifications.size());
        stats.setPeriodStart(start);
        stats.setPeriodEnd(end);

        Map<String, Long> notificationsByType = new HashMap<>();
        Map<String, Long> notificationsByStatus = new HashMap<>();

        for (Notification notification : notifications) {
            // Count by type
            notificationsByType.merge(notification.getType(), 1L, Long::sum);

            // Count by status
            notificationsByStatus.merge(notification.getStatus(), 1L, Long::sum);
        }

        stats.setNotificationsByType(notificationsByType);
        stats.setNotificationsByStatus(notificationsByStatus);

        // Calculate success rate
        long successful = notificationsByStatus.getOrDefault("SENT", 0L);
        long failed = notificationsByStatus.getOrDefault("FAILED", 0L);
        long total = successful + failed;

        if (total > 0) {
            stats.setSuccessRate((double) successful / total * 100);
        } else {
            stats.setSuccessRate(0.0);
        }

        // Calculate average processing time
        Double avgTime = notificationRepository.findAverageProcessingTime();
        stats.setAverageProcessingTimeMs(avgTime != null ? (long) (avgTime * 1000) : 0L);

        return stats;
    }

    public Map<LocalDate, Long> getDailyNotificationCount(LocalDate startDate, LocalDate endDate) {
        List<Object[]> results = notificationRepository.getDailyCountByDateRange(
                startDate.atStartOfDay(),
                endDate.plusDays(1).atStartOfDay()
        );

        Map<LocalDate, Long> dailyCounts = new HashMap<>();
        for (Object[] result : results) {
            LocalDate date = ((java.sql.Date) result[0]).toLocalDate();
            Long count = ((Long) result[1]);
            dailyCounts.put(date, count);
        }

        // Fill missing dates with zero
        LocalDate current = startDate;
        while (!current.isAfter(endDate)) {
            dailyCounts.putIfAbsent(current, 0L);
            current = current.plusDays(1);
        }

        return dailyCounts;
    }

    public Map<String, Long> getTopRecipients(int limit) {
        List<Object[]> results = notificationRepository.findTopRecipients(limit);
        Map<String, Long> topRecipients = new HashMap<>();

        for (Object[] result : results) {
            String recipient = (String) result[0];
            Long count = (Long) result[1];
            topRecipients.put(recipient, count);
        }

        return topRecipients;
    }

    public Map<String, Long> getFailureReasons() {
        List<Object[]> results = notificationRepository.findFailureReasons();
        Map<String, Long> failureReasons = new HashMap<>();

        for (Object[] result : results) {
            String errorMessage = (String) result[0];
            Long count = (Long) result[1];
            failureReasons.put(errorMessage != null ? errorMessage : "Unknown error", count);
        }

        return failureReasons;
    }

    public double getAverageProcessingTime() {
        Double avgTime = notificationRepository.findAverageProcessingTime();
        return avgTime != null ? avgTime : 0.0;
    }

    // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –º–µ—Ç–æ–¥—ã –∞–Ω–∞–ª–∏—Ç–∏–∫–∏
    public Map<String, Long> getNotificationsByType() {
        List<Object[]> results = notificationRepository.countByType();
        Map<String, Long> byType = new HashMap<>();

        for (Object[] result : results) {
            String type = (String) result[0];
            Long count = (Long) result[1];
            byType.put(type, count);
        }

        return byType;
    }

    public Map<String, Long> getNotificationsByStatus() {
        List<Object[]> results = notificationRepository.countByStatusGroup();
        Map<String, Long> byStatus = new HashMap<>();

        for (Object[] result : results) {
            String status = (String) result[0];
            Long count = (Long) result[1];
            byStatus.put(status, count);
        }

        return byStatus;
    }

    public Map<String, Long> getNotificationsByPriority() {
        List<Object[]> results = notificationRepository.countByPriority();
        Map<String, Long> byPriority = new HashMap<>();

        for (Object[] result : results) {
            String priority = (String) result[0];
            Long count = (Long) result[1];
            byPriority.put(priority, count);
        }

        return byPriority;
    }
}

package com.notificationservice.service;

import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.UUID;

@Service
@Slf4j
public class AttachmentService {

    @Value("${notification.attachments.max-size:10485760}") // 10MB default
    private long maxFileSize;

    @Value("${notification.attachments.allowed-types:pdf,doc,docx,jpg,jpeg,png,txt}")
    private String[] allowedTypes;

    @Value("${notification.attachments.storage-path:./attachments}")
    private String storagePath;

    public String saveAttachment(MultipartFile file) throws IOException {
        validateFile(file);

        String fileId = UUID.randomUUID().toString();
        String originalFilename = file.getOriginalFilename();
        String fileExtension = getFileExtension(originalFilename);
        String filename = fileId + (fileExtension != null ? "." + fileExtension : "");

        Path storageDir = Paths.get(storagePath);
        if (!Files.exists(storageDir)) {
            Files.createDirectories(storageDir);
        }

        Path filePath = storageDir.resolve(filename);
        Files.copy(file.getInputStream(), filePath);

        log.info("Attachment saved: {} (original: {})", filename, originalFilename);
        return fileId;
    }

    public byte[] getAttachment(String fileId) throws IOException {
        Path filePath = findFilePath(fileId);
        if (filePath == null) {
            throw new IOException("File not found: " + fileId);
        }
        return Files.readAllBytes(filePath);
    }

    public void deleteAttachment(String fileId) throws IOException {
        Path filePath = findFilePath(fileId);
        if (filePath != null) {
            Files.deleteIfExists(filePath);
            log.info("Attachment deleted: {}", fileId);
        }
    }

    private void validateFile(MultipartFile file) throws IOException {
        if (file.isEmpty()) {
            throw new IOException("File is empty");
        }

        if (file.getSize() > maxFileSize) {
            throw new IOException("File size exceeds maximum allowed size: " + maxFileSize);
        }

        String originalFilename = file.getOriginalFilename();
        String fileExtension = getFileExtension(originalFilename);

        if (fileExtension == null || !isAllowedFileType(fileExtension)) {
            throw new IOException("File type not allowed: " + fileExtension);
        }
    }

    private String getFileExtension(String filename) {
        if (filename == null || !filename.contains(".")) {
            return null;
        }
        return filename.substring(filename.lastIndexOf(".") + 1).toLowerCase();
    }

    private boolean isAllowedFileType(String fileExtension) {
        for (String allowedType : allowedTypes) {
            if (allowedType.equalsIgnoreCase(fileExtension)) {
                return true;
            }
        }
        return false;
    }

    private Path findFilePath(String fileId) throws IOException {
        Path storageDir = Paths.get(storagePath);
        if (!Files.exists(storageDir)) {
            return null;
        }

        return Files.list(storageDir)
                .filter(path -> path.getFileName().toString().startsWith(fileId))
                .findFirst()
                .orElse(null);
    }

    public String getAttachmentInfo(String fileId) throws IOException {
        Path filePath = findFilePath(fileId);
        if (filePath == null) {
            return null;
        }

        return Files.getAttribute(filePath, "size") + " bytes";
    }
}

package com.notificationservice.service;

import com.notificationservice.dto.BulkEmailRequest;
import com.notificationservice.dto.EmailRequest;
import com.notificationservice.dto.NotificationResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.concurrent.CompletableFuture;

@Slf4j
@Service
@RequiredArgsConstructor
public class BulkNotificationService {

    private final NotificationService notificationService;

    public List<NotificationResponse> sendBulkEmails(BulkEmailRequest request) {
        log.info("Processing bulk email request for {} recipients", request.getEmails().size());

        return request.getEmails().stream()
                .map(emailRequest -> {
                    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç –∏–∑ bulk –∑–∞–ø—Ä–æ—Å–∞ –≤ –∫–∞–∂–¥—ã–π –æ—Ç–¥–µ–ª—å–Ω—ã–π email
                    emailRequest.setPriority(convertPriority(request.getPriority()));
                    return notificationService.sendEmail(emailRequest);
                })
                .toList();
    }

    public CompletableFuture<List<NotificationResponse>> sendBulkEmailsAsync(BulkEmailRequest request) {
        log.info("Processing async bulk email request for {} recipients", request.getEmails().size());

        List<CompletableFuture<NotificationResponse>> futures = request.getEmails().stream()
                .map(emailRequest -> {
                    emailRequest.setPriority(convertPriority(request.getPriority()));
                    return notificationService.sendEmailAsync(emailRequest);
                })
                .toList();

        return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
                .thenApply(v -> futures.stream()
                        .map(CompletableFuture::join)
                        .toList());
    }

    private EmailRequest.Priority convertPriority(BulkEmailRequest.Priority bulkPriority) {
        return switch (bulkPriority) {
            case LOW -> EmailRequest.Priority.LOW;
            case NORMAL -> EmailRequest.Priority.NORMAL;
            case HIGH -> EmailRequest.Priority.HIGH;
        };
    }
}

package com.notificationservice.service;

import com.notificationservice.entity.Notification;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Profile;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.stereotype.Service;

@Service
@Profile("dev")
@Slf4j
public class DevEmailService extends EmailService {

    public DevEmailService(JavaMailSender mailSender, MetricsService metricsService) {
        super(mailSender, metricsService);
    }

    @Override
    public void sendEmail(Notification notification) {
        log.info("üìß [DEV MODE] Mock email sent to: {} with subject: {}",
                notification.getRecipient(), notification.getSubject());
        log.info("üìß [DEV MODE] Email content: {}", notification.getMessage());
        // –í dev —Ä–µ–∂–∏–º–µ –Ω–µ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ä–µ–∞–ª—å–Ω—ã–µ email, —Ç–æ–ª—å–∫–æ –ª–æ–≥–∏—Ä—É–µ–º

        // –í dev —Ä–µ–∂–∏–º–µ –≤—Å–µ email —Å—á–∏—Ç–∞—é—Ç—Å—è —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–º–∏
        log.info("üìß [DEV MODE] Email marked as sent successfully");
    }

    @Override
    public void sendEmailWithTemplate(String to, String subject, String templateId, Object variables) {
        log.info("üìß [DEV MODE] Mock template email sent to: {} with template: {}", to, templateId);
        log.info("üìß [DEV MODE] Subject: {}", subject);
        log.info("üìß [DEV MODE] Template variables: {}", variables);
        // –í dev —Ä–µ–∂–∏–º–µ –Ω–µ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ä–µ–∞–ª—å–Ω—ã–µ email, —Ç–æ–ª—å–∫–æ –ª–æ–≥–∏—Ä—É–µ–º
    }
}

package com.notificationservice.service;

import com.notificationservice.entity.EmailProvider;
import com.notificationservice.repository.EmailProviderRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.JavaMailSenderImpl;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Properties;

@Service
@RequiredArgsConstructor
@Slf4j
public class EmailProviderService {

    private final EmailProviderRepository emailProviderRepository;

    public boolean testConnection(EmailProvider provider) {
        try {
            JavaMailSender mailSender = createMailSender(provider);
            // –ü—Ä–æ—Å—Ç–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è - –ø–æ–ø—ã—Ç–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —Å–µ—Å—Å–∏–∏
            ((JavaMailSenderImpl) mailSender).testConnection();
            return true;
        } catch (Exception e) {
            log.error("Connection test failed for provider {}: {}", provider.getName(), e.getMessage());
            return false;
        }
    }

    public void checkAllProvidersHealth() {
        List<EmailProvider> activeProviders = emailProviderRepository.findByActiveTrue();

        for (EmailProvider provider : activeProviders) {
            boolean isHealthy = testConnection(provider);
            if (!isHealthy) {
                log.warn("Email provider {} is unhealthy, deactivating", provider.getName());
                provider.setActive(false); // –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ –Ω–∞ setActive
                emailProviderRepository.save(provider);
            }
        }
    }

    private JavaMailSender createMailSender(EmailProvider provider) {
        JavaMailSenderImpl mailSender = new JavaMailSenderImpl();
        mailSender.setHost(provider.getHost());
        mailSender.setPort(provider.getPort());
        mailSender.setUsername(provider.getUsername());
        mailSender.setPassword(provider.getPassword());

        Properties props = mailSender.getJavaMailProperties();
        props.put("mail.transport.protocol", "smtp");
        props.put("mail.smtp.auth", "true");
        props.put("mail.smtp.starttls.enable", "true");
        props.put("mail.smtp.connectiontimeout", "5000");
        props.put("mail.smtp.timeout", "5000");
        props.put("mail.smtp.writetimeout", "5000");

        return mailSender;
    }
}

package com.notificationservice.service;

import com.notificationservice.entity.Notification;
import com.notificationservice.exception.EmailSendingException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.mail.SimpleMailMessage;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.stereotype.Service;

@Slf4j
@Service
@RequiredArgsConstructor
public class EmailService {

    private final JavaMailSender mailSender;
    private final MetricsService metricsService;

    public void sendEmail(Notification notification) {
        if (notification == null) {
            throw new IllegalArgumentException("Notification cannot be null");
        }

        try {
            SimpleMailMessage message = new SimpleMailMessage();
            message.setTo(notification.getRecipient());
            message.setSubject(notification.getSubject());
            message.setText(notification.getMessage());

            mailSender.send(message);

            log.info("Email sent successfully to: {}", notification.getRecipient());
            metricsService.recordEmailSent();

        } catch (Exception e) {
            log.error("Failed to send email to: {}", notification.getRecipient(), e);
            metricsService.recordEmailFailed();
            throw new EmailSendingException("Email sending failed: " + e.getMessage(), e);
        }
    }

    public void sendEmailWithTemplate(String to, String subject, String templateId, Object variables) {
        log.info("Sending email with template - To: {}, Subject: {}, Template: {}", to, subject, templateId);
        // –†–µ–∞–ª–∏–∑–∞—Ü–∏—è –±—É–¥–µ—Ç –≤ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã—Ö —Å–µ—Ä–≤–∏—Å–∞—Ö
    }
}

package com.notificationservice.service;

import com.notificationservice.entity.EmailProvider;
import com.notificationservice.entity.Notification;
import com.notificationservice.repository.EmailProviderRepository;
import io.github.resilience4j.circuitbreaker.CircuitBreaker;
import io.github.resilience4j.circuitbreaker.CircuitBreakerRegistry;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.JavaMailSenderImpl;
import org.springframework.stereotype.Service;

import jakarta.mail.internet.MimeMessage;
import java.util.List;
import java.util.Properties;
import java.util.concurrent.atomic.AtomicInteger;

@Service
@RequiredArgsConstructor
@Slf4j
public class EnhancedEmailService {

    private final EmailProviderRepository emailProviderRepository;
    private final CircuitBreakerRegistry circuitBreakerRegistry;

    private final AtomicInteger currentProviderIndex = new AtomicInteger(0);
    private List<EmailProvider> activeProviders;

    public void sendEmailWithFailover(Notification notification) {
        CircuitBreaker circuitBreaker = circuitBreakerRegistry.circuitBreaker("emailService");

        circuitBreaker.executeRunnable(() -> {
            boolean sent = false;
            int attempts = 0;
            int maxAttempts = getActiveProviders().size();

            while (!sent && attempts < maxAttempts) {
                EmailProvider provider = getNextProvider();
                try {
                    sendEmailWithProvider(notification, provider);
                    sent = true;
                    log.info("Email sent successfully using provider: {}", provider.getName());
                } catch (Exception e) {
                    attempts++;
                    log.warn("Failed to send email with provider {}: {}", provider.getName(), e.getMessage());
                    // Mark provider as temporarily unavailable
                    provider.setActive(false);
                    emailProviderRepository.save(provider);
                }
            }

            if (!sent) {
                throw new RuntimeException("All email providers failed");
            }
        });
    }

    private void sendEmailWithProvider(Notification notification, EmailProvider provider) {
        JavaMailSender mailSender = createMailSender(provider);

        try {
            MimeMessage message = mailSender.createMimeMessage();
            var helper = new org.springframework.mail.javamail.MimeMessageHelper(message, true, "UTF-8");

            helper.setTo(notification.getRecipient());
            helper.setSubject(notification.getSubject());
            helper.setText(notification.getMessage(), true);
            helper.setFrom(provider.getFromEmail());

            mailSender.send(message);

        } catch (Exception e) {
            throw new RuntimeException("Failed to send email with provider " + provider.getName(), e);
        }
    }

    private JavaMailSender createMailSender(EmailProvider provider) {
        JavaMailSenderImpl mailSender = new JavaMailSenderImpl();
        mailSender.setHost(provider.getHost());
        mailSender.setPort(provider.getPort());
        mailSender.setUsername(provider.getUsername());
        mailSender.setPassword(provider.getPassword());

        Properties props = mailSender.getJavaMailProperties();
        props.put("mail.transport.protocol", "smtp");
        props.put("mail.smtp.auth", "true");
        props.put("mail.smtp.starttls.enable", "true");
        props.put("mail.smtp.connectiontimeout", "5000");
        props.put("mail.smtp.timeout", "5000");
        props.put("mail.smtp.writetimeout", "5000");

        return mailSender;
    }

    private synchronized List<EmailProvider> getActiveProviders() {
        if (activeProviders == null) {
            activeProviders = emailProviderRepository.findByActiveTrue();
        }
        return activeProviders;
    }

    private EmailProvider getNextProvider() {
        List<EmailProvider> providers = getActiveProviders();
        if (providers.isEmpty()) {
            throw new RuntimeException("No active email providers available");
        }

        int index = currentProviderIndex.getAndUpdate(i -> (i + 1) % providers.size());
        return providers.get(index);
    }

    public void refreshProviders() {
        this.activeProviders = null;
        getActiveProviders(); // Reload providers
    }
}

package com.notificationservice.service;

import io.micrometer.core.instrument.Counter;
import io.micrometer.core.instrument.MeterRegistry;
import io.micrometer.core.instrument.Timer;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.TimeUnit;

@Service
@RequiredArgsConstructor
public class MetricsService {

    private final MeterRegistry meterRegistry;
    private final ConcurrentMap<String, Counter> countersCache = new ConcurrentHashMap<>();
    private final ConcurrentMap<String, Timer> timersCache = new ConcurrentHashMap<>();

    // Email metrics
    public void recordEmailSent() {
        getOrCreateCounter("notification.emails.sent").increment();
    }

    public void recordEmailFailed() {
        getOrCreateCounter("notification.emails.failed").increment();
    }

    // Push metrics
    public void recordPushSent() {
        getOrCreateCounter("notification.push.sent").increment();
    }

    public void recordPushFailed() {
        getOrCreateCounter("notification.push.failed").increment();
    }

    // Processing time metrics
    public void recordEmailProcessingTime(long duration, TimeUnit unit) {
        getOrCreateTimer("notification.email.processing.time").record(duration, unit);
    }

    public void recordPushProcessingTime(long duration, TimeUnit unit) {
        getOrCreateTimer("notification.push.processing.time").record(duration, unit);
    }

    // Notification status metrics with tags
    public void recordNotificationStatus(String type, String status) {
        String cacheKey = String.format("notification.status.type.%s.status.%s", type, status);
        getOrCreateCounterWithTags("notification.status", cacheKey,
                new String[]{"type", type, "status", status}).increment();
    }

    // Generic counter for any notification type and status
    public void recordNotificationMetric(String type, String status) {
        String counterName = String.format("notification.%s.%s", type.toLowerCase(), status.toLowerCase());
        getOrCreateCounter(counterName).increment();
    }

    // Bulk notification metrics
    public void recordBulkNotificationProcessed(String type, int count) {
        String cacheKey = String.format("notification.bulk.processed.type.%s", type);
        getOrCreateCounterWithTags("notification.bulk.processed", cacheKey,
                new String[]{"type", type}).increment(count);
    }

    // Retry metrics
    public void recordNotificationRetry(String type) {
        String cacheKey = String.format("notification.retry.count.type.%s", type);
        getOrCreateCounterWithTags("notification.retry.count", cacheKey,
                new String[]{"type", type}).increment();
    }

    private Counter getOrCreateCounter(String name) {
        return countersCache.computeIfAbsent(name, key ->
                Counter.builder(key)
                        .register(meterRegistry)
        );
    }

    private Counter getOrCreateCounterWithTags(String baseName, String cacheKey, String... tags) {
        return countersCache.computeIfAbsent(cacheKey, key -> {
            Counter.Builder builder = Counter.builder(baseName);
            for (int i = 0; i < tags.length; i += 2) {
                builder.tag(tags[i], tags[i + 1]);
            }
            return builder.register(meterRegistry);
        });
    }

    private Timer getOrCreateTimer(String name) {
        return timersCache.computeIfAbsent(name, key ->
                Timer.builder(key)
                        .register(meterRegistry)
        );
    }

    // –ú–µ—Ç–æ–¥—ã –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
    public void clearCache() {
        countersCache.clear();
        timersCache.clear();
    }

    public int getCacheSize() {
        return countersCache.size() + timersCache.size();
    }
}

package com.notificationservice.service;

import com.notificationservice.dto.EmailRequest;
import com.notificationservice.dto.NotificationResponse;
import com.notificationservice.dto.PushRequest;
import com.notificationservice.entity.Notification;
import com.notificationservice.exception.NotificationNotFoundException;
import com.notificationservice.repository.NotificationRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;

@Service
@RequiredArgsConstructor
@Slf4j
public class NotificationService {

    private final NotificationRepository notificationRepository;
    private final EmailService emailService;
    private final PushService pushService;
    private final TemplateService templateService;
    private final MetricsService metricsService;

    @Transactional
    public NotificationResponse sendEmail(EmailRequest request) {
        String notificationId = generateId();

        try {
            // Validate request
            if (!isValidEmailRequest(request)) {
                log.warn("Invalid email request: {}", request);
                metricsService.recordEmailFailed();
                return NotificationResponse.failed(
                        notificationId, "EMAIL", request.getTo(),
                        request.getSubject(), "Invalid email request"
                );
            }

            // Process template if provided
            String finalMessage = request.getMessage();
            if (request.getTemplateId() != null && !request.getTemplateId().isEmpty()) {
                try {
                    String processedContent = templateService.processTemplate(
                            request.getTemplateId(),
                            request.getTemplateVariables() != null ? request.getTemplateVariables() : Map.of()
                    );
                    finalMessage = processedContent;
                } catch (Exception e) {
                    log.warn("Failed to process template {}, using fallback message", request.getTemplateId(), e);
                    // Continue with original message if template processing fails
                }
            }

            // Create and save notification entity
            Notification notification = createEmailNotification(request);
            notification.setMessage(finalMessage);

            Notification savedNotification = notificationRepository.save(notification);
            log.info("Saved email notification with ID: {}", savedNotification.getId());

            try {
                // Send email
                emailService.sendEmail(notification);

                // Update notification status
                notification.setStatus("SENT");
                notification.setSentAt(LocalDateTime.now());
                notificationRepository.save(notification);

                metricsService.recordEmailSent();
                log.info("Email sent successfully for notification ID: {}", savedNotification.getId());

                return NotificationResponse.success(
                        savedNotification.getId(),
                        "EMAIL",
                        request.getTo(),
                        request.getSubject(),
                        "Email sent successfully"
                );

            } catch (Exception e) {
                log.error("Failed to send email for notification ID: {}", savedNotification.getId(), e);
                notification.setStatus("FAILED");
                notification.setErrorMessage(e.getMessage());
                notificationRepository.save(notification);

                metricsService.recordEmailFailed();
                return NotificationResponse.failed(
                        savedNotification.getId(),
                        "EMAIL",
                        request.getTo(),
                        request.getSubject(),
                        e.getMessage()
                );
            }

        } catch (Exception e) {
            log.error("Unexpected error during email sending", e);
            metricsService.recordEmailFailed();
            return NotificationResponse.failed(
                    notificationId, "EMAIL", request.getTo(),
                    request.getSubject(), "Unexpected error: " + e.getMessage()
            );
        }
    }

    @Async
    public CompletableFuture<NotificationResponse> sendEmailAsync(EmailRequest request) {
        return CompletableFuture.completedFuture(sendEmail(request));
    }

    @Transactional
    public NotificationResponse sendPush(PushRequest request) {
        String notificationId = generateId();

        try {
            // Validate request
            if (!isValidPushRequest(request)) {
                log.warn("Invalid push request: {}", request);
                metricsService.recordPushFailed();
                return NotificationResponse.failed(
                        notificationId, "PUSH", request.getUserId(),
                        request.getTitle(), "Invalid push request"
                );
            }

            // Create notification entity
            Notification notification = createPushNotification(request);

            // Save initial notification
            Notification savedNotification = notificationRepository.save(notification);
            log.info("Saved push notification with ID: {}", savedNotification.getId());

            try {
                // Send push notification
                pushService.sendPush(notification);

                // Update notification status
                notification.setStatus("SENT");
                notification.setSentAt(LocalDateTime.now());
                notificationRepository.save(notification);

                metricsService.recordPushSent();
                log.info("Push notification sent successfully for notification ID: {}", savedNotification.getId());

                return NotificationResponse.success(
                        savedNotification.getId(),
                        "PUSH",
                        request.getUserId(),
                        request.getTitle(),
                        "Push notification sent successfully"
                );

            } catch (Exception e) {
                log.error("Failed to send push notification for ID: {}", savedNotification.getId(), e);
                notification.setStatus("FAILED");
                notification.setErrorMessage(e.getMessage());
                notificationRepository.save(notification);

                metricsService.recordPushFailed();
                return NotificationResponse.failed(
                        savedNotification.getId(),
                        "PUSH",
                        request.getUserId(),
                        request.getTitle(),
                        e.getMessage()
                );
            }

        } catch (Exception e) {
            log.error("Unexpected error during push notification sending", e);
            metricsService.recordPushFailed();
            return NotificationResponse.failed(
                    notificationId, "PUSH", request.getUserId(),
                    request.getTitle(), "Unexpected error: " + e.getMessage()
            );
        }
    }

    @Transactional(readOnly = true)
    public Notification getNotificationStatus(String id) {
        return notificationRepository.findById(id)
                .orElseThrow(() -> new NotificationNotFoundException("Notification not found with id: " + id));
    }

    @Transactional
    public void processNotification(String notificationId) {
        Notification notification = notificationRepository.findById(notificationId)
                .orElseThrow(() -> new NotificationNotFoundException("Notification not found"));

        if (!"PENDING".equals(notification.getStatus())) {
            log.info("Notification {} is not in PENDING status, skipping processing", notificationId);
            return;
        }

        try {
            switch (notification.getType()) {
                case "EMAIL":
                    emailService.sendEmail(notification);
                    break;
                case "PUSH":
                    pushService.sendPush(notification);
                    break;
                default:
                    throw new IllegalArgumentException("Unsupported notification type: " + notification.getType());
            }

            notification.setStatus("SENT");
            notification.setSentAt(LocalDateTime.now());
            notificationRepository.save(notification);
            log.info("Successfully processed notification: {}", notificationId);

        } catch (Exception e) {
            log.error("Failed to process notification: {}", notificationId, e);
            notification.setStatus("FAILED");
            notification.setErrorMessage(e.getMessage());
            notificationRepository.save(notification);
            throw e;
        }
    }

    private boolean isValidEmailRequest(EmailRequest request) {
        return request.getTo() != null && !request.getTo().isEmpty() &&
                request.getSubject() != null && !request.getSubject().isEmpty() &&
                request.getMessage() != null && !request.getMessage().isEmpty();
    }

    private boolean isValidPushRequest(PushRequest request) {
        return request.getUserId() != null && !request.getUserId().isEmpty() &&
                request.getTitle() != null && !request.getTitle().isEmpty() &&
                request.getMessage() != null && !request.getMessage().isEmpty();
    }

    private Notification createEmailNotification(EmailRequest request) {
        Notification notification = new Notification();
        notification.setId(generateId());
        notification.setType("EMAIL");
        notification.setStatus("PENDING");
        notification.setRecipient(request.getTo());
        notification.setSubject(request.getSubject());
        notification.setMessage(request.getMessage());
        notification.setTemplateId(request.getTemplateId());
        notification.setPriority(request.getPriority() != null ? request.getPriority().name() : "NORMAL");
        notification.setCreatedAt(LocalDateTime.now());
        return notification;
    }

    private Notification createPushNotification(PushRequest request) {
        Notification notification = new Notification();
        notification.setId(generateId());
        notification.setType("PUSH");
        notification.setStatus("PENDING");
        notification.setRecipient(request.getUserId());
        notification.setTitle(request.getTitle());
        notification.setMessage(request.getMessage());
        notification.setPriority(request.getPriority() != null ? request.getPriority().name() : "NORMAL");
        notification.setCreatedAt(LocalDateTime.now());
        return notification;
    }

    private String generateId() {
        return UUID.randomUUID().toString();
    }
}

package com.notificationservice.service;

import com.notificationservice.entity.Notification;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
@Slf4j
public class PushService {

    private final MetricsService metricsService;

    public void sendPush(Notification notification) {
        if (notification == null) {
            throw new IllegalArgumentException("Notification cannot be null");
        }

        try {
            // –ò–º–∏—Ç–∞—Ü–∏—è –æ—Ç–ø—Ä–∞–≤–∫–∏ push-—É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
            log.info("Sending push notification to user: {}, title: {}, message: {}",
                    notification.getRecipient(),
                    notification.getTitle(), // –¢–µ–ø–µ—Ä—å —ç—Ç–æ –ø–æ–ª–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
                    notification.getMessage());

            // –í —Ä–µ–∞–ª—å–Ω–æ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –∑–¥–µ—Å—å –±—ã–ª –±—ã –≤—ã–∑–æ–≤ –≤–Ω–µ—à–Ω–µ–≥–æ —Å–µ—Ä–≤–∏—Å–∞
            // –ù–∞–ø—Ä–∏–º–µ—Ä: firebaseService.sendPush(notification);

            // –ò–º–∏—Ç–∞—Ü–∏—è –∑–∞–¥–µ—Ä–∂–∫–∏ —Å–µ—Ç–∏
            Thread.sleep(100);

            log.info("Push notification sent successfully to user: {}", notification.getRecipient());

        } catch (Exception e) {
            log.error("Failed to send push notification to user: {}", notification.getRecipient(), e);
            metricsService.recordPushFailed();
            throw new RuntimeException("Push notification sending failed: " + e.getMessage(), e);
        }
    }
}

package com.notificationservice.service;

import com.notificationservice.entity.Notification;
import com.notificationservice.repository.NotificationRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;

@Service
@RequiredArgsConstructor
@Slf4j
public class RetryService {

    private final NotificationRepository notificationRepository;
    private final RabbitTemplate rabbitTemplate;
    private final NotificationService notificationService;

    @Value("${notification.retry.max-attempts:3}")
    private int maxRetryAttempts;

    @Value("${notification.retry.backoff-delay:1000}")
    private long backoffDelay;

    public void retryFailedNotification(String notificationId) {
        Notification notification = notificationRepository.findById(notificationId)
                .orElseThrow(() -> new RuntimeException("Notification not found: " + notificationId));

        if (notification.getRetryCount() >= maxRetryAttempts) {
            log.warn("Notification {} has reached maximum retry attempts ({}), moving to DLQ",
                    notificationId, maxRetryAttempts);
            moveToDeadLetterQueue(notification);
            return;
        }

        try {
            // Apply exponential backoff
            long delay = calculateBackoffDelay(notification.getRetryCount());
            Thread.sleep(delay);

            log.info("Retrying notification {} (attempt {})",
                    notificationId, notification.getRetryCount() + 1);

            notificationService.processNotification(notificationId);

        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            log.error("Retry interrupted for notification {}", notificationId);
        } catch (Exception e) {
            log.error("Retry failed for notification {}: {}", notificationId, e.getMessage());
            incrementRetryCount(notification);
        }
    }

    @Scheduled(fixedRate = 300000) // 5 minutes
    public void retryStuckNotifications() {
        log.info("Checking for stuck notifications to retry...");

        LocalDateTime cutoffTime = LocalDateTime.now().minusMinutes(10);
        List<Notification> stuckNotifications = notificationRepository
                .findByStatusAndCreatedAtBefore("PENDING", cutoffTime);

        for (Notification notification : stuckNotifications) {
            log.info("Retrying stuck notification: {}", notification.getId());
            rabbitTemplate.convertAndSend(
                    "notification.exchange",
                    "notification.routing.key",
                    notification.getId()
            );
        }

        if (!stuckNotifications.isEmpty()) {
            log.info("Retried {} stuck notifications", stuckNotifications.size());
        }
    }

    private long calculateBackoffDelay(int retryCount) {
        return (long) (backoffDelay * Math.pow(2, retryCount));
    }

    private void incrementRetryCount(Notification notification) {
        notification.setRetryCount(notification.getRetryCount() + 1);
        notificationRepository.save(notification);
    }

    private void moveToDeadLetterQueue(Notification notification) {
        notification.setStatus("FAILED_PERMANENTLY");
        notificationRepository.save(notification);

        // Send to DLQ for manual processing
        rabbitTemplate.convertAndSend(
                "notification.dlq.exchange",
                "notification.dlq.routing.key",
                notification.getId()
        );
    }

    public List<Notification> getNotificationsForRetry() {
        return notificationRepository.findByStatusAndRetryCountLessThan("FAILED", maxRetryAttempts);
    }
}

package com.notificationservice.service;

import com.notificationservice.entity.EmailProvider;
import com.notificationservice.entity.Notification;
import com.notificationservice.repository.EmailProviderRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.JavaMailSenderImpl;
import org.springframework.mail.javamail.MimeMessageHelper;
import org.springframework.stereotype.Service;

import jakarta.mail.internet.MimeMessage;
import java.util.List;
import java.util.Properties;

@Service
@RequiredArgsConstructor
@Slf4j
public class RoutedEmailService {

    private final EmailProviderRepository emailProviderRepository;
    private final MetricsService metricsService;

    public void sendRoutedEmail(Notification notification) {
        List<EmailProvider> availableProviders = emailProviderRepository.findAvailableProviders();

        if (availableProviders.isEmpty()) {
            throw new RuntimeException("No available email providers");
        }

        EmailProvider selectedProvider = selectBestProvider(availableProviders);

        try {
            sendWithProvider(notification, selectedProvider);
            updateProviderUsage(selectedProvider);
            log.info("Email sent successfully using provider: {}", selectedProvider.getName());
        } catch (Exception e) {
            log.error("Failed to send email with provider {}: {}", selectedProvider.getName(), e.getMessage());
            handleProviderFailure(selectedProvider);
            throw e;
        }
    }

    private EmailProvider selectBestProvider(List<EmailProvider> providers) {
        return providers.stream()
                .filter(provider -> provider.getCurrentUsage() < provider.getDailyLimit())
                .min((p1, p2) -> {
                    // Prefer providers with higher priority and lower usage
                    int priorityCompare = Integer.compare(p1.getPriority(), p2.getPriority());
                    if (priorityCompare != 0) return priorityCompare;

                    double p1UsageRatio = (double) p1.getCurrentUsage() / p1.getDailyLimit();
                    double p2UsageRatio = (double) p2.getCurrentUsage() / p2.getDailyLimit();
                    return Double.compare(p1UsageRatio, p2UsageRatio);
                })
                .orElseThrow(() -> new RuntimeException("No suitable provider found"));
    }

    private void sendWithProvider(Notification notification, EmailProvider provider) {
        JavaMailSender mailSender = createMailSender(provider);

        try {
            MimeMessage message = mailSender.createMimeMessage();
            MimeMessageHelper helper = new MimeMessageHelper(message, true, "UTF-8");

            helper.setTo(notification.getRecipient());
            helper.setSubject(notification.getSubject());
            helper.setText(notification.getMessage(), true);
            helper.setFrom(provider.getFromEmail());

            mailSender.send(message);
            metricsService.recordEmailSent();

        } catch (Exception e) {
            metricsService.recordEmailFailed();
            throw new RuntimeException("Failed to send email with provider " + provider.getName(), e);
        }
    }

    private JavaMailSender createMailSender(EmailProvider provider) {
        JavaMailSenderImpl mailSender = new JavaMailSenderImpl();
        mailSender.setHost(provider.getHost());
        mailSender.setPort(provider.getPort());
        mailSender.setUsername(provider.getUsername());
        mailSender.setPassword(provider.getPassword());

        Properties props = mailSender.getJavaMailProperties();
        props.put("mail.transport.protocol", "smtp");
        props.put("mail.smtp.auth", "true");
        props.put("mail.smtp.starttls.enable", "true");
        props.put("mail.smtp.connectiontimeout", "5000");
        props.put("mail.smtp.timeout", "5000");
        props.put("mail.smtp.writetimeout", "5000");
        props.put("mail.debug", "false");

        return mailSender;
    }

    private void updateProviderUsage(EmailProvider provider) {
        provider.setCurrentUsage(provider.getCurrentUsage() + 1);
        emailProviderRepository.save(provider);
    }

    private void handleProviderFailure(EmailProvider provider) {
        // Optionally mark provider as inactive or reduce its priority
        log.warn("Email provider {} failed, consider reviewing its configuration", provider.getName());
    }
}

package com.notificationservice.service;

import com.notificationservice.entity.NotificationTemplate;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.util.Map;

@Service
@Slf4j
public class TemplateProcessor {

    public String processTemplate(NotificationTemplate template, Map<String, Object> variables) {
        try {
            String processedContent = template.getContent();
            if (variables != null) {
                processedContent = replaceVariables(processedContent, variables);
            }

            return processedContent;

        } catch (Exception e) {
            log.error("Failed to process template {}: {}", template.getId(), e.getMessage());
            throw new RuntimeException("Template processing failed: " + e.getMessage(), e);
        }
    }

    public String processTemplate(String content, Map<String, Object> variables) {
        if (content == null) {
            return null;
        }

        if (variables != null) {
            return replaceVariables(content, variables);
        }

        return content;
    }

    private String replaceVariables(String content, Map<String, Object> variables) {
        String result = content;
        for (Map.Entry<String, Object> entry : variables.entrySet()) {
            String placeholder = "{{" + entry.getKey() + "}}";
            String value = entry.getValue() != null ? entry.getValue().toString() : "";
            result = result.replace(placeholder, value);
        }
        return result;
    }
}

package com.notificationservice.service;

import com.notificationservice.entity.NotificationTemplate;
import jakarta.validation.Valid;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Map;

@Service
@Slf4j
public class TemplateService {

    public String processTemplate(String templateId, Map<String, Object> variables) {
        if (templateId == null || templateId.trim().isEmpty()) {
            throw new IllegalArgumentException("Template ID cannot be null or empty");
        }

        try {
            // –ò–º–∏—Ç–∞—Ü–∏—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ —à–∞–±–ª–æ–Ω–∞
            String templateContent = getTemplateContent(templateId);

            // –ü—Ä–æ—Å—Ç–∞—è –∑–∞–º–µ–Ω–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö
            String processedContent = templateContent;
            for (Map.Entry<String, Object> entry : variables.entrySet()) {
                String placeholder = "{{" + entry.getKey() + "}}";
                processedContent = processedContent.replace(placeholder,
                        entry.getValue() != null ? entry.getValue().toString() : "");
            }

            log.info("Template processed successfully: {}", templateId);
            return processedContent;

        } catch (Exception e) {
            log.error("Failed to process template: {}", templateId, e);
            throw new RuntimeException("Template processing failed: " + e.getMessage(), e);
        }
    }

    private String getTemplateContent(String templateId) {
        // –ò–º–∏—Ç–∞—Ü–∏—è –ø–æ–ª—É—á–µ–Ω–∏—è —à–∞–±–ª–æ–Ω–∞ –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –∏–ª–∏ —Ñ–∞–π–ª–æ–≤–æ–π —Å–∏—Å—Ç–µ–º—ã
        switch (templateId) {
            case "welcome-template":
                return "Welcome {{name}} to {{company}}! We're glad to have you.";
            case "notification-template":
                return "Hello {{name}}, you have a new notification: {{message}}";
            default:
                return "Template not found: " + templateId;
        }
    }

    public List<NotificationTemplate> findAllTemplates() {
        return null;
    }

    public NotificationTemplate getTemplate(String id) {
        return null;
    }

    public NotificationTemplate createTemplate(@Valid NotificationTemplate template) {
        return null;
    }

    public NotificationTemplate updateTemplate(String id, @Valid NotificationTemplate template) {
        return null;
    }

    public void deleteTemplate(String id) {
    }

    public void evictTemplateCache(String id) {

    }
}

package com.notificationservice.utils;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.ToString;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

import jakarta.annotation.PostConstruct;
import jakarta.annotation.PreDestroy;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.function.Predicate;
import java.util.stream.Collectors;

/**
 * Mock SMTP server for testing email functionality
 * Simplified version that logs emails instead of actually sending them
 */
@Component
@Slf4j
public class MockEmailServer {

    private static final int MAX_EMAILS = 1000;
    private final List<MockEmail> receivedEmails = new CopyOnWriteArrayList<>();
    private volatile boolean running = false;

    @PostConstruct
    public void start() {
        try {
            running = true;
            log.info("Mock email server started (logging mode)");
            log.info("Emails will be logged instead of actually sent");
        } catch (Exception e) {
            log.error("Failed to start mock email server", e);
            throw new RuntimeException("Failed to start mock email server", e);
        }
    }

    @PreDestroy
    public void stop() {
        running = false;
        receivedEmails.clear();
        log.info("Mock email server stopped");
    }

    /**
     * Simulate sending an email
     */
    public void sendEmail(String from, String to, String subject, String content) {
        if (!running) {
            throw new IllegalStateException("Mock email server is not running");
        }

        // Limit storage size
        if (receivedEmails.size() >= MAX_EMAILS) {
            receivedEmails.remove(0);
        }

        MockEmail email = new MockEmail(from, to, subject, content);
        receivedEmails.add(email);

        log.info("Mock email sent: From: {}, To: {}, Subject: {}", from, to, subject);
        log.debug("Email content: {}", content);
    }

    /**
     * Get the number of received messages
     */
    public int getReceivedMessagesCount() {
        return receivedEmails.size();
    }

    /**
     * Get all received messages
     */
    public List<MockEmail> getReceivedMessages() {
        return new ArrayList<>(receivedEmails);
    }

    /**
     * Get the last received message
     */
    public MockEmail getLastReceivedMessage() {
        return receivedEmails.isEmpty() ? null : receivedEmails.get(receivedEmails.size() - 1);
    }

    /**
     * Wait for messages to arrive (useful for async testing)
     */
    public void waitForIncomingEmail(int count, long timeoutMillis) {
        long startTime = System.currentTimeMillis();
        while (receivedEmails.size() < count && (System.currentTimeMillis() - startTime) < timeoutMillis) {
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            }
        }
    }

    /**
     * Reset the server - clear all received messages
     */
    public void reset() {
        receivedEmails.clear();
        log.debug("Mock email server reset");
    }

    /**
     * Check if server is running
     */
    public boolean isRunning() {
        return running;
    }

    /**
     * Verify that an email was sent to a specific recipient
     */
    public boolean wasEmailSentTo(String recipient) {
        return receivedEmails.stream()
                .anyMatch(email -> email.getTo().equalsIgnoreCase(recipient));
    }

    /**
     * Verify that an email with specific subject was sent
     */
    public boolean wasEmailSentWithSubject(String subject) {
        return receivedEmails.stream()
                .anyMatch(email -> email.getSubject().toLowerCase().contains(subject.toLowerCase()));
    }

    /**
     * Get the content of the last received email
     */
    public String getLastEmailContent() {
        MockEmail lastEmail = getLastReceivedMessage();
        return lastEmail != null ? lastEmail.getContent() : null;
    }

    /**
     * Print all received messages for debugging
     */
    public void printReceivedMessages() {
        log.info("Received {} email(s):", receivedEmails.size());
        for (int i = 0; i < receivedEmails.size(); i++) {
            MockEmail email = receivedEmails.get(i);
            log.info("Email {}: From: {}, To: {}, Subject: {}",
                    i + 1, email.getFrom(), email.getTo(), email.getSubject());
        }
    }

    /**
     * Find emails by criteria
     */
    public List<MockEmail> findEmails(Predicate<MockEmail> criteria) {
        return receivedEmails.stream()
                .filter(criteria)
                .collect(Collectors.toList());
    }

    /**
     * Get email statistics
     */
    public Map<String, Long> getEmailStatistics() {
        return receivedEmails.stream()
                .collect(Collectors.groupingBy(
                        MockEmail::getTo,
                        Collectors.counting()
                ));
    }

    /**
     * Clear emails older than specified time
     */
    public void clearEmailsOlderThan(long maxAgeMillis) {
        long cutoffTime = System.currentTimeMillis() - maxAgeMillis;
        receivedEmails.removeIf(email -> email.getTimestamp() < cutoffTime);
    }

    /**
     * Verify that an email was sent from a specific sender
     */
    public boolean wasEmailSentFrom(String sender) {
        return receivedEmails.stream()
                .anyMatch(email -> email.getFrom().equalsIgnoreCase(sender));
    }

    /**
     * Verify that an email contains specific text in content
     */
    public boolean wasEmailSentWithContent(String contentText) {
        return receivedEmails.stream()
                .anyMatch(email -> email.getContent().toLowerCase().contains(contentText.toLowerCase()));
    }

    /**
     * Get all emails sent to a specific recipient
     */
    public List<MockEmail> getEmailsTo(String recipient) {
        return findEmails(email -> email.getTo().equalsIgnoreCase(recipient));
    }

    /**
     * Get all emails from a specific sender
     */
    public List<MockEmail> getEmailsFrom(String sender) {
        return findEmails(email -> email.getFrom().equalsIgnoreCase(sender));
    }

    /**
     * Get all emails with specific subject
     */
    public List<MockEmail> getEmailsWithSubject(String subject) {
        return findEmails(email -> email.getSubject().toLowerCase().contains(subject.toLowerCase()));
    }

    /**
     * Check if any emails were received
     */
    public boolean hasReceivedEmails() {
        return !receivedEmails.isEmpty();
    }

    /**
     * Clear all emails for a specific recipient
     */
    public void clearEmailsForRecipient(String recipient) {
        receivedEmails.removeIf(email -> email.getTo().equalsIgnoreCase(recipient));
    }

    /**
     * Inner class to represent a mock email
     */
    @Getter
    @AllArgsConstructor
    public static class MockEmail {
        private final String from;
        private final String to;
        private final String subject;
        private final String content;
        private final long timestamp = System.currentTimeMillis();

        @Override
        public String toString() {
            return String.format("MockEmail{from='%s', to='%s', subject='%s', contentLength=%d, timestamp=%d}",
                    from, to, subject, content != null ? content.length() : 0, timestamp);
        }
    }
}

package com.notificationservice;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.scheduling.annotation.EnableAsync;
import org.springframework.scheduling.annotation.EnableScheduling;

@SpringBootApplication
@EnableAsync
@EnableScheduling
public class NotificationServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(NotificationServiceApplication.class, args);
    }
}

-- Create notifications table
CREATE TABLE notifications (
    id VARCHAR(36) PRIMARY KEY,
    type VARCHAR(50) NOT NULL,
    status VARCHAR(50) NOT NULL DEFAULT 'PENDING',
    recipient VARCHAR(255) NOT NULL,
    subject VARCHAR(500),
    message TEXT,
    template_id VARCHAR(36),
    error_message TEXT,
    retry_count INTEGER DEFAULT 0,
    priority VARCHAR(20) DEFAULT 'NORMAL',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    sent_at TIMESTAMP
);

-- Create notification_templates table
CREATE TABLE notification_templates (
    id VARCHAR(36) PRIMARY KEY,
    name VARCHAR(255) NOT NULL UNIQUE,
    type VARCHAR(50) NOT NULL,
    subject VARCHAR(500) NOT NULL,
    content TEXT NOT NULL,
    variables TEXT,
    version VARCHAR(20) DEFAULT '1.0',
    active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    created_by VARCHAR(255)
);

-- Create email_providers table
CREATE TABLE email_providers (
    id VARCHAR(36) PRIMARY KEY,
    name VARCHAR(255) NOT NULL UNIQUE,
    host VARCHAR(255) NOT NULL,
    port INTEGER NOT NULL,
    username VARCHAR(255) NOT NULL,
    password VARCHAR(255) NOT NULL,
    from_email VARCHAR(255) NOT NULL,
    active BOOLEAN DEFAULT TRUE,
    priority INTEGER DEFAULT 1,
    daily_limit INTEGER DEFAULT 1000,
    current_usage INTEGER DEFAULT 0,
    last_reset TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Create users table for push notifications
CREATE TABLE users (
    id VARCHAR(36) PRIMARY KEY,
    email VARCHAR(255) UNIQUE,
    push_token VARCHAR(500),
    platform VARCHAR(50),
    device_id VARCHAR(255),
    active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Create notification_logs table for auditing
CREATE TABLE notification_logs (
    id VARCHAR(36) PRIMARY KEY,
    notification_id VARCHAR(36) NOT NULL,
    action VARCHAR(100) NOT NULL,
    details TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    created_by VARCHAR(255)
);

-- Create indexes
CREATE INDEX idx_notifications_status ON notifications(status);
CREATE INDEX idx_notifications_recipient ON notifications(recipient);
CREATE INDEX idx_notifications_created_at ON notifications(created_at);
CREATE INDEX idx_notifications_type ON notifications(type);
CREATE INDEX idx_templates_name ON notification_templates(name);
CREATE INDEX idx_templates_type ON notification_templates(type);
CREATE INDEX idx_templates_active ON notification_templates(active);
CREATE INDEX idx_email_providers_active ON email_providers(active);
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_push_token ON users(push_token);

-- Insert default templates
INSERT INTO notification_templates (id, name, type, subject, content, variables, created_by) VALUES
('welcome-template', 'Welcome Email', 'EMAIL', 'Welcome to Our Service',
'<html><body><h1>Welcome {{name}}!</h1><p>Thank you for joining our service.</p></body></html>',
'["name", "email"]', 'system'),

('password-reset-template', 'Password Reset', 'EMAIL', 'Password Reset Request',
'<html><body><h1>Password Reset</h1><p>Click <a href="{{resetLink}}">here</a> to reset your password.</p></body></html>',
'["resetLink"]', 'system'),

('notification-template', 'General Notification', 'EMAIL', '{{subject}}',
'<html><body><p>{{message}}</p></body></html>',
'["subject", "message"]', 'system');

-- Insert default email providers
INSERT INTO email_providers (id, name, host, port, username, password, from_email, priority) VALUES
('smtp-gmail', 'Gmail SMTP', 'smtp.gmail.com', 587, 'your-email@gmail.com', 'your-app-password', 'noreply@company.com', 1),
('smtp-sendgrid', 'SendGrid', 'smtp.sendgrid.net', 587, 'apikey', 'your-sendgrid-key', 'noreply@company.com', 2);

-- Migration: V2__Add_templates_table.sql
-- Description: Add notification_templates table and related indexes

-- Create notification_templates table
CREATE TABLE notification_templates (
    id VARCHAR(36) PRIMARY KEY,
    name VARCHAR(255) NOT NULL UNIQUE,
    type VARCHAR(50) NOT NULL CHECK (type IN ('EMAIL', 'PUSH', 'SMS')),
    subject VARCHAR(500) NOT NULL,
    content TEXT NOT NULL,
    variables TEXT,
    version VARCHAR(20) DEFAULT '1.0',
    active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    created_by VARCHAR(255)
);

-- Create index on template name for fast lookups
CREATE INDEX idx_templates_name ON notification_templates(name);

-- Create index on template type for filtering
CREATE INDEX idx_templates_type ON notification_templates(type);

-- Create index on active templates for quick retrieval
CREATE INDEX idx_templates_active ON notification_templates(active) WHERE active = true;

-- Create index on updated_at for recently modified templates
CREATE INDEX idx_templates_updated_at ON notification_templates(updated_at);

-- Add comment to table
COMMENT ON TABLE notification_templates IS 'Stores templates for different types of notifications';

-- Add comments to columns
COMMENT ON COLUMN notification_templates.id IS 'Unique identifier for the template';
COMMENT ON COLUMN notification_templates.name IS 'Unique name identifier for the template';
COMMENT ON COLUMN notification_templates.type IS 'Type of notification (EMAIL, PUSH, SMS)';
COMMENT ON COLUMN notification_templates.subject IS 'Subject line for emails or title for push notifications';
COMMENT ON COLUMN notification_templates.content IS 'Template content with placeholders';
COMMENT ON COLUMN notification_templates.variables IS 'JSON array of available template variables';
COMMENT ON COLUMN notification_templates.version IS 'Template version for tracking changes';
COMMENT ON COLUMN notification_templates.active IS 'Whether the template is active and can be used';
COMMENT ON COLUMN notification_templates.created_at IS 'Timestamp when template was created';
COMMENT ON COLUMN notification_templates.updated_at IS 'Timestamp when template was last updated';
COMMENT ON COLUMN notification_templates.created_by IS 'User or system that created the template';

-- Insert default templates
INSERT INTO notification_templates (id, name, type, subject, content, variables, created_by) VALUES
(
    'welcome-email-template',
    'Welcome Email',
    'EMAIL',
    'Welcome to Our Service, {{name}}!',
    '<!DOCTYPE html>
<html>
<head>
    <style>
        body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
        .header { background: #4CAF50; color: white; padding: 20px; text-align: center; }
        .content { padding: 20px; }
        .footer { background: #f4f4f4; padding: 10px; text-align: center; font-size: 12px; }
    </style>
</head>
<body>
    <div class="header">
        <h1>Welcome to Our Platform!</h1>
    </div>
    <div class="content">
        <h2>Hello {{name}},</h2>
        <p>Thank you for joining our service. We''re excited to have you on board!</p>
        <p>Your account has been successfully created with email: <strong>{{email}}</strong></p>
        <p>Get started by exploring our features and let us know if you need any help.</p>
        <p>Best regards,<br>The Team</p>
    </div>
    <div class="footer">
        <p>&copy; 2024 Our Company. All rights reserved.</p>
    </div>
</body>
</html>',
    '["name", "email"]',
    'system'
),
(
    'password-reset-template',
    'Password Reset',
    'EMAIL',
    'Password Reset Request',
    '<!DOCTYPE html>
<html>
<head>
    <style>
        body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
        .header { background: #ff6b6b; color: white; padding: 20px; text-align: center; }
        .content { padding: 20px; }
        .button { background: #007bff; color: white; padding: 10px 20px; text-decoration: none; border-radius: 5px; }
        .footer { background: #f4f4f4; padding: 10px; text-align: center; font-size: 12px; }
    </style>
</head>
<body>
    <div class="header">
        <h1>Password Reset</h1>
    </div>
    <div class="content">
        <h2>Hello {{name}},</h2>
        <p>We received a request to reset your password. Click the button below to create a new password:</p>
        <p><a href="{{resetLink}}" class="button">Reset Password</a></p>
        <p>This link will expire in {{expirationHours}} hours.</p>
        <p>If you didn''t request this reset, please ignore this email.</p>
        <p>Best regards,<br>Security Team</p>
    </div>
    <div class="footer">
        <p>&copy; 2024 Our Company. All rights reserved.</p>
    </div>
</body>
</html>',
    '["name", "resetLink", "expirationHours"]',
    'system'
),
(
    'order-confirmation-template',
    'Order Confirmation',
    'EMAIL',
    'Order Confirmation - #{{orderNumber}}',
    '<!DOCTYPE html>
<html>
<head>
    <style>
        body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
        .header { background: #007bff; color: white; padding: 20px; text-align: center; }
        .content { padding: 20px; }
        .order-details { background: #f8f9fa; padding: 15px; border-radius: 5px; }
        .footer { background: #f4f4f4; padding: 10px; text-align: center; font-size: 12px; }
    </style>
</head>
<body>
    <div class="header">
        <h1>Order Confirmation</h1>
    </div>
    <div class="content">
        <h2>Thank you for your order, {{customerName}}!</h2>
        <div class="order-details">
            <h3>Order Details:</h3>
            <p><strong>Order Number:</strong> {{orderNumber}}</p>
            <p><strong>Order Date:</strong> {{orderDate}}</p>
            <p><strong>Total Amount:</strong> {{totalAmount}}</p>
            <p><strong>Shipping Address:</strong> {{shippingAddress}}</p>
        </div>
        <p>We''ll send you a shipping confirmation when your order is on its way.</p>
        <p>Best regards,<br>Customer Service Team</p>
    </div>
    <div class="footer">
        <p>&copy; 2024 Our Company. All rights reserved.</p>
    </div>
</body>
</html>',
    '["customerName", "orderNumber", "orderDate", "totalAmount", "shippingAddress"]',
    'system'
),
(
    'push-notification-template',
    'Generic Push Notification',
    'PUSH',
    '{{title}}',
    '{{message}}',
    '["title", "message", "deepLink"]',
    'system'
),
(
    'system-alert-template',
    'System Alert',
    'EMAIL',
    'System Alert: {{alertType}}',
    '<!DOCTYPE html>
<html>
<head>
    <style>
        body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
        .header { background: #ffc107; color: #333; padding: 20px; text-align: center; }
        .content { padding: 20px; }
        .alert { background: #fff3cd; border: 1px solid #ffeaa7; padding: 15px; border-radius: 5px; }
        .footer { background: #f4f4f4; padding: 10px; text-align: center; font-size: 12px; }
    </style>
</head>
<body>
    <div class="header">
        <h1>System Alert</h1>
    </div>
    <div class="content">
        <div class="alert">
            <h3>Alert Type: {{alertType}}</h3>
            <p><strong>Message:</strong> {{alertMessage}}</p>
            <p><strong>Time:</strong> {{alertTime}}</p>
            <p><strong>Severity:</strong> {{severity}}</p>
        </div>
        <p>Please review and take appropriate action if necessary.</p>
        <p>Best regards,<br>System Monitoring Team</p>
    </div>
    <div class="footer">
        <p>&copy; 2024 Our Company. All rights reserved.</p>
    </div>
</body>
</html>',
    '["alertType", "alertMessage", "alertTime", "severity"]',
    'system'
);

-- Create template_audit_log table for tracking template changes
CREATE TABLE template_audit_log (
    id VARCHAR(36) PRIMARY KEY,
    template_id VARCHAR(36) NOT NULL,
    action VARCHAR(50) NOT NULL CHECK (action IN ('CREATE', 'UPDATE', 'DELETE', 'ACTIVATE', 'DEACTIVATE')),
    old_values JSONB,
    new_values JSONB,
    changed_by VARCHAR(255) NOT NULL,
    changed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (template_id) REFERENCES notification_templates(id) ON DELETE CASCADE
);

-- Create index on template_audit_log for efficient querying
CREATE INDEX idx_template_audit_template_id ON template_audit_log(template_id);
CREATE INDEX idx_template_audit_changed_at ON template_audit_log(changed_at);
CREATE INDEX idx_template_audit_action ON template_audit_log(action);

-- Add comment to audit table
COMMENT ON TABLE template_audit_log IS 'Audit trail for template changes';

-- Create function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Create trigger to automatically update updated_at
CREATE TRIGGER update_templates_updated_at
    BEFORE UPDATE ON notification_templates
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Create function to log template changes
CREATE OR REPLACE FUNCTION log_template_changes()
RETURNS TRIGGER AS $$
BEGIN
    IF (TG_OP = 'INSERT') THEN
        INSERT INTO template_audit_log (id, template_id, action, new_values, changed_by)
        VALUES (gen_random_uuid()::text, NEW.id, 'CREATE', row_to_json(NEW), NEW.created_by);
        RETURN NEW;
    ELSIF (TG_OP = 'UPDATE') THEN
        INSERT INTO template_audit_log (id, template_id, action, old_values, new_values, changed_by)
        VALUES (gen_random_uuid()::text, NEW.id, 'UPDATE', row_to_json(OLD), row_to_json(NEW), NEW.created_by);
        RETURN NEW;
    ELSIF (TG_OP = 'DELETE') THEN
        INSERT INTO template_audit_log (id, template_id, action, old_values, changed_by)
        VALUES (gen_random_uuid()::text, OLD.id, 'DELETE', row_to_json(OLD), OLD.created_by);
        RETURN OLD;
    END IF;
    RETURN NULL;
END;
$$ language 'plpgsql';

-- Create trigger for template audit logging
CREATE TRIGGER audit_template_changes
    AFTER INSERT OR UPDATE OR DELETE ON notification_templates
    FOR EACH ROW
    EXECUTE FUNCTION log_template_changes();


-- Migration: V3__Add_email_providers.sql
-- Description: Add email_providers table for multiple SMTP provider support with failover

-- Create email_providers table
CREATE TABLE email_providers (
    id VARCHAR(36) PRIMARY KEY,
    name VARCHAR(255) NOT NULL UNIQUE,
    host VARCHAR(255) NOT NULL,
    port INTEGER NOT NULL CHECK (port BETWEEN 1 AND 65535),
    username VARCHAR(255) NOT NULL,
    password VARCHAR(255) NOT NULL,
    from_email VARCHAR(255) NOT NULL,
    from_name VARCHAR(255),
    active BOOLEAN DEFAULT TRUE,
    priority INTEGER DEFAULT 1 CHECK (priority >= 1),
    daily_limit INTEGER DEFAULT 1000 CHECK (daily_limit >= 0),
    current_usage INTEGER DEFAULT 0 CHECK (current_usage >= 0),
    max_connection_pool_size INTEGER DEFAULT 5,
    connection_timeout INTEGER DEFAULT 5000,
    timeout INTEGER DEFAULT 5000,
    use_ssl BOOLEAN DEFAULT FALSE,
    use_tls BOOLEAN DEFAULT TRUE,
    last_used TIMESTAMP,
    last_reset TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    created_by VARCHAR(255)
);

-- Create indexes for efficient querying
CREATE INDEX idx_email_providers_active ON email_providers(active) WHERE active = true;
CREATE INDEX idx_email_providers_priority ON email_providers(priority);
CREATE INDEX idx_email_providers_usage ON email_providers(current_usage);
CREATE INDEX idx_email_providers_last_used ON email_providers(last_used);

-- Create index for finding available providers
CREATE INDEX idx_email_providers_available ON email_providers(active, priority)
WHERE active = true AND current_usage < daily_limit;

-- Add comments to table
COMMENT ON TABLE email_providers IS 'Stores configuration for multiple SMTP providers with failover support';

-- Add comments to columns
COMMENT ON COLUMN email_providers.id IS 'Unique identifier for the provider';
COMMENT ON COLUMN email_providers.name IS 'Unique name for the provider configuration';
COMMENT ON COLUMN email_providers.host IS 'SMTP server hostname';
COMMENT ON COLUMN email_providers.port IS 'SMTP server port';
COMMENT ON COLUMN email_providers.username IS 'SMTP authentication username';
COMMENT ON COLUMN email_providers.password IS 'SMTP authentication password';
COMMENT ON COLUMN email_providers.from_email IS 'Default from email address';
COMMENT ON COLUMN email_providers.from_name IS 'Default from name';
COMMENT ON COLUMN email_providers.active IS 'Whether the provider is active and can be used';
COMMENT ON COLUMN email_providers.priority IS 'Priority for provider selection (lower number = higher priority)';
COMMENT ON COLUMN email_providers.daily_limit IS 'Maximum number of emails allowed per day';
COMMENT ON COLUMN email_providers.current_usage IS 'Number of emails sent today';
COMMENT ON COLUMN email_providers.max_connection_pool_size IS 'Maximum connection pool size for this provider';
COMMENT ON COLUMN email_providers.connection_timeout IS 'Connection timeout in milliseconds';
COMMENT ON COLUMN email_providers.timeout IS 'Socket timeout in milliseconds';
COMMENT ON COLUMN email_providers.use_ssl IS 'Whether to use SSL encryption';
COMMENT ON COLUMN email_providers.use_tls IS 'Whether to use TLS encryption';
COMMENT ON COLUMN email_providers.last_used IS 'Timestamp when provider was last used successfully';
COMMENT ON COLUMN email_providers.last_reset IS 'Timestamp when usage counter was last reset';
COMMENT ON COLUMN email_providers.created_at IS 'Timestamp when provider was created';
COMMENT ON COLUMN email_providers.updated_at IS 'Timestamp when provider was last updated';
COMMENT ON COLUMN email_providers.created_by IS 'User or system that created the provider configuration';

-- Insert default email providers
INSERT INTO email_providers (
    id, name, host, port, username, password, from_email, from_name,
    priority, daily_limit, use_ssl, use_tls, created_by
) VALUES
(
    'smtp-gmail-primary',
    'Gmail Primary',
    'smtp.gmail.com',
    587,
    'your-email@gmail.com',
    'your-app-password',
    'noreply@company.com',
    'Company Notifications',
    1,
    500,
    false,
    true,
    'system'
),
(
    'smtp-gmail-secondary',
    'Gmail Secondary',
    'smtp.gmail.com',
    587,
    'your-backup-email@gmail.com',
    'your-app-password',
    'noreply@company.com',
    'Company Notifications',
    2,
    500,
    false,
    true,
    'system'
),
(
    'smtp-sendgrid',
    'SendGrid',
    'smtp.sendgrid.net',
    587,
    'apikey',
    'your-sendgrid-api-key',
    'noreply@company.com',
    'Company Notifications',
    3,
    10000,
    false,
    true,
    'system'
),
(
    'smtp-mailgun',
    'Mailgun',
    'smtp.mailgun.org',
    587,
    'postmaster@your-domain.mailgun.org',
    'your-mailgun-password',
    'noreply@company.com',
    'Company Notifications',
    4,
    10000,
    false,
    true,
    'system'
),
(
    'smtp-amazon-ses',
    'Amazon SES',
    'email-smtp.us-east-1.amazonaws.com',
    587,
    'your-ses-smtp-username',
    'your-ses-smtp-password',
    'noreply@company.com',
    'Company Notifications',
    5,
    50000,
    false,
    true,
    'system'
);

-- Create provider_usage_log table for tracking provider usage
CREATE TABLE provider_usage_log (
    id VARCHAR(36) PRIMARY KEY,
    provider_id VARCHAR(36) NOT NULL,
    notification_id VARCHAR(36),
    recipient_count INTEGER DEFAULT 1,
    success BOOLEAN NOT NULL,
    error_message TEXT,
    response_time INTEGER, -- in milliseconds
    used_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (provider_id) REFERENCES email_providers(id) ON DELETE CASCADE
);

-- Create indexes for usage log
CREATE INDEX idx_provider_usage_provider_id ON provider_usage_log(provider_id);
CREATE INDEX idx_provider_usage_used_at ON provider_usage_log(used_at);
CREATE INDEX idx_provider_usage_success ON provider_usage_log(success);
CREATE INDEX idx_provider_usage_response_time ON provider_usage_log(response_time);

-- Add comment to usage log table
COMMENT ON TABLE provider_usage_log IS 'Logs usage and performance of email providers';

-- Create provider_health_metrics table for monitoring provider health
CREATE TABLE provider_health_metrics (
    id VARCHAR(36) PRIMARY KEY,
    provider_id VARCHAR(36) NOT NULL,
    check_timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    is_reachable BOOLEAN NOT NULL,
    response_time INTEGER, -- in milliseconds
    error_rate DECIMAL(5,4) DEFAULT 0, -- error rate as decimal (0.0 to 1.0)
    success_rate DECIMAL(5,4) DEFAULT 1.0, -- success rate as decimal (0.0 to 1.0)
    queue_length INTEGER DEFAULT 0,
    FOREIGN KEY (provider_id) REFERENCES email_providers(id) ON DELETE CASCADE
);

-- Create indexes for health metrics
CREATE INDEX idx_provider_health_provider_id ON provider_health_metrics(provider_id);
CREATE INDEX idx_provider_health_timestamp ON provider_health_metrics(check_timestamp);
CREATE INDEX idx_provider_health_reachable ON provider_health_metrics(is_reachable);

-- Add comment to health metrics table
COMMENT ON TABLE provider_health_metrics IS 'Health and performance metrics for email providers';

-- Create function to update provider usage
CREATE OR REPLACE FUNCTION update_provider_usage()
RETURNS TRIGGER AS $$
BEGIN
    -- Update current_usage and last_used when a provider is used
    UPDATE email_providers
    SET
        current_usage = current_usage + NEW.recipient_count,
        last_used = CURRENT_TIMESTAMP
    WHERE id = NEW.provider_id;

    RETURN NEW;
END;
$$ language 'plpgsql';

-- Create trigger to update provider usage
CREATE TRIGGER update_provider_usage_trigger
    AFTER INSERT ON provider_usage_log
    FOR EACH ROW
    WHEN (NEW.success = true)
    EXECUTE FUNCTION update_provider_usage();

-- Create function to reset daily usage counters
CREATE OR REPLACE FUNCTION reset_daily_usage()
RETURNS VOID AS $$
BEGIN
    UPDATE email_providers
    SET
        current_usage = 0,
        last_reset = CURRENT_TIMESTAMP
    WHERE last_reset < CURRENT_DATE;
END;
$$ language 'plpgsql';

-- Create function to get best available provider
CREATE OR REPLACE FUNCTION get_best_available_provider()
RETURNS TABLE(
    provider_id VARCHAR(36),
    provider_name VARCHAR(255),
    host VARCHAR(255),
    port INTEGER,
    username VARCHAR(255),
    password VARCHAR(255),
    from_email VARCHAR(255),
    from_name VARCHAR(255)
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        ep.id,
        ep.name,
        ep.host,
        ep.port,
        ep.username,
        ep.password,
        ep.from_email,
        ep.from_name
    FROM email_providers ep
    WHERE
        ep.active = true
        AND ep.current_usage < ep.daily_limit
    ORDER BY
        ep.priority ASC,
        ep.current_usage::decimal / ep.daily_limit ASC -- Prefer less used providers
    LIMIT 1;
END;
$$ language 'plpgsql';

-- Create function to calculate provider health score
CREATE OR REPLACE FUNCTION calculate_provider_health_score(provider_id VARCHAR)
RETURNS DECIMAL AS $$
DECLARE
    health_score DECIMAL;
    recent_success_rate DECIMAL;
    avg_response_time DECIMAL;
    usage_ratio DECIMAL;
BEGIN
    -- Calculate recent success rate (last hour)
    SELECT
        COALESCE(
            SUM(CASE WHEN success THEN 1 ELSE 0 END)::decimal / NULLIF(COUNT(*), 0),
            1.0
        ) INTO recent_success_rate
    FROM provider_usage_log
    WHERE provider_id = $1
    AND used_at >= (CURRENT_TIMESTAMP - INTERVAL '1 hour');

    -- Calculate average response time (last hour)
    SELECT
        COALESCE(AVG(response_time), 1000) INTO avg_response_time
    FROM provider_usage_log
    WHERE provider_id = $1
    AND success = true
    AND used_at >= (CURRENT_TIMESTAMP - INTERVAL '1 hour');

    -- Calculate usage ratio
    SELECT
        COALESCE(current_usage::decimal / NULLIF(daily_limit, 0), 0) INTO usage_ratio
    FROM email_providers
    WHERE id = $1;

    -- Calculate health score (0.0 to 1.0)
    health_score :=
        (recent_success_rate * 0.5) +
        (GREATEST(0, 1 - (avg_response_time / 5000)) * 0.3) + -- Normalize response time (5s max)
        (GREATEST(0, 1 - usage_ratio) * 0.2); -- Lower score for highly used providers

    RETURN health_score;
END;
$$ language 'plpgsql';

-- Create updated_at trigger for email_providers
CREATE TRIGGER update_email_providers_updated_at
    BEFORE UPDATE ON email_providers
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Create view for provider status
CREATE VIEW provider_status AS
SELECT
    ep.id,
    ep.name,
    ep.active,
    ep.priority,
    ep.current_usage,
    ep.daily_limit,
    ep.last_used,
    ROUND((ep.current_usage::decimal / NULLIF(ep.daily_limit, 0)) * 100, 2) as usage_percentage,
    calculate_provider_health_score(ep.id) as health_score,
    CASE
        WHEN ep.active = false THEN 'INACTIVE'
        WHEN ep.current_usage >= ep.daily_limit THEN 'LIMIT_EXCEEDED'
        WHEN calculate_provider_health_score(ep.id) < 0.5 THEN 'UNHEALTHY'
        WHEN ep.last_used IS NULL OR ep.last_used < (CURRENT_TIMESTAMP - INTERVAL '1 hour') THEN 'IDLE'
        ELSE 'HEALTHY'
    END as status
FROM email_providers ep;

-- Add comment to the view
COMMENT ON VIEW provider_status IS 'Current status and health of all email providers';

-- data.sql
-- Initial data population for Notification Service
-- This file contains sample data for development and testing environments

-- Insert sample users for push notifications
INSERT INTO users (id, email, push_token, platform, device_id, active, created_at) VALUES
(
    'user-001',
    'john.doe@example.com',
    'fcm_token_john_android',
    'ANDROID',
    'device_android_001',
    true,
    CURRENT_TIMESTAMP
),
(
    'user-002',
    'jane.smith@example.com',
    'apns_token_jane_ios',
    'IOS',
    'device_ios_001',
    true,
    CURRENT_TIMESTAMP
),
(
    'user-003',
    'bob.wilson@example.com',
    'web_push_token_bob',
    'WEB',
    'device_web_001',
    true,
    CURRENT_TIMESTAMP
),
(
    'user-004',
    'alice.brown@example.com',
    'fcm_token_alice_android',
    'ANDROID',
    'device_android_002',
    true,
    CURRENT_TIMESTAMP
),
(
    'user-005',
    'charlie.davis@example.com',
    NULL,
    'ANDROID',
    'device_android_003',
    false,
    CURRENT_TIMESTAMP
) ON CONFLICT (id) DO NOTHING;

-- Insert additional notification templates
INSERT INTO notification_templates (id, name, type, subject, content, variables, version, active, created_by) VALUES
(
    'weekly-newsletter-template',
    'Weekly Newsletter',
    'EMAIL',
    'Your Weekly Newsletter - {{date}}',
    '<!DOCTYPE html>
<html>
<head>
    <style>
        body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; max-width: 600px; margin: 0 auto; }
        .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 30px; text-align: center; }
        .content { padding: 30px; background: #f9f9f9; }
        .news-item { background: white; padding: 15px; margin: 15px 0; border-radius: 5px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .footer { text-align: center; padding: 20px; font-size: 12px; color: #666; }
        .button { display: inline-block; padding: 12px 24px; background-color: #667eea; color: white; text-decoration: none; border-radius: 5px; }
    </style>
</head>
<body>
    <div class="header">
        <h1>Weekly Newsletter</h1>
        <p>{{date}}</p>
    </div>
    <div class="content">
        <h2>Hello {{subscriberName}}!</h2>
        <p>Here are this week''s updates:</p>

        <div class="news-item">
            <h3>{{featureTitle1}}</h3>
            <p>{{featureDescription1}}</p>
        </div>

        <div class="news-item">
            <h3>{{featureTitle2}}</h3>
            <p>{{featureDescription2}}</p>
        </div>

        <div style="text-align: center; margin: 30px 0;">
            <a href="{{newsletterLink}}" class="button">Read Full Newsletter</a>
        </div>

        <p>Thank you for being a valued subscriber!</p>
    </div>
    <div class="footer">
        <p>&copy; 2024 Our Company. All rights reserved.</p>
        <p><a href="{{unsubscribeLink}}">Unsubscribe</a> from these emails.</p>
    </div>
</body>
</html>',
    '["date", "subscriberName", "featureTitle1", "featureDescription1", "featureTitle2", "featureDescription2", "newsletterLink", "unsubscribeLink"]',
    '1.0',
    true,
    'system'
),
(
    'account-verification-template',
    'Account Verification',
    'EMAIL',
    'Verify Your Account',
    '<!DOCTYPE html>
<html>
<head>
    <style>
        body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; max-width: 600px; margin: 0 auto; }
        .header { background: #28a745; color: white; padding: 30px; text-align: center; }
        .content { padding: 30px; background: #f9f9f9; }
        .code { font-size: 32px; font-weight: bold; text-align: center; letter-spacing: 5px; margin: 20px 0; color: #28a745; }
        .footer { text-align: center; padding: 20px; font-size: 12px; color: #666; }
    </style>
</head>
<body>
    <div class="header">
        <h1>Account Verification</h1>
    </div>
    <div class="content">
        <h2>Hello {{name}}!</h2>
        <p>Thank you for creating an account. Please use the verification code below to complete your registration:</p>

        <div class="code">{{verificationCode}}</div>

        <p>This code will expire in {{expirationMinutes}} minutes.</p>
        <p>If you didn''t create an account, please ignore this email.</p>
    </div>
    <div class="footer">
        <p>&copy; 2024 Our Company. All rights reserved.</p>
    </div>
</body>
</html>',
    '["name", "verificationCode", "expirationMinutes"]',
    '1.0',
    true,
    'system'
),
(
    'promotional-offer-template',
    'Promotional Offer',
    'EMAIL',
    'Special Offer Just For You!',
    '<!DOCTYPE html>
<html>
<head>
    <style>
        body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; max-width: 600px; margin: 0 auto; }
        .header { background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%); color: white; padding: 40px; text-align: center; }
        .content { padding: 30px; background: #f9f9f9; }
        .offer { background: white; padding: 25px; margin: 20px 0; border-radius: 10px; text-align: center; box-shadow: 0 4px 8px rgba(0,0,0,0.1); }
        .discount { font-size: 48px; font-weight: bold; color: #ff6b6b; margin: 10px 0; }
        .button { display: inline-block; padding: 15px 30px; background: #ff6b6b; color: white; text-decoration: none; border-radius: 25px; font-size: 18px; margin: 20px 0; }
        .footer { text-align: center; padding: 20px; font-size: 12px; color: #666; }
    </style>
</head>
<body>
    <div class="header">
        <h1>Special Offer!</h1>
        <p>Limited Time Promotion</p>
    </div>
    <div class="content">
        <div class="offer">
            <h2>Hello {{customerName}}!</h2>
            <p>As a valued customer, we''re offering you an exclusive discount:</p>
            <div class="discount">{{discountPercentage}}% OFF</div>
            <p>Use code: <strong>{{promoCode}}</strong></p>
            <p>Valid until: {{expiryDate}}</p>
            <a href="{{offerLink}}" class="button">Claim Your Offer</a>
        </div>
        <p>Don''t miss out on this amazing opportunity!</p>
    </div>
    <div class="footer">
        <p>&copy; 2024 Our Company. All rights reserved.</p>
        <p><a href="{{unsubscribeLink}}">Unsubscribe</a> from promotional emails.</p>
    </div>
</body>
</html>',
    '["customerName", "discountPercentage", "promoCode", "expiryDate", "offerLink", "unsubscribeLink"]',
    '1.0',
    true,
    'system'
) ON CONFLICT (id) DO NOTHING;

-- Insert sample notifications for testing
INSERT INTO notifications (id, type, status, recipient, subject, message, template_id, retry_count, priority, created_at, sent_at) VALUES
(
    'notif-001',
    'EMAIL',
    'SENT',
    'john.doe@example.com',
    'Welcome to Our Service, John!',
    'Welcome email content...',
    'welcome-email-template',
    0,
    'NORMAL',
    CURRENT_TIMESTAMP - INTERVAL '2 days',
    CURRENT_TIMESTAMP - INTERVAL '2 days' + INTERVAL '5 minutes'
),
(
    'notif-002',
    'PUSH',
    'SENT',
    'user-001',
    'New Message Received',
    'You have a new message from Jane',
    'push-notification-template',
    0,
    'HIGH',
    CURRENT_TIMESTAMP - INTERVAL '1 day',
    CURRENT_TIMESTAMP - INTERVAL '1 day' + INTERVAL '10 seconds'
),
(
    'notif-003',
    'EMAIL',
    'FAILED',
    'invalid-email@example',
    'Password Reset Request',
    'Reset password content...',
    'password-reset-template',
    3,
    'NORMAL',
    CURRENT_TIMESTAMP - INTERVAL '3 hours',
    NULL
),
(
    'notif-004',
    'EMAIL',
    'PENDING',
    'alice.brown@example.com',
    'Weekly Newsletter - 2024-01-15',
    'Newsletter content...',
    'weekly-newsletter-template',
    0,
    'LOW',
    CURRENT_TIMESTAMP - INTERVAL '30 minutes',
    NULL
),
(
    'notif-005',
    'PUSH',
    'SENT',
    'user-002',
    'Order Shipped',
    'Your order #12345 has been shipped',
    'push-notification-template',
    0,
    'NORMAL',
    CURRENT_TIMESTAMP - INTERVAL '2 hours',
    CURRENT_TIMESTAMP - INTERVAL '2 hours' + INTERVAL '15 seconds'
),
(
    'notif-006',
    'EMAIL',
    'SENT',
    'bob.wilson@example.com',
    'Order Confirmation - #67890',
    'Order confirmation content...',
    'order-confirmation-template',
    0,
    'NORMAL',
    CURRENT_TIMESTAMP - INTERVAL '6 hours',
    CURRENT_TIMESTAMP - INTERVAL '6 hours' + INTERVAL '2 minutes'
) ON CONFLICT (id) DO NOTHING;

-- Insert sample provider usage logs
INSERT INTO provider_usage_log (id, provider_id, notification_id, recipient_count, success, error_message, response_time, used_at) VALUES
(
    'usage-log-001',
    'smtp-gmail-primary',
    'notif-001',
    1,
    true,
    NULL,
    1200,
    CURRENT_TIMESTAMP - INTERVAL '2 days'
),
(
    'usage-log-002',
    'smtp-gmail-primary',
    'notif-003',
    1,
    false,
    'SMTP connection timeout',
    5000,
    CURRENT_TIMESTAMP - INTERVAL '3 hours'
),
(
    'usage-log-003',
    'smtp-gmail-secondary',
    'notif-003',
    1,
    false,
    'Invalid email address',
    800,
    CURRENT_TIMESTAMP - INTERVAL '2 hours'
),
(
    'usage-log-004',
    'smtp-sendgrid',
    'notif-006',
    1,
    true,
    NULL,
    950,
    CURRENT_TIMESTAMP - INTERVAL '6 hours'
) ON CONFLICT (id) DO NOTHING;

-- Insert sample template audit logs
INSERT INTO template_audit_log (id, template_id, action, old_values, new_values, changed_by, changed_at) VALUES
(
    'audit-001',
    'welcome-email-template',
    'UPDATE',
    '{"subject": "Welcome to Our Service", "version": "1.0"}',
    '{"subject": "Welcome to Our Service, {{name}}!", "version": "1.1"}',
    'admin-user',
    CURRENT_TIMESTAMP - INTERVAL '5 days'
),
(
    'audit-002',
    'password-reset-template',
    'ACTIVATE',
    NULL,
    '{"active": true}',
    'system',
    CURRENT_TIMESTAMP - INTERVAL '3 days'
) ON CONFLICT (id) DO NOTHING;

-- Insert sample provider health metrics
INSERT INTO provider_health_metrics (id, provider_id, check_timestamp, is_reachable, response_time, error_rate, success_rate, queue_length) VALUES
(
    'health-001',
    'smtp-gmail-primary',
    CURRENT_TIMESTAMP - INTERVAL '1 hour',
    true,
    1200,
    0.05,
    0.95,
    0
),
(
    'health-002',
    'smtp-gmail-secondary',
    CURRENT_TIMESTAMP - INTERVAL '1 hour',
    true,
    1500,
    0.02,
    0.98,
    0
),
(
    'health-003',
    'smtp-sendgrid',
    CURRENT_TIMESTAMP - INTERVAL '1 hour',
    true,
    900,
    0.01,
    0.99,
    0
) ON CONFLICT (id) DO NOTHING;

-- Insert sample notification logs for auditing
INSERT INTO notification_logs (id, notification_id, action, details, created_at, created_by) VALUES
(
    'nlog-001',
    'notif-001',
    'SENT',
    '{"provider": "smtp-gmail-primary", "responseTime": 1200, "recipient": "john.doe@example.com"}',
    CURRENT_TIMESTAMP - INTERVAL '2 days',
    'system'
),
(
    'nlog-002',
    'notif-002',
    'SENT',
    '{"platform": "ANDROID", "deviceId": "device_android_001", "responseTime": 150}',
    CURRENT_TIMESTAMP - INTERVAL '1 day',
    'system'
),
(
    'nlog-003',
    'notif-003',
    'FAILED',
    '{"attempt": 1, "error": "SMTP connection timeout", "provider": "smtp-gmail-primary"}',
    CURRENT_TIMESTAMP - INTERVAL '3 hours',
    'system'
),
(
    'nlog-004',
    'notif-003',
    'RETRY',
    '{"attempt": 2, "provider": "smtp-gmail-secondary", "error": "Invalid email address"}',
    CURRENT_TIMESTAMP - INTERVAL '2 hours',
    'system'
) ON CONFLICT (id) DO NOTHING;

-- Update email providers with realistic usage data
UPDATE email_providers
SET
    current_usage = 150,
    last_used = CURRENT_TIMESTAMP - INTERVAL '2 hours'
WHERE id = 'smtp-gmail-primary';

UPDATE email_providers
SET
    current_usage = 75,
    last_used = CURRENT_TIMESTAMP - INTERVAL '4 hours'
WHERE id = 'smtp-gmail-secondary';

UPDATE email_providers
SET
    current_usage = 1200,
    last_used = CURRENT_TIMESTAMP - INTERVAL '1 hour'
WHERE id = 'smtp-sendgrid';

-- Create sample data views for reporting
CREATE OR REPLACE VIEW notification_stats AS
SELECT
    type,
    status,
    COUNT(*) as count,
    AVG(
        CASE
            WHEN sent_at IS NOT NULL AND created_at IS NOT NULL
            THEN EXTRACT(EPOCH FROM (sent_at - created_at))
            ELSE NULL
        END
    ) as avg_processing_time_seconds
FROM notifications
GROUP BY type, status;

CREATE OR REPLACE VIEW provider_performance AS
SELECT
    ep.name as provider_name,
    COUNT(pul.id) as total_attempts,
    SUM(CASE WHEN pul.success THEN 1 ELSE 0 END) as successful_attempts,
    ROUND(
        SUM(CASE WHEN pul.success THEN 1 ELSE 0 END)::decimal /
        NULLIF(COUNT(pul.id), 0) * 100, 2
    ) as success_rate_percentage,
    AVG(pul.response_time) as avg_response_time_ms,
    MAX(pul.used_at) as last_used
FROM email_providers ep
LEFT JOIN provider_usage_log pul ON ep.id = pul.provider_id
GROUP BY ep.id, ep.name
ORDER BY success_rate_percentage DESC NULLS LAST;

-- Print summary of inserted data
DO $$
BEGIN
    RAISE NOTICE 'Data population completed successfully!';
    RAISE NOTICE 'Inserted:';
    RAISE NOTICE '  - % users', (SELECT COUNT(*) FROM users);
    RAISE NOTICE '  - % notification templates', (SELECT COUNT(*) FROM notification_templates);
    RAISE NOTICE '  - % notifications', (SELECT COUNT(*) FROM notifications);
    RAISE NOTICE '  - % email providers', (SELECT COUNT(*) FROM email_providers);
    RAISE NOTICE '  - % provider usage logs', (SELECT COUNT(*) FROM provider_usage_log);
    RAISE NOTICE '  - % template audit logs', (SELECT COUNT(*) FROM template_audit_log);
END $$;

# Main application configuration for PostgreSQL
spring.datasource.url=jdbc:postgresql://localhost:5432/notifications
spring.datasource.username=postgres
spring.datasource.password=password
spring.jpa.hibernate.ddl-auto=validate
spring.flyway.enabled=true

spring:
  application:
    name: notification-service
  profiles:
    active: dev
  jackson:
    time-zone: UTC
    date-format: com.fasterxml.jackson.databind.util.ISO8601DateFormat
  servlet:
    multipart:
      max-file-size: 10MB
      max-request-size: 10MB

server:
  port: 8080
  servlet:
    context-path: /

logging:
  level:
    com.notificationservice: INFO
    org.springframework: INFO
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n"


spring:
  config:
    activate:
      on-profile: dev

  datasource:
    url: jdbc:h2:mem:devdb;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE
    username: sa
    password: ""
    driver-class-name: org.h2.Driver

  jpa:
    hibernate:
      ddl-auto: create-drop
    show-sql: true
    properties:
      hibernate:
        format_sql: true
        use_sql_comments: true

  h2:
    console:
      enabled: true
      path: /h2-console

  # –û—Ç–∫–ª—é—á–∞–µ–º –≤–Ω–µ—à–Ω–∏–µ —Å–µ—Ä–≤–∏—Å—ã –¥–ª—è dev
  data:
    redis:
      enabled: false
  rabbitmq:
    enabled: false  # –ü–æ–ª–Ω–æ—Å—Ç—å—é –æ—Ç–∫–ª—é—á–∞–µ–º RabbitMQ
    listener:
      type: simple
      simple:
        auto-startup: false  # –û—Ç–∫–ª—é—á–∞–µ–º –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π —Å—Ç–∞—Ä—Ç listeners
  mail:
    host: localhost
    port: 1025
    properties:
      mail:
        smtp:
          auth: false
          starttls:
            enable: false

  flyway:
    enabled: false

# –û—Ç–∫–ª—é—á–∞–µ–º RabbitMQ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é
rabbitmq:
  enabled: false

# Server Configuration
server:
  port: 8080
  servlet:
    context-path: /

# Logging
logging:
  level:
    com.notificationservice: INFO
    org.hibernate.SQL: DEBUG
    org.springframework.amqp: WARN  # –°–Ω–∏–∂–∞–µ–º —É—Ä–æ–≤–µ–Ω—å –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è RabbitMQ
    org.springframework.retry: WARN

# Management Endpoints
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics
      base-path: /manage
  endpoint:
    health:
      show-details: always

# Notification Configuration
notification:
  email:
    test-mode: true
    from: dev@notificationservice.com
  retry:
    max-attempts: 1
  rate-limit:
    requests-per-minute: 10000

# Security Configuration for dev
jwt:
  secret: dev-secret-key-for-development-only-change-in-production

spring:
  config:
    activate:
      on-profile: prod

  datasource:
    url: jdbc:postgresql://${DB_HOST:localhost}:${DB_PORT:5432}/${DB_NAME:notifications}
    username: ${DB_USERNAME:postgres}
    password: ${DB_PASSWORD:password}
    driver-class-name: org.postgresql.Driver

  jpa:
    hibernate:
      ddl-auto: validate
    show-sql: false
    properties:
      hibernate:
        dialect: org.hibernate.dialect.PostgreSQLDialect

  redis:
    host: ${REDIS_HOST:localhost}
    port: ${REDIS_PORT:6379}

  rabbitmq:
    host: ${RABBITMQ_HOST:localhost}
    port: ${RABBITMQ_PORT:5672}
    username: ${RABBITMQ_USERNAME:guest}
    password: ${RABBITMQ_PASSWORD:guest}

  mail:
    host: ${SMTP_HOST:smtp.gmail.com}
    port: ${SMTP_PORT:587}
    username: ${SMTP_USERNAME:}
    password: ${SMTP_PASSWORD:}

  flyway:
    enabled: true
    locations: classpath:db/migration

package com.notificationservice.config;

import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.test.context.TestConfiguration;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.FilterType;
import org.springframework.context.annotation.Import;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.scheduling.annotation.EnableAsync;

@TestConfiguration
@EnableAutoConfiguration
@EnableJpaRepositories(basePackages = "com.notificationservice.repository")
@EnableAsync
@Import({TestSecurityConfig.class, TestConfig.class})
@ComponentScan(
        basePackages = "com.notificationservice",
        excludeFilters = {
                @ComponentScan.Filter(type = FilterType.REGEX, pattern = "com\\.notificationservice\\.config\\.MonitoringConfig"),
                @ComponentScan.Filter(type = FilterType.REGEX, pattern = "com\\.notificationservice\\.config\\.RabbitMQConfig"),
                @ComponentScan.Filter(type = FilterType.REGEX, pattern = "com\\.notificationservice\\.controller\\.HealthController")
        }
)
public class TestApplicationConfig {
    // –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –¥–ª—è —Ç–µ—Å—Ç–æ–≤ - –∏—Å–∫–ª—é—á–∞–µ–º –ø—Ä–æ–±–ª–µ–º–Ω—ã–µ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
}

package com.notificationservice.config;

import com.notificationservice.service.*;
import io.micrometer.core.instrument.MeterRegistry;
import io.micrometer.core.instrument.simple.SimpleMeterRegistry;
import org.mockito.Mockito;
import org.springframework.boot.actuate.health.HealthEndpoint;
import org.springframework.boot.actuate.health.Health;
import org.springframework.boot.test.context.TestConfiguration;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Primary;
import org.springframework.mail.javamail.JavaMailSender;

import java.util.concurrent.TimeUnit;

@TestConfiguration
public class TestConfig {

    @Bean
    @Primary
    public MetricsService metricsService(MeterRegistry meterRegistry) {
        return new MetricsService(meterRegistry);
    }

    @Bean
    @Primary
    public EmailService emailService(JavaMailSender mailSender, MetricsService metricsService) {
        return new EmailService(mailSender, metricsService);
    }

    @Bean
    @Primary
    public PushService pushService(MetricsService metricsService) {
        return new PushService(metricsService);
    }

    @Bean
    @Primary
    public TemplateService templateService() {
        TemplateService mock = Mockito.mock(TemplateService.class);
        Mockito.when(mock.processTemplate(Mockito.anyString(), Mockito.anyMap()))
                .thenReturn("Processed template content");
        return mock;
    }

    @Bean
    @Primary
    public JavaMailSender javaMailSender() {
        return Mockito.mock(JavaMailSender.class);
    }

    @Bean
    @Primary
    public MeterRegistry meterRegistry() {
        return new SimpleMeterRegistry();
    }

    @Bean
    @Primary
    public HealthEndpoint healthEndpoint() {
        HealthEndpoint mock = Mockito.mock(HealthEndpoint.class);
        Health health = Health.up().build();
        Mockito.when(mock.health()).thenReturn(health);
        return mock;
    }
}

package com.notificationservice.config;

import org.springframework.boot.test.context.TestConfiguration;
import org.springframework.context.annotation.Bean;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.SecurityFilterChain;

@TestConfiguration
@EnableWebSecurity
public class TestSecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
                .csrf(csrf -> csrf.disable())
                .authorizeHttpRequests(authz -> authz
                        .requestMatchers("/api/v1/notifications/**").permitAll()
                        .anyRequest().authenticated()
                )
                .sessionManagement(session -> session
                        .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                );
        return http.build();
    }
}

package com.notificationservice.controller;

import com.notificationservice.config.TestSecurityConfig;
import com.notificationservice.dto.EmailRequest;
import com.notificationservice.dto.NotificationResponse;
import com.notificationservice.dto.PushRequest;
import com.notificationservice.entity.Notification;
import com.notificationservice.exception.NotificationNotFoundException;
import com.notificationservice.service.NotificationService;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.context.annotation.Import;
import org.springframework.http.MediaType;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.web.servlet.MockMvc;

import java.time.LocalDateTime;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.*;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@WebMvcTest(NotificationController.class)
@Import(TestSecurityConfig.class)
@ActiveProfiles("test")
class NotificationControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private ObjectMapper objectMapper;

    @MockBean
    private NotificationService notificationService;

    @Test
    void sendEmail_WithValidRequest_ShouldReturnOk() throws Exception {
        // Arrange
        EmailRequest emailRequest = new EmailRequest();
        emailRequest.setTo("test@example.com");
        emailRequest.setSubject("Test Subject");
        emailRequest.setMessage("Test Message");

        NotificationResponse response = NotificationResponse.success(
                "test-id", "EMAIL", "test@example.com", "Test Subject", "Test Message"
        );

        when(notificationService.sendEmail(any(EmailRequest.class))).thenReturn(response);

        // Act & Assert
        mockMvc.perform(post("/api/v1/notifications/email")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(emailRequest)))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.id").value("test-id"))
                .andExpect(jsonPath("$.type").value("EMAIL"))
                .andExpect(jsonPath("$.status").value("SENT"))
                .andExpect(jsonPath("$.recipient").value("test@example.com"))
                .andExpect(jsonPath("$.subject").value("Test Subject"))
                .andExpect(jsonPath("$.message").value("Test Message"))
                .andExpect(jsonPath("$.success").value(true));
    }

    @Test
    void sendPush_WithValidRequest_ShouldReturnOk() throws Exception {
        // Arrange
        PushRequest pushRequest = new PushRequest();
        pushRequest.setUserId("user-123");
        pushRequest.setTitle("Test Title");
        pushRequest.setMessage("Test Message");
        pushRequest.setPlatform("IOS");

        NotificationResponse response = NotificationResponse.success(
                "test-id", "PUSH", "user-123", "Test Title", "Test Message"
        );

        when(notificationService.sendPush(any(PushRequest.class))).thenReturn(response);

        // Act & Assert
        mockMvc.perform(post("/api/v1/notifications/push")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(pushRequest)))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.id").value("test-id"))
                .andExpect(jsonPath("$.type").value("PUSH"))
                .andExpect(jsonPath("$.status").value("SENT"))
                .andExpect(jsonPath("$.recipient").value("user-123"))
                .andExpect(jsonPath("$.subject").value("Test Title"))
                .andExpect(jsonPath("$.message").value("Test Message"))
                .andExpect(jsonPath("$.success").value(true));
    }

    @Test
    void getNotificationStatus_WithExistingId_ShouldReturnOk() throws Exception {
        // Arrange
        String notificationId = "test-id";
        Notification notification = new Notification();
        notification.setId(notificationId);
        notification.setType("EMAIL");
        notification.setStatus("SENT");
        notification.setRecipient("test@example.com");
        notification.setSubject("Test Subject");
        notification.setMessage("Test Message");
        notification.setCreatedAt(LocalDateTime.now());

        when(notificationService.getNotificationStatus(notificationId)).thenReturn(notification);

        // Act & Assert
        mockMvc.perform(get("/api/v1/notifications/{id}", notificationId))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.id").value(notificationId))
                .andExpect(jsonPath("$.type").value("EMAIL"))
                .andExpect(jsonPath("$.status").value("SENT"))
                .andExpect(jsonPath("$.recipient").value("test@example.com"));
    }

    @Test
    void getNotificationStatus_WithNonExistingId_ShouldReturnNotFound() throws Exception {
        // Arrange
        String notificationId = "non-existing-id";
        when(notificationService.getNotificationStatus(notificationId))
                .thenThrow(new NotificationNotFoundException("Notification not found"));

        // Act & Assert
        mockMvc.perform(get("/api/v1/notifications/{id}", notificationId))
                .andExpect(status().isNotFound())
                .andExpect(jsonPath("$.status").value(404))
                .andExpect(jsonPath("$.error").value("Notification Not Found"))
                .andExpect(jsonPath("$.message").value("Notification not found"));
    }

    @Test
    void sendEmail_WithFailedResponse_ShouldReturnOkWithError() throws Exception {
        // Arrange
        EmailRequest request = new EmailRequest();
        request.setTo("test@example.com");
        request.setSubject("Test Subject");
        request.setMessage("Test Message");

        // –ò—Å–ø–æ–ª—å–∑—É–µ–º –º–µ—Ç–æ–¥ failed –≤–º–µ—Å—Ç–æ error
        NotificationResponse response = NotificationResponse.failed(
                "test-id", "EMAIL", "test@example.com", "Test Subject", "SMTP error"
        );

        when(notificationService.sendEmail(any(EmailRequest.class))).thenReturn(response);

        // Act & Assert
        mockMvc.perform(post("/api/v1/notifications/email")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(request)))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.status").value("FAILED"))
                .andExpect(jsonPath("$.success").value(false))
                .andExpect(jsonPath("$.errorMessage").value("SMTP error"));
    }

    @Test
    void sendEmail_WithInvalidRequest_ShouldReturnBadRequest() throws Exception {
        // Arrange
        EmailRequest invalidRequest = new EmailRequest();
        invalidRequest.setTo(""); // Invalid email
        invalidRequest.setSubject(""); // Empty subject
        invalidRequest.setMessage(""); // Empty message

        // Act & Assert
        mockMvc.perform(post("/api/v1/notifications/email")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(invalidRequest)))
                .andExpect(status().isBadRequest());

        verify(notificationService, never()).sendEmail(any());
    }

    @Test
    void sendPush_WithInvalidRequest_ShouldReturnBadRequest() throws Exception {
        // Arrange
        PushRequest invalidRequest = new PushRequest();
        invalidRequest.setUserId(""); // Empty user ID
        invalidRequest.setTitle(""); // Empty title
        invalidRequest.setMessage(""); // Empty message

        // Act & Assert
        mockMvc.perform(post("/api/v1/notifications/push")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(invalidRequest)))
                .andExpect(status().isBadRequest());

        verify(notificationService, never()).sendPush(any());
    }

    @Test
    void whenMultipleRequests_ShouldWorkCorrectly() throws Exception {
        // Arrange
        Notification notification = new Notification();
        notification.setId("test-id-1");
        notification.setStatus("SENT");
        notification.setType("EMAIL");
        notification.setRecipient("test@example.com");
        when(notificationService.getNotificationStatus("test1")).thenReturn(notification);
        when(notificationService.getNotificationStatus("test2")).thenReturn(notification);

        NotificationResponse response = NotificationResponse.success(
                "test-id-2", "EMAIL", "test@example.com", "Test", "Test"
        );
        when(notificationService.sendEmail(any(EmailRequest.class))).thenReturn(response);

        // Multiple requests should work
        mockMvc.perform(get("/api/v1/notifications/{id}", "test1"))
                .andExpect(status().isOk());

        mockMvc.perform(get("/api/v1/notifications/{id}", "test2"))
                .andExpect(status().isOk());

        EmailRequest emailRequest1 = new EmailRequest();
        emailRequest1.setTo("test1@example.com");
        emailRequest1.setSubject("Test1");
        emailRequest1.setMessage("Test1");

        mockMvc.perform(post("/api/v1/notifications/email")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(emailRequest1)))
                .andExpect(status().isOk());

        EmailRequest emailRequest2 = new EmailRequest();
        emailRequest2.setTo("test2@example.com");
        emailRequest2.setSubject("Test2");
        emailRequest2.setMessage("Test2");

        mockMvc.perform(post("/api/v1/notifications/email")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(emailRequest2)))
                .andExpect(status().isOk());
    }

    @Test
    void sendEmail_WithTemplate_ShouldReturnOk() throws Exception {
        // Arrange
        EmailRequest emailRequest = new EmailRequest();
        emailRequest.setTo("test@example.com");
        emailRequest.setSubject("Test Subject");
        emailRequest.setMessage("Test Message");
        emailRequest.setTemplateId("welcome-template");
        emailRequest.setTemplateVariables(java.util.Map.of("name", "John"));

        NotificationResponse response = NotificationResponse.success(
                "test-id", "EMAIL", "test@example.com", "Test Subject", "Test Message"
        );

        when(notificationService.sendEmail(any(EmailRequest.class))).thenReturn(response);

        // Act & Assert
        mockMvc.perform(post("/api/v1/notifications/email")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(emailRequest)))
                .andExpect(status().isOk());
    }

    @Test
    void sendEmail_WithNullRequest_ShouldReturnBadRequest() throws Exception {
        // Act & Assert
        mockMvc.perform(post("/api/v1/notifications/email")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content("null"))
                .andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.status").value(400))
                .andExpect(jsonPath("$.error").value("Invalid Request"))
                .andExpect(jsonPath("$.message").value("Request body is invalid or missing"));
    }

    @Test
    void sendEmail_WithMalformedJson_ShouldReturnBadRequest() throws Exception {
        // Act & Assert
        mockMvc.perform(post("/api/v1/notifications/email")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content("{ invalid json }"))
                .andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.status").value(400))
                .andExpect(jsonPath("$.error").value("Invalid Request"))
                .andExpect(jsonPath("$.message").value("Request body is invalid or missing"));
    }

    @Test
    void sendEmail_WithEmptyBody_ShouldReturnBadRequest() throws Exception {
        // Act & Assert
        mockMvc.perform(post("/api/v1/notifications/email")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(""))
                .andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.status").value(400))
                .andExpect(jsonPath("$.error").value("Invalid Request"))
                .andExpect(jsonPath("$.message").value("Request body is invalid or missing"));
    }

    @Test
    void sendEmail_WithMissingContentType_ShouldReturnUnsupportedMediaType() throws Exception {
        // Act & Assert
        mockMvc.perform(post("/api/v1/notifications/email")
                        .content("{}"))
                .andExpect(status().isUnsupportedMediaType())
                .andExpect(jsonPath("$.status").value(415))
                .andExpect(jsonPath("$.error").value("Unsupported Media Type"))
                .andExpect(jsonPath("$.message").value("Content type is not supported"));
    }
}

package com.notificationservice.exception;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.BindingResult;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.context.request.WebRequest;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class GlobalExceptionHandlerTest {

    @InjectMocks
    private GlobalExceptionHandler exceptionHandler;

    private final WebRequest webRequest = mock(WebRequest.class);

    @Test
    void handleNotificationNotFoundException_ShouldReturnNotFoundResponse() {
        // Arrange
        NotificationNotFoundException exception = new NotificationNotFoundException("Notification 123 not found");
        when(webRequest.getDescription(false)).thenReturn("uri=/api/notifications/123");

        // Act
        ResponseEntity<GlobalExceptionHandler.ErrorResponse> response =
                exceptionHandler.handleNotificationNotFoundException(exception, webRequest);

        // Assert
        assertNotNull(response);
        assertEquals(HttpStatus.NOT_FOUND, response.getStatusCode());

        GlobalExceptionHandler.ErrorResponse errorResponse = response.getBody();
        assertNotNull(errorResponse);
        assertEquals(HttpStatus.NOT_FOUND.value(), errorResponse.getStatus());
        assertEquals("Notification Not Found", errorResponse.getError());
        assertEquals("Notification 123 not found", errorResponse.getMessage());
        assertEquals("/api/notifications/123", errorResponse.getPath());
        assertNotNull(errorResponse.getTimestamp());
    }

    @Test
    void handleNotificationException_ShouldReturnBadRequestResponse() {
        // Arrange
        NotificationException exception = new NotificationException("Invalid notification data");
        when(webRequest.getDescription(false)).thenReturn("uri=/api/notifications/email");

        // Act
        ResponseEntity<GlobalExceptionHandler.ErrorResponse> response =
                exceptionHandler.handleNotificationException(exception, webRequest);

        // Assert
        assertNotNull(response);
        assertEquals(HttpStatus.BAD_REQUEST, response.getStatusCode());

        GlobalExceptionHandler.ErrorResponse errorResponse = response.getBody();
        assertNotNull(errorResponse);
        assertEquals(HttpStatus.BAD_REQUEST.value(), errorResponse.getStatus());
        assertEquals("Notification Error", errorResponse.getError());
        assertEquals("Invalid notification data", errorResponse.getMessage());
    }

    @Test
    void handleTemplateNotFoundException_ShouldReturnNotFoundResponse() {
        // Arrange
        TemplateNotFoundException exception = new TemplateNotFoundException("Template welcome-email not found");
        when(webRequest.getDescription(false)).thenReturn("uri=/api/notifications/email");

        // Act
        ResponseEntity<GlobalExceptionHandler.ErrorResponse> response =
                exceptionHandler.handleTemplateNotFoundException(exception, webRequest);

        // Assert
        assertNotNull(response);
        assertEquals(HttpStatus.NOT_FOUND, response.getStatusCode());

        GlobalExceptionHandler.ErrorResponse errorResponse = response.getBody();
        assertNotNull(errorResponse);
        assertEquals(HttpStatus.NOT_FOUND.value(), errorResponse.getStatus());
        assertEquals("Template Not Found", errorResponse.getError());
        assertEquals("Template welcome-email not found", errorResponse.getMessage());
    }

    @Test
    void handleEmailSendingException_ShouldReturnInternalServerErrorResponse() {
        // Arrange
        EmailSendingException exception = new EmailSendingException("SMTP connection failed");
        when(webRequest.getDescription(false)).thenReturn("uri=/api/notifications/email");

        // Act
        ResponseEntity<GlobalExceptionHandler.ErrorResponse> response =
                exceptionHandler.handleEmailSendingException(exception, webRequest);

        // Assert
        assertNotNull(response);
        assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, response.getStatusCode());

        GlobalExceptionHandler.ErrorResponse errorResponse = response.getBody();
        assertNotNull(errorResponse);
        assertEquals(HttpStatus.INTERNAL_SERVER_ERROR.value(), errorResponse.getStatus());
        assertEquals("Email Sending Failed", errorResponse.getError());
        assertEquals("SMTP connection failed", errorResponse.getMessage());
    }

    @Test
    void handleValidationExceptions_ShouldReturnBadRequestWithDetails() {
        // Arrange
        BindingResult bindingResult = mock(BindingResult.class);
        MethodArgumentNotValidException exception = mock(MethodArgumentNotValidException.class);

        FieldError fieldError1 = new FieldError("emailRequest", "to", "Email is required");
        FieldError fieldError2 = new FieldError("emailRequest", "subject", "Subject cannot be empty");

        when(exception.getBindingResult()).thenReturn(bindingResult);
        when(bindingResult.getFieldErrors()).thenReturn(List.of(fieldError1, fieldError2));
        when(webRequest.getDescription(false)).thenReturn("uri=/api/v1/notifications/email");

        // Act
        ResponseEntity<GlobalExceptionHandler.ErrorResponse> response =
                exceptionHandler.handleValidationExceptions(exception, webRequest);

        // Assert
        assertNotNull(response);
        assertEquals(HttpStatus.BAD_REQUEST, response.getStatusCode());

        GlobalExceptionHandler.ErrorResponse errorResponse = response.getBody();
        assertNotNull(errorResponse);
        assertEquals(HttpStatus.BAD_REQUEST.value(), errorResponse.getStatus());
        assertEquals("Validation Failed", errorResponse.getError());
        assertEquals("Request validation failed", errorResponse.getMessage());

        assertNotNull(errorResponse.getDetails());
        assertEquals(2, errorResponse.getDetails().size());
        assertEquals("Email is required", errorResponse.getDetails().get("to"));
        assertEquals("Subject cannot be empty", errorResponse.getDetails().get("subject"));
    }

    @Test
    void handleHttpMessageNotReadableException_ShouldReturnBadRequest() {
        // Arrange
        org.springframework.http.converter.HttpMessageNotReadableException exception =
                new org.springframework.http.converter.HttpMessageNotReadableException("Invalid JSON");
        when(webRequest.getDescription(false)).thenReturn("uri=/api/v1/notifications/email");

        // Act
        ResponseEntity<GlobalExceptionHandler.ErrorResponse> response =
                exceptionHandler.handleHttpMessageNotReadableException(exception, webRequest);

        // Assert
        assertNotNull(response);
        assertEquals(HttpStatus.BAD_REQUEST, response.getStatusCode());

        GlobalExceptionHandler.ErrorResponse errorResponse = response.getBody();
        assertNotNull(errorResponse);
        assertEquals(HttpStatus.BAD_REQUEST.value(), errorResponse.getStatus());
        assertEquals("Invalid Request", errorResponse.getError());
        assertEquals("Request body is invalid or missing", errorResponse.getMessage());
    }

    @Test
    void handleGlobalException_ShouldReturnInternalServerErrorResponse() {
        // Arrange
        Exception exception = new RuntimeException("Unexpected database error");
        when(webRequest.getDescription(false)).thenReturn("uri=/api/notifications/email");

        // Act
        ResponseEntity<GlobalExceptionHandler.ErrorResponse> response =
                exceptionHandler.handleGlobalException(exception, webRequest);

        // Assert
        assertNotNull(response);
        assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, response.getStatusCode());

        GlobalExceptionHandler.ErrorResponse errorResponse = response.getBody();
        assertNotNull(errorResponse);
        assertEquals(HttpStatus.INTERNAL_SERVER_ERROR.value(), errorResponse.getStatus());
        assertEquals("Internal Server Error", errorResponse.getError());
        assertEquals("An unexpected error occurred", errorResponse.getMessage());
    }

    @Test
    void handleNullPointerException_ShouldReturnInternalServerError() {
        // Arrange
        NullPointerException exception = new NullPointerException("Something was null");
        when(webRequest.getDescription(false)).thenReturn("uri=/api/notifications/push");

        // Act
        ResponseEntity<GlobalExceptionHandler.ErrorResponse> response =
                exceptionHandler.handleGlobalException(exception, webRequest);

        // Assert
        assertNotNull(response);
        assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, response.getStatusCode());

        GlobalExceptionHandler.ErrorResponse errorResponse = response.getBody();
        assertNotNull(errorResponse);
        assertEquals("Internal Server Error", errorResponse.getError());
    }

    @Test
    void handleHttpMediaTypeNotSupportedException_ShouldReturnUnsupportedMediaType() {
        // Arrange
        org.springframework.web.HttpMediaTypeNotSupportedException exception =
                new org.springframework.web.HttpMediaTypeNotSupportedException("Content-Type 'application/octet-stream' is not supported");
        when(webRequest.getDescription(false)).thenReturn("uri=/api/v1/notifications/email");

        // Act
        ResponseEntity<GlobalExceptionHandler.ErrorResponse> response =
                exceptionHandler.handleHttpMediaTypeNotSupportedException(exception, webRequest);

        // Assert
        assertNotNull(response);
        assertEquals(HttpStatus.UNSUPPORTED_MEDIA_TYPE, response.getStatusCode());

        GlobalExceptionHandler.ErrorResponse errorResponse = response.getBody();
        assertNotNull(errorResponse);
        assertEquals(HttpStatus.UNSUPPORTED_MEDIA_TYPE.value(), errorResponse.getStatus());
        assertEquals("Unsupported Media Type", errorResponse.getError());
        assertEquals("Content type is not supported", errorResponse.getMessage());
    }

    @Test
    void errorResponse_ShouldHaveCorrectGettersAndSetters() {
        // Arrange
        LocalDateTime timestamp = LocalDateTime.now();
        Map<String, String> details = Map.of("field", "error message");

        GlobalExceptionHandler.ErrorResponse errorResponse =
                GlobalExceptionHandler.ErrorResponse.builder()
                        .timestamp(timestamp)
                        .status(400)
                        .error("Bad Request")
                        .message("Invalid input")
                        .path("/test")
                        .details(details)
                        .build();

        // Act & Assert
        assertEquals(timestamp, errorResponse.getTimestamp());
        assertEquals(400, errorResponse.getStatus());
        assertEquals("Bad Request", errorResponse.getError());
        assertEquals("Invalid input", errorResponse.getMessage());
        assertEquals("/test", errorResponse.getPath());
        assertEquals(details, errorResponse.getDetails());

        // Test setters
        LocalDateTime newTimestamp = LocalDateTime.now().plusHours(1);
        Map<String, String> newDetails = Map.of("newField", "new error message");

        errorResponse.setTimestamp(newTimestamp);
        errorResponse.setStatus(404);
        errorResponse.setError("Not Found");
        errorResponse.setMessage("Resource not found");
        errorResponse.setPath("/new-path");
        errorResponse.setDetails(newDetails);

        assertEquals(newTimestamp, errorResponse.getTimestamp());
        assertEquals(404, errorResponse.getStatus());
        assertEquals("Not Found", errorResponse.getError());
        assertEquals("Resource not found", errorResponse.getMessage());
        assertEquals("/new-path", errorResponse.getPath());
        assertEquals(newDetails, errorResponse.getDetails());
    }

    @Test
    void errorResponse_NoArgsConstructor_ShouldWork() {
        // Arrange & Act
        GlobalExceptionHandler.ErrorResponse errorResponse = new GlobalExceptionHandler.ErrorResponse();

        // Assert
        assertNotNull(errorResponse);
        assertNull(errorResponse.getTimestamp());
        assertEquals(0, errorResponse.getStatus());
        assertNull(errorResponse.getError());
        assertNull(errorResponse.getMessage());
        assertNull(errorResponse.getPath());
        assertNull(errorResponse.getDetails());
    }

    @Test
    void errorResponse_AllArgsConstructor_ShouldWork() {
        // Arrange
        LocalDateTime timestamp = LocalDateTime.now();
        Map<String, String> details = Map.of("test", "value");

        // Act
        GlobalExceptionHandler.ErrorResponse errorResponse =
                new GlobalExceptionHandler.ErrorResponse(timestamp, 400, "Error", "Message", "/path", details);

        // Assert
        assertNotNull(errorResponse);
        assertEquals(timestamp, errorResponse.getTimestamp());
        assertEquals(400, errorResponse.getStatus());
        assertEquals("Error", errorResponse.getError());
        assertEquals("Message", errorResponse.getMessage());
        assertEquals("/path", errorResponse.getPath());
        assertEquals(details, errorResponse.getDetails());
    }
}

package com.notificationservice.integration;

import com.notificationservice.config.TestApplicationConfig;
import com.notificationservice.dto.EmailRequest;
import com.notificationservice.dto.NotificationResponse;
import com.notificationservice.service.EmailService;
import com.notificationservice.service.NotificationService;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.test.context.ActiveProfiles;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeUnit;

import static org.awaitility.Awaitility.await;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

@SpringBootTest(classes = TestApplicationConfig.class)
@ActiveProfiles("test")
class AsyncNotificationTest {

    @Autowired
    private NotificationService notificationService;

    @MockBean
    private EmailService emailService;

    @Test
    void sendEmail_ShouldCompleteSuccessfully() {
        // Given
        EmailRequest request = createValidEmailRequest();

        // Configure mock for void method
        doNothing().when(emailService).sendEmail(any());

        // When
        NotificationResponse response = notificationService.sendEmail(request);

        // Then
        assertNotNull(response);
        assertNotNull(response.getId());
        assertTrue(response.isSuccess());
        assertEquals("SENT", response.getStatus());
    }

    @Test
    void processHighVolumeNotifications_ShouldHandleMultipleRequests() {
        // Given
        EmailRequest request = createValidEmailRequest();
        doNothing().when(emailService).sendEmail(any());

        // When - –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –Ω–µ—Å–∫–æ–ª—å–∫–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π
        for (int i = 0; i < 3; i++) {
            NotificationResponse response = notificationService.sendEmail(request);
            assertNotNull(response);
            assertTrue(response.isSuccess());
        }

        // Then - –ø—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –≤—Å–µ –≤—ã–∑–æ–≤—ã –æ–±—Ä–∞–±–æ—Ç–∞–Ω—ã
        verify(emailService, times(3)).sendEmail(any());
    }

    @Test
    void sendEmailAsync_ShouldCompleteSuccessfully() {
        // Given
        EmailRequest request = createValidEmailRequest();
        doNothing().when(emailService).sendEmail(any());

        // When
        CompletableFuture<NotificationResponse> future = notificationService.sendEmailAsync(request);

        // Then
        await().atMost(5, TimeUnit.SECONDS).until(future::isDone);
        assertTrue(future.isDone());
        assertFalse(future.isCompletedExceptionally());

        NotificationResponse response = future.join();
        assertNotNull(response);
        assertTrue(response.isSuccess());
        assertEquals("SENT", response.getStatus());
    }

    @Test
    void sendEmail_WhenEmailServiceFails_ShouldReturnFailedResponse() {
        // Given
        EmailRequest request = createValidEmailRequest();
        doThrow(new RuntimeException("SMTP error")).when(emailService).sendEmail(any());

        // When
        NotificationResponse response = notificationService.sendEmail(request);

        // Then
        assertNotNull(response);
        assertFalse(response.isSuccess());
        assertNotNull(response.getErrorMessage());
        assertEquals("FAILED", response.getStatus());
    }

    private EmailRequest createValidEmailRequest() {
        EmailRequest request = new EmailRequest();
        request.setTo("test@example.com");
        request.setSubject("Test Subject");
        request.setMessage("Test message");
        return request;
    }
}

package com.notificationservice.integration;

import com.notificationservice.config.TestSecurityConfig;
import com.notificationservice.controller.NotificationController;
import com.notificationservice.dto.EmailRequest;
import com.notificationservice.exception.NotificationNotFoundException;
import com.notificationservice.service.NotificationService;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.context.annotation.Import;
import org.springframework.http.MediaType;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.web.servlet.MockMvc;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@WebMvcTest(NotificationController.class)
@Import(TestSecurityConfig.class)
@ActiveProfiles("test")
class GlobalExceptionHandlerIntegrationTest {

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private ObjectMapper objectMapper;

    @MockBean
    private NotificationService notificationService;

    @Test
    void whenNotificationNotFound_ShouldReturnNotFoundResponse() throws Exception {
        // Arrange
        String notificationId = "non-existent-id";
        when(notificationService.getNotificationStatus(notificationId))
                .thenThrow(new NotificationNotFoundException("Notification not found with id: " + notificationId));

        // Act & Assert
        mockMvc.perform(get("/api/v1/notifications/{id}", notificationId))
                .andExpect(status().isNotFound())
                .andExpect(jsonPath("$.status").value(404))
                .andExpect(jsonPath("$.error").value("Notification Not Found"))
                .andExpect(jsonPath("$.message").value("Notification not found with id: " + notificationId))
                .andExpect(jsonPath("$.timestamp").exists());
    }

    @Test
    void whenInvalidEmailRequest_ShouldReturnValidationError() throws Exception {
        // Arrange
        EmailRequest invalidRequest = new EmailRequest();
        invalidRequest.setTo("invalid-email"); // Invalid email format
        invalidRequest.setSubject(""); // Empty subject
        invalidRequest.setMessage(""); // Empty message

        // Act & Assert
        mockMvc.perform(post("/api/v1/notifications/email")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(invalidRequest)))
                .andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.status").value(400))
                .andExpect(jsonPath("$.error").value("Validation Failed"))
                .andExpect(jsonPath("$.details").exists());
    }

    @Test
    void whenServiceThrowsRuntimeException_ShouldReturnInternalServerError() throws Exception {
        // Arrange
        when(notificationService.sendEmail(any(EmailRequest.class)))
                .thenThrow(new RuntimeException("Unexpected service error"));

        EmailRequest validRequest = new EmailRequest();
        validRequest.setTo("test@example.com");
        validRequest.setSubject("Test Subject");
        validRequest.setMessage("Test Message");

        // Act & Assert
        mockMvc.perform(post("/api/v1/notifications/email")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(validRequest)))
                .andExpect(status().isInternalServerError())
                .andExpect(jsonPath("$.status").value(500))
                .andExpect(jsonPath("$.error").value("Internal Server Error"))
                .andExpect(jsonPath("$.message").value("An unexpected error occurred"));
    }

    @Test
    void whenInvalidJsonInRequest_ShouldReturnBadRequest() throws Exception {
        // Act & Assert
        mockMvc.perform(post("/api/v1/notifications/email")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content("{ invalid json }"))
                .andExpect(status().isBadRequest());
    }

    @Test
    void whenEmailSendingFails_ShouldReturnInternalServerError() throws Exception {
        // Arrange
        EmailRequest request = new EmailRequest();
        request.setTo("test@example.com");
        request.setSubject("Test Subject");
        request.setMessage("Test Message");

        when(notificationService.sendEmail(any(EmailRequest.class)))
                .thenThrow(new com.notificationservice.exception.EmailSendingException("SMTP server unavailable"));

        // Act & Assert
        mockMvc.perform(post("/api/v1/notifications/email")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(request)))
                .andExpect(status().isInternalServerError())
                .andExpect(jsonPath("$.status").value(500))
                .andExpect(jsonPath("$.error").value("Email Sending Failed"))
                .andExpect(jsonPath("$.message").value("SMTP server unavailable"));
    }

    @Test
    void whenTemplateNotFound_ShouldReturnNotFound() throws Exception {
        // Arrange
        EmailRequest request = new EmailRequest();
        request.setTo("test@example.com");
        request.setSubject("Test Subject");
        request.setMessage("Test Message");
        request.setTemplateId("non-existent-template");

        when(notificationService.sendEmail(any(EmailRequest.class)))
                .thenThrow(new com.notificationservice.exception.TemplateNotFoundException("Template not found: non-existent-template"));

        // Act & Assert
        mockMvc.perform(post("/api/v1/notifications/email")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(request)))
                .andExpect(status().isNotFound())
                .andExpect(jsonPath("$.status").value(404))
                .andExpect(jsonPath("$.error").value("Template Not Found"))
                .andExpect(jsonPath("$.message").value("Template not found: non-existent-template"));
    }
}

package com.notificationservice.integration;

import com.notificationservice.NotificationServiceApplication;
import com.notificationservice.dto.EmailRequest;
import com.notificationservice.dto.NotificationResponse;
import com.notificationservice.entity.Notification;
import com.notificationservice.repository.NotificationRepository;
import com.notificationservice.service.EmailService;
import com.notificationservice.service.NotificationService;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.transaction.annotation.Transactional;

import java.util.Optional;
import java.util.concurrent.CompletableFuture;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

@SpringBootTest(classes = NotificationServiceApplication.class)
@ActiveProfiles("test")
@Transactional
class NotificationIntegrationTest {

    @Autowired
    private NotificationService notificationService;

    @Autowired
    private NotificationRepository notificationRepository;

    @MockBean
    private EmailService emailService;

    @Test
    void completeEmailFlow_ShouldWorkCorrectly() {
        // Given
        EmailRequest request = new EmailRequest();
        request.setTo("integration@example.com");
        request.setSubject("Integration Test");
        request.setMessage("Integration test message");

        doNothing().when(emailService).sendEmail(any(Notification.class));

        // When
        NotificationResponse response = notificationService.sendEmail(request);

        // Then
        assertNotNull(response);
        assertNotNull(response.getId());

        // Verify notification was saved in database
        Optional<Notification> saved = notificationRepository.findById(response.getId());
        assertTrue(saved.isPresent());
        assertEquals("integration@example.com", saved.get().getRecipient());
        assertEquals("Integration Test", saved.get().getSubject());
    }

    @Test
    void asyncEmailProcessing_ShouldComplete() throws Exception {
        // Given
        EmailRequest request = new EmailRequest();
        request.setTo("async@example.com");
        request.setSubject("Async Test");
        request.setMessage("Async test message");

        doNothing().when(emailService).sendEmail(any(Notification.class));

        // When
        CompletableFuture<NotificationResponse> future = notificationService.sendEmailAsync(request);
        NotificationResponse response = future.get(); // Wait for completion

        // Then
        assertNotNull(response);
        assertNotNull(response.getId());
        assertEquals("SENT", response.getStatus());
    }

    @Test
    void multipleNotifications_ShouldBeProcessedIndependently() {
        // Given
        EmailRequest request1 = new EmailRequest();
        request1.setTo("test1@example.com");
        request1.setSubject("Test 1");
        request1.setMessage("Message 1");

        EmailRequest request2 = new EmailRequest();
        request2.setTo("test2@example.com");
        request2.setSubject("Test 2");
        request2.setMessage("Message 2");

        doNothing().when(emailService).sendEmail(any(Notification.class));

        // When
        NotificationResponse response1 = notificationService.sendEmail(request1);
        NotificationResponse response2 = notificationService.sendEmail(request2);

        // Then
        assertNotNull(response1.getId());
        assertNotNull(response2.getId());
        assertNotEquals(response1.getId(), response2.getId());

        // Verify both are in database
        assertTrue(notificationRepository.findById(response1.getId()).isPresent());
        assertTrue(notificationRepository.findById(response2.getId()).isPresent());
    }
}

package com.notificationservice.integration;

import com.notificationservice.config.TestApplicationConfig;
import com.notificationservice.dto.EmailRequest;
import com.notificationservice.dto.NotificationResponse;
import com.notificationservice.exception.NotificationNotFoundException;
import com.notificationservice.repository.NotificationRepository;
import com.notificationservice.service.EmailService;
import com.notificationservice.service.NotificationService;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.test.context.ActiveProfiles;

import java.util.Optional;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

@SpringBootTest(classes = TestApplicationConfig.class)
@ActiveProfiles("test")
class NotificationServiceExceptionTest {

    @Autowired
    private NotificationService notificationService;

    @MockBean
    private NotificationRepository notificationRepository;

    @MockBean
    private EmailService emailService;

    @Test
    void getNotificationStatus_WhenNotFound_ShouldThrowException() {
        // Given
        String nonExistentId = UUID.randomUUID().toString();
        when(notificationRepository.findById(nonExistentId)).thenReturn(Optional.empty());

        // When & Then
        assertThrows(NotificationNotFoundException.class, () -> {
            notificationService.getNotificationStatus(nonExistentId);
        });
    }

    @Test
    void sendEmail_WhenEmailServiceFails_ShouldHandleGracefully() {
        // Given
        EmailRequest request = new EmailRequest();
        request.setTo("test@example.com");
        request.setSubject("Test Subject");
        request.setMessage("Test Message");

        // –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –º–æ–∫ –¥–ª—è –≤—ã–±—Ä–æ—Å–∞ –∏—Å–∫–ª—é—á–µ–Ω–∏—è
        doThrow(new RuntimeException("SMTP error")).when(emailService).sendEmail(any());

        // When
        NotificationResponse response = notificationService.sendEmail(request);

        // Then - —Å–µ—Ä–≤–∏—Å –¥–æ–ª–∂–µ–Ω –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –æ—à–∏–±–∫—É –∏ –≤–µ—Ä–Ω—É—Ç—å –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –æ—Ç–≤–µ—Ç
        assertNotNull(response);
        assertFalse(response.isSuccess());
        assertNotNull(response.getErrorMessage());
    }
}

package com.notificationservice.integration;

import com.notificationservice.NotificationServiceApplication;
import com.notificationservice.dto.EmailRequest;
import com.notificationservice.dto.NotificationResponse;
import com.notificationservice.entity.Notification;
import com.notificationservice.repository.NotificationRepository;
import com.notificationservice.service.EmailService;
import com.notificationservice.service.NotificationService;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.mock.mockito.SpyBean;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Optional;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

@SpringBootTest(classes = NotificationServiceApplication.class)
@ActiveProfiles("test")
@Transactional
class NotificationServiceIT {

    @Autowired
    private NotificationService notificationService;

    @Autowired
    private NotificationRepository notificationRepository;

    @SpyBean
    private EmailService emailService;

    @BeforeEach
    void setUp() {
        notificationRepository.deleteAll();
    }

    @Test
    void sendEmail_WithRealDatabase_ShouldPersistData() {
        // Given
        EmailRequest request = new EmailRequest();
        request.setTo("test@example.com");
        request.setSubject("Test Subject");
        request.setMessage("Test message content");

        // When
        NotificationResponse response = notificationService.sendEmail(request);

        // Then
        assertNotNull(response);
        assertNotNull(response.getId());
        assertTrue(response.isSuccess());

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ —Å–æ—Ö—Ä–∞–Ω–∏–ª–æ—Å—å –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö
        Optional<Notification> savedNotification = notificationRepository.findById(response.getId());
        assertTrue(savedNotification.isPresent());

        Notification notification = savedNotification.get();
        assertEquals("test@example.com", notification.getRecipient());
        assertEquals("Test Subject", notification.getSubject());
        assertEquals("EMAIL", notification.getType());
        assertEquals("SENT", notification.getStatus()); // –°—Ç–∞—Ç—É—Å –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å SENT –ø–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–π –æ—Ç–ø—Ä–∞–≤–∫–∏
        assertNotNull(notification.getSentAt());

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ emailService –±—ã–ª –≤—ã–∑–≤–∞–Ω
        verify(emailService, times(1)).sendEmail(any(Notification.class));
    }

    @Test
    void sendEmail_WithInvalidRequest_ShouldReturnError() {
        // Given
        EmailRequest request = new EmailRequest();
        request.setTo(""); // –ù–µ–≤–∞–ª–∏–¥–Ω—ã–π email
        request.setSubject("Test Subject");
        request.setMessage("Test message");

        // When
        NotificationResponse response = notificationService.sendEmail(request);

        // Then
        assertNotNull(response);
        assertFalse(response.isSuccess());
        assertNotNull(response.getErrorMessage());

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∑–∞–ø–∏—Å—å –≤ –ë–î –Ω–µ —Å–æ–∑–¥–∞–≤–∞–ª–∞—Å—å
        assertEquals(0, notificationRepository.count());

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ emailService –ù–ï –±—ã–ª –≤—ã–∑–≤–∞–Ω
        verify(emailService, never()).sendEmail(any(Notification.class));
    }

    @Test
    void sendEmail_WithTemplate_ShouldPersistData() {
        // Given
        EmailRequest request = new EmailRequest();
        request.setTo("template@example.com");
        request.setSubject("Template Test");
        request.setMessage("Fallback message");
        request.setTemplateId("welcome-template");

        // When
        NotificationResponse response = notificationService.sendEmail(request);

        // Then
        assertNotNull(response);
        assertNotNull(response.getId());
        assertTrue(response.isSuccess());

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –≤ –ë–î
        Optional<Notification> savedNotification = notificationRepository.findById(response.getId());
        assertTrue(savedNotification.isPresent());

        Notification notification = savedNotification.get();
        assertEquals("template@example.com", notification.getRecipient());
        assertEquals("EMAIL", notification.getType());
        assertEquals("SENT", notification.getStatus());
        assertEquals("welcome-template", notification.getTemplateId());

        verify(emailService, times(1)).sendEmail(any(Notification.class));
    }

    @Test
    void sendEmail_WhenEmailServiceFails_ShouldUpdateStatusToFailed() {
        // Given
        EmailRequest request = new EmailRequest();
        request.setTo("test@example.com");
        request.setSubject("Test Subject");
        request.setMessage("Test message");

        // –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –º–æ–∫ –¥–ª—è –≤—ã–±—Ä–∞—Å—ã–≤–∞–Ω–∏—è –∏—Å–∫–ª—é—á–µ–Ω–∏—è
        doThrow(new RuntimeException("SMTP error"))
                .when(emailService).sendEmail(any(Notification.class));

        // When
        NotificationResponse response = notificationService.sendEmail(request);

        // Then
        assertNotNull(response);
        assertFalse(response.isSuccess());
        assertNotNull(response.getErrorMessage());

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ —Å–æ—Ö—Ä–∞–Ω–∏–ª–æ—Å—å —Å —Å—Ç–∞—Ç—É—Å–æ–º FAILED
        Optional<Notification> savedNotification = notificationRepository.findById(response.getId());
        assertTrue(savedNotification.isPresent());

        Notification notification = savedNotification.get();
        assertEquals("FAILED", notification.getStatus());
        assertNotNull(notification.getErrorMessage());
        assertEquals("test@example.com", notification.getRecipient());
    }

    @Test
    void sendEmail_WithValidRequest_ShouldGenerateUniqueId() {
        // Given
        EmailRequest request1 = new EmailRequest();
        request1.setTo("test1@example.com");
        request1.setSubject("Test 1");
        request1.setMessage("Message 1");

        EmailRequest request2 = new EmailRequest();
        request2.setTo("test2@example.com");
        request2.setSubject("Test 2");
        request2.setMessage("Message 2");

        // When
        NotificationResponse response1 = notificationService.sendEmail(request1);
        NotificationResponse response2 = notificationService.sendEmail(request2);

        // Then
        assertNotNull(response1.getId());
        assertNotNull(response2.getId());
        assertNotEquals(response1.getId(), response2.getId());

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –æ–±–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è —Å–æ—Ö—Ä–∞–Ω–∏–ª–∏—Å—å
        List<Notification> allNotifications = notificationRepository.findAll();
        assertEquals(2, allNotifications.size());

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –æ–±–∞ –∏–º–µ—é—Ç —Å—Ç–∞—Ç—É—Å SENT
        assertEquals(2, allNotifications.stream()
                .filter(n -> "SENT".equals(n.getStatus()))
                .count());

        verify(emailService, times(2)).sendEmail(any(Notification.class));
    }
}

package com.notificationservice.repository;

import com.notificationservice.entity.Notification;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

@DataJpaTest
@ActiveProfiles("test")
@Transactional
class NotificationRepositoryTest {

    @Autowired
    private NotificationRepository notificationRepository;

    @BeforeEach
    void setUp() {
        notificationRepository.deleteAll();
    }

    @Test
    void findByStatusAndCreatedAtBefore_ShouldRespectStatus() {
        // Given
        Notification pendingNotification = createNotification("pending@example.com", "Pending Subject", "Pending message");
        Notification sentNotification = createNotification("sent@example.com", "Sent Subject", "Sent message");
        sentNotification.setStatus("SENT");
        notificationRepository.save(sentNotification);

        // When - –∏—â–µ–º —Ç–æ–ª—å–∫–æ PENDING —Å –≤—Ä–µ–º–µ–Ω–µ–º –≤ –±—É–¥—É—â–µ–º (—á—Ç–æ–±—ã –Ω–∞–π—Ç–∏ –≤—Å–µ)
        List<Notification> result = notificationRepository.findByStatusAndCreatedAtBefore("PENDING", LocalDateTime.now().plusHours(1));

        // Then - –ø—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –Ω–∞—à–ª–∏ —Ç–æ–ª—å–∫–æ PENDING –∑–∞–ø–∏—Å—å
        assertEquals(1, result.size(), "Should find only PENDING notifications");
        assertEquals(pendingNotification.getId(), result.get(0).getId());
        assertEquals("PENDING", result.get(0).getStatus());
        assertEquals("pending@example.com", result.get(0).getRecipient());
    }

    @Test
    void findByStatusAndCreatedAtBefore_ShouldFindAllWhenTimeIsInFuture() {
        // Given
        createNotification("test1@example.com", "Test 1", "Message 1");
        createNotification("test2@example.com", "Test 2", "Message 2");

        // When - –∏—â–µ–º –¥–æ –≤—Ä–µ–º–µ–Ω–∏ –≤ –±—É–¥—É—â–µ–º
        List<Notification> result = notificationRepository.findByStatusAndCreatedAtBefore("PENDING", LocalDateTime.now().plusHours(1));

        // Then - –¥–æ–ª–∂–Ω–æ –Ω–∞–π—Ç–∏ –≤—Å–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
        assertEquals(2, result.size(), "Should find all notifications when searching in the future");
    }

    @Test
    void findByStatusAndCreatedAtBefore_ShouldReturnEmptyForWrongStatus() {
        // Given
        createNotification("test@example.com", "Test Subject", "Test message");

        // When - –∏—â–µ–º —Å –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–º —Å—Ç–∞—Ç—É—Å–æ–º
        List<Notification> result = notificationRepository.findByStatusAndCreatedAtBefore("SENT", LocalDateTime.now().plusHours(1));

        // Then - –Ω–µ –¥–æ–ª–∂–Ω–æ –Ω–∞–π—Ç–∏
        assertEquals(0, result.size(), "Should not find notifications with wrong status");
    }

    @Test
    void findByStatusAndCreatedAtBefore_ShouldReturnEmptyForPastTime() {
        // Given
        createNotification("test@example.com", "Test Subject", "Test message");

        // When - –∏—â–µ–º –¥–æ –≤—Ä–µ–º–µ–Ω–∏ –≤ –ø—Ä–æ—à–ª–æ–º
        List<Notification> result = notificationRepository.findByStatusAndCreatedAtBefore("PENDING", LocalDateTime.now().minusHours(1));

        // Then - –Ω–µ –¥–æ–ª–∂–Ω–æ –Ω–∞–π—Ç–∏ (–≤—Å–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è —Å–æ–∑–¥–∞–Ω—ã —Å–µ–π—á–∞—Å)
        assertEquals(0, result.size(), "Should not find notifications when searching in the past");
    }

    @Test
    void findByStatus_ShouldReturnCorrectNotifications() {
        // Given
        createNotification("test1@example.com", "Test 1", "Message 1");

        Notification pending2 = createNotification("user123", "Push Title", "Push message");
        pending2.setType("PUSH");
        notificationRepository.save(pending2);

        Notification sent = createNotification("test2@example.com", "Test 2", "Message 2");
        sent.setStatus("SENT");
        notificationRepository.save(sent);

        // When
        List<Notification> pendingResults = notificationRepository.findByStatus("PENDING");
        List<Notification> sentResults = notificationRepository.findByStatus("SENT");

        // Then
        assertEquals(2, pendingResults.size(), "Should find 2 PENDING notifications");
        assertEquals(1, sentResults.size(), "Should find 1 SENT notification");
        assertEquals("SENT", sentResults.get(0).getStatus());
    }

    @Test
    void saveNotification_ShouldGenerateIdAutomatically() {
        // Given
        Notification notification = createNotification("test@example.com", "Test Subject", "Test Message");

        // When
        Notification saved = notificationRepository.save(notification);

        // Then
        assertNotNull(saved.getId(), "ID should be generated automatically");
        assertFalse(saved.getId().isEmpty());
        assertEquals("EMAIL", saved.getType());
        assertEquals("PENDING", saved.getStatus());
        assertEquals("test@example.com", saved.getRecipient());
        assertNotNull(saved.getCreatedAt(), "CreatedAt should be set automatically");
    }

    @Test
    void findByRecipient_ShouldReturnCorrectNotifications() {
        // Given
        String recipient = "test@example.com";
        createNotification(recipient, "Subject 1", "Message 1");
        createNotification(recipient, "Subject 2", "Message 2");
        createNotification("other@example.com", "Other Subject", "Other message");

        // When
        List<Notification> result = notificationRepository.findByRecipient(recipient);

        // Then
        assertEquals(2, result.size(), "Should find 2 notifications for the recipient");
        assertTrue(result.stream().allMatch(n -> recipient.equals(n.getRecipient())));
    }

    @Test
    void findByType_ShouldReturnCorrectNotifications() {
        // Given
        createNotification("test1@example.com", "Email 1", "Message 1");
        createNotification("test2@example.com", "Email 2", "Message 2");

        Notification pushNotification = createNotification("user123", "Push", "Push message");
        pushNotification.setType("PUSH");
        notificationRepository.save(pushNotification);

        // When
        List<Notification> emailResults = notificationRepository.findByType("EMAIL");
        List<Notification> pushResults = notificationRepository.findByType("PUSH");

        // Then
        assertEquals(2, emailResults.size(), "Should find 2 EMAIL notifications");
        assertEquals(1, pushResults.size(), "Should find 1 PUSH notification");
        assertEquals("PUSH", pushResults.get(0).getType());
    }

    @Test
    void countByStatus_ShouldReturnCorrectCount() {
        // Given
        createNotification("test1@example.com", "Test 1", "Message 1");
        createNotification("test2@example.com", "Test 2", "Message 2");

        Notification sent = createNotification("test3@example.com", "Test 3", "Message 3");
        sent.setStatus("SENT");
        notificationRepository.save(sent);

        // When
        long pendingCount = notificationRepository.countByStatus("PENDING");
        long sentCount = notificationRepository.countByStatus("SENT");

        // Then
        assertEquals(2, pendingCount, "Should count 2 PENDING notifications");
        assertEquals(1, sentCount, "Should count 1 SENT notification");
    }

    @Test
    void findByStatusAndRetryCountLessThan_ShouldReturnCorrectNotifications() {
        // Given
        Notification lowRetry = createNotification("low@example.com", "Low Retry", "Message");
        lowRetry.setRetryCount(2);
        notificationRepository.save(lowRetry);

        Notification highRetry = createNotification("high@example.com", "High Retry", "Message");
        highRetry.setRetryCount(5);
        notificationRepository.save(highRetry);

        // When
        List<Notification> result = notificationRepository.findByStatusAndRetryCountLessThan("PENDING", 3);

        // Then
        assertEquals(1, result.size(), "Should find only notification with retry count less than 3");
        assertEquals("low@example.com", result.get(0).getRecipient());
    }

    @Test
    void findByCreatedAtBetween_ShouldReturnAllForWideRange() {
        // Given
        createNotification("test1@example.com", "Test 1", "Message 1");
        createNotification("test2@example.com", "Test 2", "Message 2");

        // When - –∏—â–µ–º –≤ –æ—á–µ–Ω—å —à–∏—Ä–æ–∫–æ–º –¥–∏–∞–ø–∞–∑–æ–Ω–µ
        LocalDateTime startTime = LocalDateTime.now().minusDays(1);
        LocalDateTime endTime = LocalDateTime.now().plusDays(1);
        List<Notification> result = notificationRepository.findByCreatedAtBetween(startTime, endTime);

        // Then - –¥–æ–ª–∂–Ω–æ –Ω–∞–π—Ç–∏ –≤—Å–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
        assertEquals(2, result.size(), "Should find all notifications in wide time range");
    }

    @Test
    void findByCreatedAtBetween_ShouldReturnEmptyForFutureRange() {
        // Given
        createNotification("test@example.com", "Test", "Message");

        // When - –∏—â–µ–º –≤ –±—É–¥—É—â–µ–º –¥–∏–∞–ø–∞–∑–æ–Ω–µ
        LocalDateTime startTime = LocalDateTime.now().plusHours(1);
        LocalDateTime endTime = LocalDateTime.now().plusHours(2);
        List<Notification> result = notificationRepository.findByCreatedAtBetween(startTime, endTime);

        // Then - –Ω–µ –¥–æ–ª–∂–Ω–æ –Ω–∞–π—Ç–∏
        assertEquals(0, result.size(), "Should not find notifications in future time range");
    }

    @Test
    void findByCreatedAtBetween_ShouldReturnEmptyForPastRange() {
        // Given
        createNotification("test@example.com", "Test", "Message");

        // When - –∏—â–µ–º –≤ –ø—Ä–æ—à–ª–æ–º –¥–∏–∞–ø–∞–∑–æ–Ω–µ
        LocalDateTime startTime = LocalDateTime.now().minusHours(2);
        LocalDateTime endTime = LocalDateTime.now().minusHours(1);
        List<Notification> result = notificationRepository.findByCreatedAtBetween(startTime, endTime);

        // Then - –Ω–µ –¥–æ–ª–∂–Ω–æ –Ω–∞–π—Ç–∏
        assertEquals(0, result.size(), "Should not find notifications in past time range");
    }

    // –¢–µ—Å—Ç–∏—Ä—É–µ–º —Å–ª–æ–∂–Ω—ã–µ –∑–∞–ø—Ä–æ—Å—ã –∞–Ω–∞–ª–∏—Ç–∏–∫–∏
    @Test
    void findAverageProcessingTime_ShouldReturnNullWhenNoData() {
        // When
        Double result = notificationRepository.findAverageProcessingTime();

        // Then
        assertNull(result, "Should return null when no processing time data");
    }

    @Test
    void findAverageProcessingTime_ShouldCalculateAverage() {
        // Given
        Notification notification1 = createNotification("test1@example.com", "Test 1", "Message 1");
        notification1.setProcessingTime(100L);
        notificationRepository.save(notification1);

        Notification notification2 = createNotification("test2@example.com", "Test 2", "Message 2");
        notification2.setProcessingTime(200L);
        notificationRepository.save(notification2);

        // When
        Double result = notificationRepository.findAverageProcessingTime();

        // Then
        assertNotNull(result, "Should calculate average processing time");
        assertEquals(150.0, result, 0.01, "Average should be 150");
    }

    @Test
    void countByType_ShouldReturnCorrectCounts() {
        // Given
        createNotification("test1@example.com", "Email 1", "Message 1");
        createNotification("test2@example.com", "Email 2", "Message 2");

        Notification push = createNotification("user1", "Push 1", "Message");
        push.setType("PUSH");
        notificationRepository.save(push);

        // When
        List<Object[]> result = notificationRepository.countByType();

        // Then
        assertEquals(2, result.size(), "Should return counts for 2 types");

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –µ—Å—Ç—å –æ–±–∞ —Ç–∏–ø–∞
        boolean hasEmail = result.stream().anyMatch(arr -> "EMAIL".equals(arr[0]) && 2L == (Long) arr[1]);
        boolean hasPush = result.stream().anyMatch(arr -> "PUSH".equals(arr[0]) && 1L == (Long) arr[1]);

        assertTrue(hasEmail, "Should have EMAIL type with count 2");
        assertTrue(hasPush, "Should have PUSH type with count 1");
    }

    // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–π –º–µ—Ç–æ–¥ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
    private Notification createNotification(String recipient, String subject, String message) {
        Notification notification = new Notification();
        notification.setType("EMAIL");
        notification.setStatus("PENDING");
        notification.setRecipient(recipient);
        notification.setSubject(subject);
        notification.setMessage(message);
        return notificationRepository.save(notification);
    }
}

package com.notificationservice.security;

import com.notificationservice.config.TestSecurityConfig;
import com.notificationservice.controller.NotificationController;
import com.notificationservice.dto.NotificationResponse;
import com.notificationservice.entity.Notification;
import com.notificationservice.service.NotificationService;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.context.annotation.Import;
import org.springframework.http.MediaType;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.web.servlet.MockMvc;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.when;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@WebMvcTest(NotificationController.class)
@ActiveProfiles("test")
@Import(TestSecurityConfig.class)
class SecurityTest {

    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private NotificationService notificationService;

    @Test
    void whenAccessProtectedEndpoints_ShouldBeAllowed() throws Exception {
        // Mock the service response
        Notification notification = new Notification();
        notification.setId("test-id");
        notification.setStatus("SENT");
        when(notificationService.getNotificationStatus(anyString())).thenReturn(notification);

        NotificationResponse emailResponse = NotificationResponse.success(
                "test-id", "EMAIL", "test@example.com", "Test Subject", "Test message"
        );
        when(notificationService.sendEmail(any())).thenReturn(emailResponse);

        NotificationResponse pushResponse = NotificationResponse.success(
                "test-id", "PUSH", "user123", "Test Title", "Test push message"
        );
        when(notificationService.sendPush(any())).thenReturn(pushResponse);

        // Test all endpoints - –æ–Ω–∏ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –¥–æ—Å—Ç—É–ø–Ω—ã –±–ª–∞–≥–æ–¥–∞—Ä—è TestSecurityConfig
        mockMvc.perform(get("/api/v1/notifications/{id}", "test-id"))
                .andExpect(status().isOk());

        mockMvc.perform(post("/api/v1/notifications/email")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content("""
                    {
                        "to": "test@example.com",
                        "subject": "Test Subject",
                        "message": "Test message content",
                        "priority": "NORMAL"
                    }
                    """))
                .andExpect(status().isOk());

        mockMvc.perform(post("/api/v1/notifications/push")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content("""
                    {
                        "userId": "user123",
                        "title": "Test Title",
                        "message": "Test push message",
                        "platform": "IOS",
                        "priority": "NORMAL"
                    }
                    """))
                .andExpect(status().isOk());
    }

    @Test
    void whenValidRequests_ShouldReturnOk() throws Exception {
        // Mock successful responses
        NotificationResponse emailResponse = NotificationResponse.success(
                "email-id", "EMAIL", "test@example.com", "Test", "Test"
        );
        when(notificationService.sendEmail(any())).thenReturn(emailResponse);

        NotificationResponse pushResponse = NotificationResponse.success(
                "push-id", "PUSH", "user123", "Test", "Test"
        );
        when(notificationService.sendPush(any())).thenReturn(pushResponse);

        // Valid email request
        mockMvc.perform(post("/api/v1/notifications/email")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content("""
                    {
                        "to": "test@example.com",
                        "subject": "Test Subject",
                        "message": "Test Message",
                        "priority": "NORMAL"
                    }
                    """))
                .andExpect(status().isOk());

        // Valid push request
        mockMvc.perform(post("/api/v1/notifications/push")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content("""
                    {
                        "userId": "user123",
                        "title": "Test Title",
                        "message": "Test Message",
                        "platform": "ANDROID",
                        "priority": "NORMAL"
                    }
                    """))
                .andExpect(status().isOk());
    }

    // –£–ë–ò–†–ê–ï–ú —Ç–µ—Å—Ç Swagger —Ç–∞–∫ –∫–∞–∫ –æ–Ω –º–æ–∂–µ—Ç –Ω–µ –±—ã—Ç—å –Ω–∞—Å—Ç—Ä–æ–µ–Ω –≤ —Ç–µ—Å—Ç–æ–≤–æ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç–µ
    // –í–º–µ—Å—Ç–æ —ç—Ç–æ–≥–æ —Ç–µ—Å—Ç–∏—Ä—É–µ–º —Ç–æ–ª—å–∫–æ –±–∏–∑–Ω–µ—Å-–ª–æ–≥–∏–∫—É

    @Test
    void whenMultipleRequests_ShouldWorkCorrectly() throws Exception {
        // Mock responses
        Notification notification = new Notification();
        notification.setId("test-id-1");
        notification.setStatus("SENT");
        when(notificationService.getNotificationStatus(anyString())).thenReturn(notification);

        NotificationResponse response = NotificationResponse.success(
                "test-id-2", "EMAIL", "test@example.com", "Test", "Test"
        );
        when(notificationService.sendEmail(any())).thenReturn(response);
        when(notificationService.sendPush(any())).thenReturn(response);

        // Multiple requests should work
        mockMvc.perform(get("/api/v1/notifications/test1"))
                .andExpect(status().isOk());

        mockMvc.perform(get("/api/v1/notifications/test2"))
                .andExpect(status().isOk());

        mockMvc.perform(post("/api/v1/notifications/email")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content("""
                    {
                        "to": "test1@example.com",
                        "subject": "Test1",
                        "message": "Test1",
                        "priority": "NORMAL"
                    }
                    """))
                .andExpect(status().isOk());

        mockMvc.perform(post("/api/v1/notifications/email")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content("""
                    {
                        "to": "test2@example.com",
                        "subject": "Test2",
                        "message": "Test2",
                        "priority": "HIGH"
                    }
                    """))
                .andExpect(status().isOk());
    }
}

package com.notificationservice.service;

import com.notificationservice.entity.Notification;
import com.notificationservice.exception.EmailSendingException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.mail.SimpleMailMessage;
import org.springframework.mail.javamail.JavaMailSender;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class EmailServiceTest {

    @Mock
    private JavaMailSender mailSender;

    @Mock
    private MetricsService metricsService;

    private EmailService emailService; // –£–±—Ä–∞–ª–∏ @InjectMocks

    private Notification testNotification;

    @BeforeEach
    void setUp() {
        // –°–æ–∑–¥–∞–µ–º —Ä–µ–∞–ª—å–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä EmailService
        emailService = new EmailService(mailSender, metricsService) {
            @Override
            public void sendEmailWithTemplate(String to, String subject, String templateId, Object variables) {
            }
        };

        testNotification = new Notification();
        testNotification.setId("test-id");
        testNotification.setRecipient("test@example.com");
        testNotification.setSubject("Test Subject");
        testNotification.setMessage("Test Message");
    }

    @Test
    void sendEmail_WithValidNotification_ShouldSendEmail() {
        // Act
        emailService.sendEmail(testNotification);

        // Assert
        verify(mailSender, times(1)).send(any(SimpleMailMessage.class));
        verify(metricsService, times(1)).recordEmailSent();
        verify(metricsService, never()).recordEmailFailed();
    }

    @Test
    void sendEmail_WithMailException_ShouldRecordFailure() {
        // Arrange
        doThrow(new RuntimeException("SMTP error")).when(mailSender).send(any(SimpleMailMessage.class));

        // Act & Assert
        EmailSendingException exception = assertThrows(EmailSendingException.class, () -> {
            emailService.sendEmail(testNotification);
        });

        // Assert
        assertEquals("Email sending failed: SMTP error", exception.getMessage());
        verify(mailSender, times(1)).send(any(SimpleMailMessage.class));
        verify(metricsService, times(1)).recordEmailFailed();
        verify(metricsService, never()).recordEmailSent();
    }

    @Test
    void sendEmail_WithNullNotification_ShouldThrowException() {
        // Act & Assert
        IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, () -> {
            emailService.sendEmail(null);
        });

        assertEquals("Notification cannot be null", exception.getMessage());
        verify(mailSender, never()).send(any(SimpleMailMessage.class));
        verify(metricsService, never()).recordEmailSent();
        verify(metricsService, never()).recordEmailFailed();
    }
}

package com.notificationservice.service;

import io.micrometer.core.instrument.MeterRegistry;
import io.micrometer.core.instrument.simple.SimpleMeterRegistry;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.util.concurrent.TimeUnit;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;

class ExtendedMetricsServiceTest {

    private MeterRegistry meterRegistry;
    private MetricsService metricsService;

    @BeforeEach
    void setUp() {
        meterRegistry = new SimpleMeterRegistry();
        metricsService = new MetricsService(meterRegistry);
    }

    @Test
    void recordEmailProcessingTime_ShouldRecordTimer() {
        // Given
        long duration = 150L;
        TimeUnit unit = TimeUnit.MILLISECONDS;

        // When
        metricsService.recordEmailProcessingTime(duration, unit);

        // Then
        long count = meterRegistry.timer("notification.email.processing.time").count();
        assertEquals(1, count);
    }

    @Test
    void recordPushProcessingTime_ShouldRecordTimer() {
        // Given
        long duration = 100L;
        TimeUnit unit = TimeUnit.MILLISECONDS;

        // When
        metricsService.recordPushProcessingTime(duration, unit);

        // Then
        long count = meterRegistry.timer("notification.push.processing.time").count();
        assertEquals(1, count);
    }

    @Test
    void recordNotificationStatus_ShouldCreateCounterWithTags() {
        // Given
        String type = "EMAIL";
        String status = "SUCCESS";

        // When
        metricsService.recordNotificationStatus(type, status);

        // Then
        double count = meterRegistry.counter("notification.status",
                "type", type, "status", status).count();
        assertEquals(1.0, count);
    }

    @Test
    void recordNotificationMetric_ShouldCreateSpecificCounter() {
        // Given
        String type = "EMAIL";
        String status = "SUCCESS";

        // When
        metricsService.recordNotificationMetric(type, status);

        // Then
        double count = meterRegistry.counter("notification.email.success").count();
        assertEquals(1.0, count);
    }

    @Test
    void recordBulkNotificationProcessed_ShouldRecordWithCount() {
        // Given
        String type = "EMAIL";
        int count = 5;

        // When
        metricsService.recordBulkNotificationProcessed(type, count);

        // Then
        double actualCount = meterRegistry.counter("notification.bulk.processed",
                "type", type).count();
        assertEquals(5.0, actualCount);
    }

    @Test
    void recordNotificationRetry_ShouldIncrementRetryCounter() {
        // Given
        String type = "EMAIL";

        // When
        metricsService.recordNotificationRetry(type);

        // Then
        double count = meterRegistry.counter("notification.retry.count",
                "type", type).count();
        assertEquals(1.0, count);
    }

    @Test
    void multipleOperations_ShouldUseCache() {
        // When
        metricsService.recordEmailSent();
        int cacheSizeAfterFirstCall = metricsService.getCacheSize();

        metricsService.recordEmailSent(); // Should use cached counter
        int cacheSizeAfterSecondCall = metricsService.getCacheSize();

        // Then
        assertEquals(2.0, meterRegistry.counter("notification.emails.sent").count());
        // Cache size should be the same after multiple calls (reusing cached objects)
        assertEquals(cacheSizeAfterFirstCall, cacheSizeAfterSecondCall);
    }

    @Test
    void clearCache_ShouldResetAllCaches() {
        // Given
        metricsService.recordEmailSent(); // Populates cache - 1 –≤—ã–∑–æ–≤
        metricsService.recordEmailProcessingTime(100, TimeUnit.MILLISECONDS); // Populates cache - 1 –≤—ã–∑–æ–≤
        int initialCacheSize = metricsService.getCacheSize();

        // When
        metricsService.clearCache();
        int cacheSizeAfterClear = metricsService.getCacheSize();

        // Then
        assertEquals(0, cacheSizeAfterClear);
        assertTrue(initialCacheSize > 0, "Initial cache should not be empty");

        // Should work after cache clear - —Å–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–µ —Å—á–µ—Ç—á–∏–∫–∏/—Ç–∞–π–º–µ—Ä—ã
        metricsService.recordEmailSent(); // 2 –≤—ã–∑–æ–≤
        metricsService.recordEmailProcessingTime(200, TimeUnit.MILLISECONDS); // 2 –≤—ã–∑–æ–≤

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –º–µ—Ç—Ä–∏–∫–∏ —Ä–∞–±–æ—Ç–∞—é—Ç –ø–æ—Å–ª–µ –æ—á–∏—Å—Ç–∫–∏ –∫—ç—à–∞
        // –°—á–µ—Ç—á–∏–∫: 1 –≤—ã–∑–æ–≤ –¥–æ –æ—á–∏—Å—Ç–∫–∏ + 1 –ø–æ—Å–ª–µ = 2
        assertEquals(2.0, meterRegistry.counter("notification.emails.sent").count());
        // –¢–∞–π–º–µ—Ä: 1 –≤—ã–∑–æ–≤ –¥–æ –æ—á–∏—Å—Ç–∫–∏ + 1 –ø–æ—Å–ª–µ = 2
        assertEquals(2, meterRegistry.timer("notification.email.processing.time").count());
        // –ù–æ–≤—ã–µ –æ–±—ä–µ–∫—Ç—ã –≤ –∫—ç—à–µ
        assertEquals(2, metricsService.getCacheSize());
    }
}

package com.notificationservice.service;

import io.micrometer.core.instrument.MeterRegistry;
import io.micrometer.core.instrument.simple.SimpleMeterRegistry;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.util.concurrent.TimeUnit;

import static org.junit.jupiter.api.Assertions.*;

class MetricsServiceTest {

    private MeterRegistry meterRegistry;
    private MetricsService metricsService;

    @BeforeEach
    void setUp() {
        meterRegistry = new SimpleMeterRegistry();
        metricsService = new MetricsService(meterRegistry);
    }

    @Test
    void recordEmailSent_ShouldIncrementCounter() {
        // When
        metricsService.recordEmailSent();
        metricsService.recordEmailSent();

        // Then
        double count = meterRegistry.counter("notification.emails.sent").count();
        assertEquals(2.0, count);
    }

    @Test
    void recordEmailFailed_ShouldIncrementCounter() {
        // When
        metricsService.recordEmailFailed();

        // Then
        double count = meterRegistry.counter("notification.emails.failed").count();
        assertEquals(1.0, count);
    }

    @Test
    void recordPushSent_ShouldIncrementCounter() {
        // When
        metricsService.recordPushSent();
        metricsService.recordPushSent();
        metricsService.recordPushSent();

        // Then
        double count = meterRegistry.counter("notification.push.sent").count();
        assertEquals(3.0, count);
    }

    @Test
    void recordPushFailed_ShouldIncrementCounter() {
        // When
        metricsService.recordPushFailed();

        // Then
        double count = meterRegistry.counter("notification.push.failed").count();
        assertEquals(1.0, count);
    }

    @Test
    void recordEmailProcessingTime_ShouldRecordTimer() {
        // When
        metricsService.recordEmailProcessingTime(150, TimeUnit.MILLISECONDS);
        metricsService.recordEmailProcessingTime(200, TimeUnit.MILLISECONDS);

        // Then
        long count = meterRegistry.timer("notification.email.processing.time").count();
        assertEquals(2, count);
    }

    @Test
    void recordPushProcessingTime_ShouldRecordTimer() {
        // When
        metricsService.recordPushProcessingTime(100, TimeUnit.MILLISECONDS);

        // Then
        long count = meterRegistry.timer("notification.push.processing.time").count();
        assertEquals(1, count);
    }

    @Test
    void recordNotificationStatus_ShouldCreateCounterWithTags() {
        // When
        metricsService.recordNotificationStatus("EMAIL", "SUCCESS");
        metricsService.recordNotificationStatus("EMAIL", "FAILED");
        metricsService.recordNotificationStatus("PUSH", "SUCCESS");

        // Then
        double emailSuccess = meterRegistry.counter("notification.status",
                "type", "EMAIL", "status", "SUCCESS").count();
        double emailFailed = meterRegistry.counter("notification.status",
                "type", "EMAIL", "status", "FAILED").count();
        double pushSuccess = meterRegistry.counter("notification.status",
                "type", "PUSH", "status", "SUCCESS").count();

        assertEquals(1.0, emailSuccess);
        assertEquals(1.0, emailFailed);
        assertEquals(1.0, pushSuccess);
    }

    @Test
    void recordNotificationMetric_ShouldCreateSpecificCounter() {
        // When
        metricsService.recordNotificationMetric("EMAIL", "success");
        metricsService.recordNotificationMetric("EMAIL", "success");
        metricsService.recordNotificationMetric("PUSH", "failed");

        // Then
        double emailSuccess = meterRegistry.counter("notification.email.success").count();
        double pushFailed = meterRegistry.counter("notification.push.failed").count();

        assertEquals(2.0, emailSuccess);
        assertEquals(1.0, pushFailed);
    }

    @Test
    void recordBulkNotificationProcessed_ShouldRecordWithCount() {
        // When
        metricsService.recordBulkNotificationProcessed("EMAIL", 5);
        metricsService.recordBulkNotificationProcessed("PUSH", 3);

        // Then
        double emailCount = meterRegistry.counter("notification.bulk.processed",
                "type", "EMAIL").count();
        double pushCount = meterRegistry.counter("notification.bulk.processed",
                "type", "PUSH").count();

        assertEquals(5.0, emailCount);
        assertEquals(3.0, pushCount);
    }

    @Test
    void recordNotificationRetry_ShouldIncrementRetryCounter() {
        // When
        metricsService.recordNotificationRetry("EMAIL");
        metricsService.recordNotificationRetry("EMAIL");
        metricsService.recordNotificationRetry("PUSH");

        // Then
        double emailRetry = meterRegistry.counter("notification.retry.count",
                "type", "EMAIL").count();
        double pushRetry = meterRegistry.counter("notification.retry.count",
                "type", "PUSH").count();

        assertEquals(2.0, emailRetry);
        assertEquals(1.0, pushRetry);
    }

    @Test
    void clearCache_ShouldResetCache() {
        // Given
        metricsService.recordEmailSent(); // Populates cache
        int initialCacheSize = metricsService.getCacheSize();

        // When
        metricsService.clearCache();
        int cacheSizeAfterClear = metricsService.getCacheSize();

        // Then
        assertEquals(0, cacheSizeAfterClear);
        assertTrue(initialCacheSize > 0, "Initial cache should not be empty");

        // Should work after cache clear
        // –°—á–µ—Ç—á–∏–∫ –ø—Ä–æ–¥–æ–ª–∂–∞–µ—Ç —Å—É—â–µ—Å—Ç–≤–æ–≤–∞—Ç—å –≤ MeterRegistry, –ø–æ—ç—Ç–æ–º—É –∑–Ω–∞—á–µ–Ω–∏—è –Ω–∞–∫–∞–ø–ª–∏–≤–∞—é—Ç—Å—è
        metricsService.recordEmailSent();
        // 1 –≤—ã–∑–æ–≤ –¥–æ –æ—á–∏—Å—Ç–∫–∏ + 1 –ø–æ—Å–ª–µ = 2
        double count = meterRegistry.counter("notification.emails.sent").count();
        assertEquals(2.0, count);
        assertEquals(1, metricsService.getCacheSize());
    }
}

package com.notificationservice.service;

import com.notificationservice.dto.EmailRequest;
import com.notificationservice.dto.PushRequest;
import com.notificationservice.entity.Notification;
import com.notificationservice.repository.NotificationRepository;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.time.LocalDateTime;
import java.util.Optional;
import java.util.UUID;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class NotificationMetricsTest {

    @Mock
    private NotificationRepository notificationRepository;

    @Mock
    private EmailService emailService;

    @Mock
    private PushService pushService;

    @Mock
    private MetricsService metricsService;

    @Mock
    private TemplateService templateService;

    @InjectMocks
    private NotificationService notificationService;

    @Test
    void whenEmailSentSuccessfully_ShouldRecordMetrics() {
        // Given
        EmailRequest request = new EmailRequest();
        request.setTo("test@example.com");
        request.setSubject("Test");
        request.setMessage("Test message");

        String notificationId = UUID.randomUUID().toString();

        when(notificationRepository.save(any(Notification.class))).thenAnswer(invocation -> {
            Notification notification = invocation.getArgument(0);
            notification.setId(notificationId);
            return notification;
        });

        doNothing().when(emailService).sendEmail(any(Notification.class));

        // When
        notificationService.sendEmail(request);

        // Then
        verify(metricsService, times(1)).recordEmailSent();
        verify(metricsService, never()).recordEmailFailed();
    }

    @Test
    void whenPushSentSuccessfully_ShouldRecordMetrics() {
        // Given
        PushRequest request = new PushRequest();
        request.setUserId("user123");
        request.setTitle("Test");
        request.setMessage("Test message");

        String notificationId = UUID.randomUUID().toString();

        when(notificationRepository.save(any(Notification.class))).thenAnswer(invocation -> {
            Notification notification = invocation.getArgument(0);
            notification.setId(notificationId);
            return notification;
        });

        doNothing().when(pushService).sendPush(any(Notification.class));

        // When
        notificationService.sendPush(request);

        // Then
        verify(metricsService, times(1)).recordPushSent();
        verify(metricsService, never()).recordPushFailed();
    }

    @Test
    void whenEmailValidationFails_ShouldRecordFailureMetrics() {
        // Given
        EmailRequest invalidRequest = new EmailRequest();
        invalidRequest.setTo(""); // –ù–µ–≤–∞–ª–∏–¥–Ω—ã–π email
        invalidRequest.setSubject("Test");
        invalidRequest.setMessage("Test message");

        // When
        notificationService.sendEmail(invalidRequest);

        // Then
        verify(metricsService, times(1)).recordEmailFailed();
        verify(metricsService, never()).recordEmailSent();
        verify(notificationRepository, never()).save(any(Notification.class));
    }

    @Test
    void whenPushValidationFails_ShouldRecordFailureMetrics() {
        // Given
        PushRequest invalidRequest = new PushRequest();
        invalidRequest.setUserId(""); // –ù–µ–≤–∞–ª–∏–¥–Ω—ã–π userId
        invalidRequest.setTitle("Test");
        invalidRequest.setMessage("Test message");

        // When
        notificationService.sendPush(invalidRequest);

        // Then
        verify(metricsService, times(1)).recordPushFailed();
        verify(metricsService, never()).recordPushSent();
        verify(notificationRepository, never()).save(any(Notification.class));
    }

    @Test
    void whenEmailSendingFails_ShouldRecordFailureMetrics() {
        // Given
        EmailRequest request = new EmailRequest();
        request.setTo("test@example.com");
        request.setSubject("Test");
        request.setMessage("Test message");

        String notificationId = UUID.randomUUID().toString();

        when(notificationRepository.save(any(Notification.class))).thenAnswer(invocation -> {
            Notification notification = invocation.getArgument(0);
            notification.setId(notificationId);
            return notification;
        });

        doThrow(new RuntimeException("Email service unavailable"))
                .when(emailService).sendEmail(any(Notification.class));

        // When
        notificationService.sendEmail(request);

        // Then
        verify(metricsService, times(1)).recordEmailFailed();
        verify(metricsService, never()).recordEmailSent();
    }
}

package com.notificationservice.service;

import com.notificationservice.dto.EmailRequest;
import com.notificationservice.dto.NotificationResponse;
import com.notificationservice.dto.PushRequest;
import com.notificationservice.entity.Notification;
import com.notificationservice.exception.EmailSendingException;
import com.notificationservice.exception.NotificationNotFoundException;
import com.notificationservice.repository.NotificationRepository;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.amqp.rabbit.core.RabbitTemplate;

import java.time.LocalDateTime;
import java.util.Optional;
import java.util.concurrent.CompletableFuture;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class NotificationServiceTest {

    @Mock
    private RabbitTemplate rabbitTemplate;

    @Mock
    private NotificationRepository notificationRepository;

    @Mock
    private EmailService emailService;

    @Mock
    private PushService pushService;

    @Mock
    private TemplateService templateService;

    @Mock
    private MetricsService metricsService;

    @InjectMocks
    private NotificationService notificationService;

    private EmailRequest validEmailRequest;
    private PushRequest validPushRequest;

    @BeforeEach
    void setUp() {
        validEmailRequest = new EmailRequest();
        validEmailRequest.setTo("test@example.com");
        validEmailRequest.setSubject("Test Subject");
        validEmailRequest.setMessage("Test Message");
        validEmailRequest.setPriority(EmailRequest.Priority.NORMAL);

        validPushRequest = new PushRequest();
        validPushRequest.setUserId("user-123");
        validPushRequest.setTitle("Test Title");
        validPushRequest.setMessage("Test Message");
        validPushRequest.setPriority(PushRequest.Priority.NORMAL);
    }

    @Test
    void sendEmail_WithValidRequest_ShouldReturnSuccessResponse() {
        // Arrange
        when(notificationRepository.save(any(Notification.class))).thenAnswer(invocation -> {
            Notification notification = invocation.getArgument(0);
            notification.setId("test-id");
            return notification;
        });

        // Act
        NotificationResponse response = notificationService.sendEmail(validEmailRequest);

        // Assert
        assertNotNull(response);
        assertEquals("test-id", response.getId());
        assertEquals("EMAIL", response.getType());
        assertEquals("test@example.com", response.getRecipient());
        assertEquals("SENT", response.getStatus());
        verify(notificationRepository, times(2)).save(any(Notification.class));
        verify(emailService, times(1)).sendEmail(any(Notification.class));
        verify(metricsService, times(1)).recordEmailSent();
    }

    @Test
    void sendEmail_WithInvalidRequest_ShouldReturnErrorResponse() {
        // Arrange
        EmailRequest invalidRequest = new EmailRequest();
        invalidRequest.setTo("");
        invalidRequest.setSubject("");
        invalidRequest.setMessage("");

        // Act
        NotificationResponse response = notificationService.sendEmail(invalidRequest);

        // Assert
        assertNotNull(response);
        assertEquals("FAILED", response.getStatus());
        assertTrue(response.getErrorMessage().contains("Invalid email request"));
        verify(metricsService, times(1)).recordEmailFailed();
        verify(notificationRepository, never()).save(any(Notification.class));
    }

    @Test
    void sendEmail_WithTemplate_ShouldProcessTemplate() {
        // Arrange
        validEmailRequest.setTemplateId("test-template");
        validEmailRequest.setTemplateVariables(java.util.Map.of("name", "John"));

        when(notificationRepository.save(any(Notification.class))).thenAnswer(invocation -> {
            Notification notification = invocation.getArgument(0);
            notification.setId("test-id");
            return notification;
        });
        when(templateService.processTemplate(anyString(), any())).thenReturn("Processed Template Content");

        // Act
        NotificationResponse response = notificationService.sendEmail(validEmailRequest);

        // Assert
        assertNotNull(response);
        verify(templateService, times(1)).processTemplate("test-template", validEmailRequest.getTemplateVariables());
        verify(emailService, times(1)).sendEmail(any(Notification.class));
    }

    @Test
    void sendEmailAsync_ShouldReturnCompletableFuture() {
        // Arrange
        when(notificationRepository.save(any(Notification.class))).thenAnswer(invocation -> {
            Notification notification = invocation.getArgument(0);
            notification.setId("test-id");
            return notification;
        });

        // Act
        CompletableFuture<NotificationResponse> future = notificationService.sendEmailAsync(validEmailRequest);

        // Assert
        assertNotNull(future);
        assertDoesNotThrow(() -> {
            NotificationResponse response = future.get();
            assertNotNull(response);
            assertEquals("SENT", response.getStatus());
        });
    }

    @Test
    void sendPush_WithValidRequest_ShouldReturnSuccessResponse() {
        // Arrange
        when(notificationRepository.save(any(Notification.class))).thenAnswer(invocation -> {
            Notification notification = invocation.getArgument(0);
            notification.setId("test-id");
            return notification;
        });

        // Act
        NotificationResponse response = notificationService.sendPush(validPushRequest);

        // Assert
        assertNotNull(response);
        assertEquals("PUSH", response.getType());
        assertEquals("user-123", response.getRecipient());
        assertEquals("SENT", response.getStatus());
        verify(pushService, times(1)).sendPush(any(Notification.class));
        verify(metricsService, times(1)).recordPushSent();
    }

    @Test
    void sendPush_WithInvalidRequest_ShouldReturnErrorResponse() {
        // Arrange
        PushRequest invalidRequest = new PushRequest();
        invalidRequest.setUserId("");
        invalidRequest.setTitle("");
        invalidRequest.setMessage("");

        // Act
        NotificationResponse response = notificationService.sendPush(invalidRequest);

        // Assert
        assertNotNull(response);
        assertEquals("FAILED", response.getStatus());
        assertTrue(response.getErrorMessage().contains("Invalid push request"));
        verify(metricsService, times(1)).recordPushFailed();
        verify(notificationRepository, never()).save(any(Notification.class));
    }

    @Test
    void getNotificationStatus_WithExistingId_ShouldReturnNotification() {
        // Arrange
        String notificationId = "test-id";
        Notification testNotification = new Notification();
        testNotification.setId(notificationId);
        when(notificationRepository.findById(notificationId)).thenReturn(Optional.of(testNotification));

        // Act
        Notification result = notificationService.getNotificationStatus(notificationId);

        // Assert
        assertNotNull(result);
        assertEquals(notificationId, result.getId());
        verify(notificationRepository, times(1)).findById(notificationId);
    }

    @Test
    void getNotificationStatus_WithNonExistingId_ShouldThrowException() {
        // Arrange
        String notificationId = "non-existing-id";
        when(notificationRepository.findById(notificationId)).thenReturn(Optional.empty());

        // Act & Assert
        assertThrows(NotificationNotFoundException.class, () -> {
            notificationService.getNotificationStatus(notificationId);
        });
    }

    @Test
    void processNotification_WithPendingEmail_ShouldProcessSuccessfully() {
        // Arrange
        String notificationId = "test-id";
        Notification testNotification = new Notification();
        testNotification.setId(notificationId);
        testNotification.setType("EMAIL");
        testNotification.setStatus("PENDING");

        when(notificationRepository.findById(notificationId)).thenReturn(Optional.of(testNotification));

        // Act
        notificationService.processNotification(notificationId);

        // Assert
        verify(emailService, times(1)).sendEmail(testNotification);
        verify(notificationRepository, times(1)).save(any(Notification.class));
    }

    @Test
    void processNotification_WithFailedEmail_ShouldHandleFailure() {
        // Arrange
        String notificationId = "test-id";
        Notification testNotification = new Notification();
        testNotification.setId(notificationId);
        testNotification.setType("EMAIL");
        testNotification.setStatus("PENDING");

        when(notificationRepository.findById(notificationId)).thenReturn(Optional.of(testNotification));
        doThrow(new EmailSendingException("SMTP Error")).when(emailService).sendEmail(any(Notification.class));

        // Act & Assert
        assertThrows(EmailSendingException.class, () -> {
            notificationService.processNotification(notificationId);
        });

        verify(notificationRepository, times(1)).save(any(Notification.class));
    }

    @Test
    void processNotification_WithNonPendingStatus_ShouldSkipProcessing() {
        // Arrange
        String notificationId = "test-id";
        Notification testNotification = new Notification();
        testNotification.setId(notificationId);
        testNotification.setStatus("SENT");

        when(notificationRepository.findById(notificationId)).thenReturn(Optional.of(testNotification));

        // Act
        notificationService.processNotification(notificationId);

        // Assert
        verify(emailService, never()).sendEmail(any(Notification.class));
        verify(pushService, never()).sendPush(any(Notification.class));
    }

    @Test
    void processNotification_WithUnknownType_ShouldThrowException() {
        // Arrange
        String notificationId = "test-id";
        Notification testNotification = new Notification();
        testNotification.setId(notificationId);
        testNotification.setType("UNKNOWN");
        testNotification.setStatus("PENDING");

        when(notificationRepository.findById(notificationId)).thenReturn(Optional.of(testNotification));

        // Act & Assert
        assertThrows(IllegalArgumentException.class, () -> {
            notificationService.processNotification(notificationId);
        });
    }

    @Test
    void sendEmail_WithEmailServiceException_ShouldHandleGracefully() {
        // Arrange
        when(notificationRepository.save(any(Notification.class))).thenAnswer(invocation -> {
            Notification notification = invocation.getArgument(0);
            notification.setId("test-id");
            return notification;
        });
        doThrow(new EmailSendingException("SMTP error")).when(emailService).sendEmail(any(Notification.class));

        // Act
        NotificationResponse response = notificationService.sendEmail(validEmailRequest);

        // Assert
        assertNotNull(response);
        assertEquals("FAILED", response.getStatus());
        assertTrue(response.getErrorMessage().contains("SMTP error"));
        verify(metricsService, times(1)).recordEmailFailed();
    }

    @Test
    void sendPush_WithPushServiceException_ShouldHandleGracefully() {
        // Arrange
        when(notificationRepository.save(any(Notification.class))).thenAnswer(invocation -> {
            Notification notification = invocation.getArgument(0);
            notification.setId("test-id");
            return notification;
        });
        doThrow(new RuntimeException("Push service error")).when(pushService).sendPush(any(Notification.class));

        // Act
        NotificationResponse response = notificationService.sendPush(validPushRequest);

        // Assert
        assertNotNull(response);
        assertEquals("FAILED", response.getStatus());
        assertTrue(response.getErrorMessage().contains("Push service error"));
        verify(metricsService, times(1)).recordPushFailed();
    }
}

package com.notificationservice.service;

import com.notificationservice.config.TestApplicationConfig;
import com.notificationservice.dto.EmailRequest;
import com.notificationservice.dto.NotificationResponse;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.transaction.annotation.Transactional;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@SpringBootTest(classes = TestApplicationConfig.class)
@ActiveProfiles("test")
@Transactional
class NotificationServiceUnitTest {

    @Autowired
    private NotificationService notificationService;

    @MockBean
    private EmailService emailService;

    @Test
    void sendEmailSuccessfully() {
        // Given
        EmailRequest request = new EmailRequest();
        request.setTo("test@example.com");
        request.setSubject("Test Subject");

        // –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º mock
        doNothing().when(emailService).sendEmail(any());

        // When
        NotificationResponse response = notificationService.sendEmail(request);

        // Then
        assertNotNull(response);
        assertNotNull(response.getId());
    }

    @Test
    void getNotificationStatus() {
        // Given
        EmailRequest request = new EmailRequest();
        request.setTo("test@example.com");
        request.setSubject("Test Subject");
        request.setMessage("Test Message"); // –î–æ–±–∞–≤–ª—è–µ–º –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ–µ –ø–æ–ª–µ

        doNothing().when(emailService).sendEmail(any());

        // When
        NotificationResponse sentResponse = notificationService.sendEmail(request);

        // Then
        assertNotNull(sentResponse);
        assertNotNull(sentResponse.getId());

        // When
        var notification = notificationService.getNotificationStatus(sentResponse.getId());

        // Then
        assertNotNull(notification);
        assertEquals(sentResponse.getId(), notification.getId());
    }
}

package com.notificationservice.service;

import io.micrometer.core.instrument.MeterRegistry;
import io.micrometer.core.instrument.simple.SimpleMeterRegistry;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.util.concurrent.TimeUnit;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;

class OptimizedMetricsServiceTest {

    private MeterRegistry meterRegistry;
    private MetricsService metricsService;

    @BeforeEach
    void setUp() {
        meterRegistry = new SimpleMeterRegistry();
        metricsService = new MetricsService(meterRegistry);
    }

    @Test
    void recordEmailSent_ShouldUseCachedCounter() {
        // When
        metricsService.recordEmailSent();
        int cacheSizeAfterFirstCall = metricsService.getCacheSize();

        metricsService.recordEmailSent(); // –í—Ç–æ—Ä–æ–π –≤—ã–∑–æ–≤ –¥–æ–ª–∂–µ–Ω –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫—ç—à
        int cacheSizeAfterSecondCall = metricsService.getCacheSize();

        // Then
        assertEquals(2.0, meterRegistry.counter("notification.emails.sent").count());
        assertEquals(cacheSizeAfterFirstCall, cacheSizeAfterSecondCall); // Cache size should not change
    }

    @Test
    void recordMultipleMetrics_ShouldCacheAllCounters() {
        // When
        metricsService.recordEmailSent();
        metricsService.recordEmailFailed();
        metricsService.recordPushSent();
        metricsService.recordPushFailed();

        // Then - –ø—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –≤—Å–µ —Å—á–µ—Ç—á–∏–∫–∏ —Å–æ–∑–¥–∞–Ω—ã –∏ —Ä–∞–±–æ—Ç–∞—é—Ç
        assertEquals(1.0, meterRegistry.counter("notification.emails.sent").count());
        assertEquals(1.0, meterRegistry.counter("notification.emails.failed").count());
        assertEquals(1.0, meterRegistry.counter("notification.push.sent").count());
        assertEquals(1.0, meterRegistry.counter("notification.push.failed").count());

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –∫—ç—à —Å–æ–¥–µ—Ä–∂–∏—Ç –≤—Å–µ —Å—á–µ—Ç—á–∏–∫–∏
        assertEquals(4, metricsService.getCacheSize());
    }

    @Test
    void clearCache_ShouldResetCache() {
        // Given
        metricsService.recordEmailSent(); // –°–æ–∑–¥–∞–µ—Ç –∏ –∫—ç—à–∏—Ä—É–µ—Ç —Å—á–µ—Ç—á–∏–∫
        int initialCacheSize = metricsService.getCacheSize();

        // When
        metricsService.clearCache();
        int cacheSizeAfterClear = metricsService.getCacheSize();

        // Then
        assertEquals(0, cacheSizeAfterClear);
        assertTrue(initialCacheSize > 0, "Initial cache should not be empty");

        // –î–æ–ª–∂–µ–Ω —Å–æ–∑–¥–∞—Ç—å —Å—á–µ—Ç—á–∏–∫ –∑–∞–Ω–æ–≤–æ, –Ω–æ —Å—á–µ—Ç—á–∏–∫ –≤ MeterRegistry –ø—Ä–æ–¥–æ–ª–∂–∞–µ—Ç —Å—É—â–µ—Å—Ç–≤–æ–≤–∞—Ç—å
        metricsService.recordEmailSent();
        // 1 –≤—ã–∑–æ–≤ –¥–æ –æ—á–∏—Å—Ç–∫–∏ + 1 –ø–æ—Å–ª–µ = 2
        assertEquals(2.0, meterRegistry.counter("notification.emails.sent").count());
        assertEquals(1, metricsService.getCacheSize());
    }

    @Test
    void recordEmailProcessingTime_ShouldRecordTimer() {
        // When
        metricsService.recordEmailProcessingTime(150, TimeUnit.MILLISECONDS);

        // Then - –ø—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ —Ç–∞–π–º–µ—Ä —Å–æ–∑–¥–∞–Ω –∏ –≤—ã–∑–≤–∞–Ω
        long count = meterRegistry.find("notification.email.processing.time").timer().count();
        assertEquals(1, count);
    }
}

package com.notificationservice.service;

import com.notificationservice.entity.Notification;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import static org.junit.Assert.assertThrows;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class PushServiceTest {

    @Mock
    private MetricsService metricsService;

    @InjectMocks
    private PushService pushService;

    private Notification testNotification;

    @BeforeEach
    void setUp() {
        testNotification = new Notification();
        testNotification.setId("test-id");
        testNotification.setRecipient("user-123");
        testNotification.setTitle("Test Title");
        testNotification.setMessage("Test Message");
    }

    @Test
    void sendPush_WithValidNotification_ShouldSendPush() {
        // Act
        pushService.sendPush(testNotification);

        // Assert
        verify(metricsService, never()).recordPushFailed();
        // –í —Ä–µ–∞–ª—å–Ω–æ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –∑–¥–µ—Å—å –±—ã–ª–∞ –±—ã –ø—Ä–æ–≤–µ—Ä–∫–∞ –≤—ã–∑–æ–≤–∞ –≤–Ω–µ—à–Ω–µ–≥–æ —Å–µ—Ä–≤–∏—Å–∞
    }

    @Test
    void sendPush_WithPushException_ShouldRecordFailure() {
        // Arrange
        // –í —Ä–µ–∞–ª—å–Ω–æ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –∑–¥–µ—Å—å –±—ã–ª –±—ã –º–æ–∫ –≤–Ω–µ—à–Ω–µ–≥–æ —Å–µ—Ä–≤–∏—Å–∞

        // Act
        pushService.sendPush(testNotification);

        // Assert
        // –í —Ä–µ–∞–ª—å–Ω–æ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –∑–¥–µ—Å—å –±—ã–ª–∞ –±—ã –ø—Ä–æ–≤–µ—Ä–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—à–∏–±–∫–∏
        verify(metricsService, never()).recordPushFailed();
    }

    @Test
    void sendPush_WithNullNotification_ShouldThrowException() {
        // Act & Assert
        assertThrows(IllegalArgumentException.class, () -> {
            pushService.sendPush(null);
        });
    }
}

package com.notificationservice.service;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;

@ExtendWith(MockitoExtension.class)
class TemplateServiceTest {

    @InjectMocks
    private TemplateService templateService;

    @Test
    void processTemplate_WithValidTemplateAndVariables_ShouldReturnProcessedContent() {
        // Arrange
        String templateId = "welcome-template";
        Map<String, Object> variables = Map.of("name", "John", "company", "Test Corp");

        // Act
        String result = templateService.processTemplate(templateId, variables);

        // Assert
        assertNotNull(result);
        assertTrue(result.contains("John"));
        assertTrue(result.contains("Test Corp"));
    }

    @Test
    void processTemplate_WithNullTemplateId_ShouldThrowException() {
        // Arrange
        Map<String, Object> variables = Map.of("name", "John");

        // Act & Assert
        assertThrows(IllegalArgumentException.class, () -> {
            templateService.processTemplate(null, variables);
        });
    }

    @Test
    void processTemplate_WithEmptyTemplateId_ShouldThrowException() {
        // Arrange
        Map<String, Object> variables = Map.of("name", "John");

        // Act & Assert
        assertThrows(IllegalArgumentException.class, () -> {
            templateService.processTemplate("", variables);
        });
    }

    @Test
    void processTemplate_WithNonExistentTemplate_ShouldReturnDefaultMessage() {
        // Arrange
        String templateId = "non-existent-template";
        Map<String, Object> variables = Map.of("name", "John");

        // Act
        String result = templateService.processTemplate(templateId, variables);

        // Assert
        assertNotNull(result);
        assertTrue(result.contains("Template not found"));
    }
}

package com.notificationservice.unit;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.junit.jupiter.MockitoExtension;

import static org.junit.jupiter.api.Assertions.*;

@ExtendWith(MockitoExtension.class)
class SimpleUnitTest {

    @Test
    void basicTest() {
        assertTrue(true, "This should always pass");
    }

    @Test
    void mathTest() {
        assertEquals(4, 2 + 2, "Basic math should work");
    }

    @Test
    void stringTest() {
        String message = "Hello, Test!";
        assertNotNull(message);
        assertTrue(message.contains("Test"));
    }
}

package com.notificationservice.util;

import org.springframework.validation.BindingResult;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;

import java.util.List;

import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

public class ExceptionTestUtils {

    public static MethodArgumentNotValidException createValidationException(String fieldName, String errorMessage) {
        BindingResult bindingResult = mock(BindingResult.class);
        FieldError fieldError = new FieldError("objectName", fieldName, errorMessage);
        when(bindingResult.getFieldErrors()).thenReturn(List.of(fieldError)); // –ò—Å–ø–æ–ª—å–∑—É–µ–º getFieldErrors –≤–º–µ—Å—Ç–æ getAllErrors
        MethodArgumentNotValidException exception = mock(MethodArgumentNotValidException.class);
        when(exception.getBindingResult()).thenReturn(bindingResult);
        return exception;
    }

    public static MethodArgumentNotValidException createMultipleValidationException() {
        BindingResult bindingResult = mock(BindingResult.class);
        FieldError fieldError1 = new FieldError("emailRequest", "to", "Email is required");
        FieldError fieldError2 = new FieldError("emailRequest", "subject", "Subject cannot be empty");
        FieldError fieldError3 = new FieldError("emailRequest", "message", "Message is required");
        when(bindingResult.getFieldErrors()).thenReturn(List.of(fieldError1, fieldError2, fieldError3));
        MethodArgumentNotValidException exception = mock(MethodArgumentNotValidException.class);
        when(exception.getBindingResult()).thenReturn(bindingResult);
        return exception;
    }
}

package com.notificationservice.validation;

import com.notificationservice.dto.EmailRequest;
import org.junit.jupiter.api.Test;

import jakarta.validation.ConstraintViolation;
import jakarta.validation.Validation;
import jakarta.validation.Validator;
import jakarta.validation.ValidatorFactory;
import java.util.Set;

import static org.junit.jupiter.api.Assertions.*;

class EmailRequestValidationTest {

    private final Validator validator;

    public EmailRequestValidationTest() {
        ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
        validator = factory.getValidator();
    }

    @Test
    void whenValidEmailRequest_ThenNoViolations() {
        // Given
        EmailRequest request = new EmailRequest();
        request.setTo("test@example.com");
        request.setSubject("Test Subject");
        request.setMessage("Test message content");

        // When
        Set<ConstraintViolation<EmailRequest>> violations = validator.validate(request);

        // Then
        assertTrue(violations.isEmpty(), "Should have no violations for valid email request");
    }

    @Test
    void whenInvalidEmail_ThenViolationOccurs() {
        // Given
        EmailRequest request = new EmailRequest();
        request.setTo("invalid-email");
        request.setSubject("Test Subject");
        request.setMessage("Test message");

        // When
        Set<ConstraintViolation<EmailRequest>> violations = validator.validate(request);

        // Then
        assertFalse(violations.isEmpty(), "Should have violations for invalid email format");
        assertEquals(1, violations.size());
        assertTrue(violations.iterator().next().getMessage().toLowerCase().contains("email"));
    }

    @Test
    void whenEmptyEmail_ThenViolationOccurs() {
        // Given
        EmailRequest request = new EmailRequest();
        request.setTo("");
        request.setSubject("Test Subject");
        request.setMessage("Test message");

        // When
        Set<ConstraintViolation<EmailRequest>> violations = validator.validate(request);

        // Then
        assertFalse(violations.isEmpty(), "Should have violations for empty email");
    }

    @Test
    void whenNullEmail_ThenViolationOccurs() {
        // Given
        EmailRequest request = new EmailRequest();
        request.setTo(null);
        request.setSubject("Test Subject");
        request.setMessage("Test message");

        // When
        Set<ConstraintViolation<EmailRequest>> violations = validator.validate(request);

        // Then
        assertFalse(violations.isEmpty(), "Should have violations for null email");
    }

    @Test
    void whenEmptySubject_ThenViolationOccurs() {
        // Given
        EmailRequest request = new EmailRequest();
        request.setTo("test@example.com");
        request.setSubject("");
        request.setMessage("Test message");

        // When
        Set<ConstraintViolation<EmailRequest>> violations = validator.validate(request);

        // Then
        assertFalse(violations.isEmpty(), "Should have violations for empty subject");
    }

    @Test
    void whenNullSubject_ThenViolationOccurs() {
        // Given
        EmailRequest request = new EmailRequest();
        request.setTo("test@example.com");
        request.setSubject(null);
        request.setMessage("Test message");

        // When
        Set<ConstraintViolation<EmailRequest>> violations = validator.validate(request);

        // Then
        assertFalse(violations.isEmpty(), "Should have violations for null subject");
    }

    @Test
    void whenEmptyMessage_ThenViolationOccurs() {
        // Given
        EmailRequest request = new EmailRequest();
        request.setTo("test@example.com");
        request.setSubject("Test Subject");
        request.setMessage("");

        // When
        Set<ConstraintViolation<EmailRequest>> violations = validator.validate(request);

        // Then
        assertFalse(violations.isEmpty(), "Should have violations for empty message");
    }

    @Test
    void whenNullMessage_ThenViolationOccurs() {
        // Given
        EmailRequest request = new EmailRequest();
        request.setTo("test@example.com");
        request.setSubject("Test Subject");
        request.setMessage(null);

        // When
        Set<ConstraintViolation<EmailRequest>> violations = validator.validate(request);

        // Then
        assertFalse(violations.isEmpty(), "Should have violations for null message");
    }

    @Test
    void whenAllFieldsInvalid_ThenMultipleViolations() {
        // Given
        EmailRequest request = new EmailRequest();
        request.setTo("invalid");
        request.setSubject("");
        request.setMessage(null);

        // When
        Set<ConstraintViolation<EmailRequest>> violations = validator.validate(request);

        // Then
        assertFalse(violations.isEmpty(), "Should have multiple violations");
        assertTrue(violations.size() >= 3, "Should have at least 3 violations");
    }
}

package com.notificationservice.validation;

import com.notificationservice.config.TestSecurityConfig;
import com.notificationservice.controller.NotificationController;
import com.notificationservice.dto.NotificationResponse;
import com.notificationservice.service.NotificationService;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.context.annotation.Import;
import org.springframework.http.MediaType;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.web.servlet.MockMvc;

import static org.mockito.Mockito.when;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@WebMvcTest(NotificationController.class)
@ActiveProfiles("test")
@Import(TestSecurityConfig.class)
class NotificationValidationTest {

    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private NotificationService notificationService;

    @Test
    void whenValidEmailRequest_ShouldReturnOk() throws Exception {
        NotificationResponse response = NotificationResponse.success(
                "test-id", "EMAIL", "test@example.com", "Test", "Test"
        );
        when(notificationService.sendEmail(org.mockito.ArgumentMatchers.any())).thenReturn(response);

        mockMvc.perform(post("/api/v1/notifications/email")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content("""
                    {
                        "to": "valid@example.com",
                        "subject": "Test Subject",
                        "message": "Test Message",
                        "priority": "NORMAL"
                    }
                    """))
                .andExpect(status().isOk());
    }

    @Test
    void whenValidPushRequest_ShouldReturnOk() throws Exception {
        NotificationResponse response = NotificationResponse.success(
                "test-id", "PUSH", "user123", "Test", "Test"
        );
        when(notificationService.sendPush(org.mockito.ArgumentMatchers.any())).thenReturn(response);

        mockMvc.perform(post("/api/v1/notifications/push")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content("""
                    {
                        "userId": "user123",
                        "title": "Test Title",
                        "message": "Test Message",
                        "platform": "IOS",
                        "priority": "NORMAL"
                    }
                    """))
                .andExpect(status().isOk());
    }
}

package com.notificationservice.validation;

import com.notificationservice.dto.PushRequest;
import org.junit.jupiter.api.Test;

import jakarta.validation.ConstraintViolation;
import jakarta.validation.Validation;
import jakarta.validation.Validator;
import jakarta.validation.ValidatorFactory;
import java.util.Set;

import static org.junit.jupiter.api.Assertions.*;

class PushRequestValidationTest {

    private final Validator validator;

    public PushRequestValidationTest() {
        ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
        validator = factory.getValidator();
    }

    @Test
    void whenValidPushRequest_ThenNoViolations() {
        // Given
        PushRequest request = new PushRequest();
        request.setUserId("user-123");
        request.setTitle("Test Title");
        request.setMessage("Test message content");
        request.setPlatform("IOS");

        // When
        Set<ConstraintViolation<PushRequest>> violations = validator.validate(request);

        // Then
        assertTrue(violations.isEmpty(), "Should have no violations for valid push request");
    }

    @Test
    void whenEmptyUserId_ThenViolationOccurs() {
        // Given
        PushRequest request = new PushRequest();
        request.setUserId("");
        request.setTitle("Test Title");
        request.setMessage("Test message");

        // When
        Set<ConstraintViolation<PushRequest>> violations = validator.validate(request);

        // Then
        assertFalse(violations.isEmpty(), "Should have violations for empty user ID");
    }

    @Test
    void whenNullUserId_ThenViolationOccurs() {
        // Given
        PushRequest request = new PushRequest();
        request.setUserId(null);
        request.setTitle("Test Title");
        request.setMessage("Test message");

        // When
        Set<ConstraintViolation<PushRequest>> violations = validator.validate(request);

        // Then
        assertFalse(violations.isEmpty(), "Should have violations for null user ID");
    }

    @Test
    void whenEmptyTitle_ThenViolationOccurs() {
        // Given
        PushRequest request = new PushRequest();
        request.setUserId("user-123");
        request.setTitle("");
        request.setMessage("Test message");

        // When
        Set<ConstraintViolation<PushRequest>> violations = validator.validate(request);

        // Then
        assertFalse(violations.isEmpty(), "Should have violations for empty title");
    }

    @Test
    void whenNullTitle_ThenViolationOccurs() {
        // Given
        PushRequest request = new PushRequest();
        request.setUserId("user-123");
        request.setTitle(null);
        request.setMessage("Test message");

        // When
        Set<ConstraintViolation<PushRequest>> violations = validator.validate(request);

        // Then
        assertFalse(violations.isEmpty(), "Should have violations for null title");
    }

    @Test
    void whenEmptyMessage_ThenViolationOccurs() {
        // Given
        PushRequest request = new PushRequest();
        request.setUserId("user-123");
        request.setTitle("Test Title");
        request.setMessage("");

        // When
        Set<ConstraintViolation<PushRequest>> violations = validator.validate(request);

        // Then
        assertFalse(violations.isEmpty(), "Should have violations for empty message");
    }

    @Test
    void whenNullMessage_ThenViolationOccurs() {
        // Given
        PushRequest request = new PushRequest();
        request.setUserId("user-123");
        request.setTitle("Test Title");
        request.setMessage(null);

        // When
        Set<ConstraintViolation<PushRequest>> violations = validator.validate(request);

        // Then
        assertFalse(violations.isEmpty(), "Should have violations for null message");
    }

    @Test
    void whenInvalidPlatform_ThenViolationOccurs() {
        // Given
        PushRequest request = new PushRequest();
        request.setUserId("user-123");
        request.setTitle("Test Title");
        request.setMessage("Test message");
        request.setPlatform("INVALID_PLATFORM"); // –ù–µ–≤–∞–ª–∏–¥–Ω–∞—è –ø–ª–∞—Ç—Ñ–æ—Ä–º–∞

        // When
        Set<ConstraintViolation<PushRequest>> violations = validator.validate(request);

        // Then
        assertFalse(violations.isEmpty(), "Should have violations for invalid platform");

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –µ—Å—Ç—å violation –∏–º–µ–Ω–Ω–æ –¥–ª—è –ø–æ–ª—è platform
        boolean hasPlatformViolation = violations.stream()
                .anyMatch(v -> "platform".equals(v.getPropertyPath().toString()));
        assertTrue(hasPlatformViolation, "Should have violation for platform field");
    }

    @Test
    void whenAllFieldsInvalid_ThenMultipleViolations() {
        // Given
        PushRequest request = new PushRequest();
        request.setUserId("");
        request.setTitle("");
        request.setMessage(null);

        // When
        Set<ConstraintViolation<PushRequest>> violations = validator.validate(request);

        // Then
        assertFalse(violations.isEmpty(), "Should have multiple violations");
        assertTrue(violations.size() >= 3, "Should have at least 3 violations");
    }
}

spring:
  config:
    activate:
      on-profile: test
  datasource:
    url: jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE;MODE=PostgreSQL
    username: sa
    password: ""
    driver-class-name: org.h2.Driver
  jpa:
    hibernate:
      ddl-auto: create-drop
    show-sql: true
    properties:
      hibernate:
        dialect: org.hibernate.dialect.H2Dialect
        format_sql: true
        show_sql: false
    defer-datasource-initialization: false
  h2:
    console:
      enabled: false
  flyway:
    enabled: false
  sql:
    init:
      mode: never  # –û—Ç–∫–ª—é—á–∞–µ–º –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—é SQL
      data-locations: ""  # –û—á–∏—â–∞–µ–º –ø—É—Ç—å –∫ –¥–∞–Ω–Ω—ã–º
  autoconfigure:
    exclude:
      - org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration
      - org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration
      - org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration
      - org.springframework.boot.actuate.autoconfigure.metrics.amqp.RabbitMetricsAutoConfiguration
  main:
    allow-bean-definition-overriding: true
    lazy-initialization: false
  task:
    scheduling:
      enabled: false
  mvc:
    throw-exception-if-no-handler-found: true

# Jackson configuration for tests
jackson:
  serialization:
    write-dates-as-timestamps: false
    indent-output: true

# Security configuration for tests
security:
  user:
    name: testuser
    password: testpass
    roles: USER

# –í–∫–ª—é—á–∞–µ–º —Ç–æ–ª—å–∫–æ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ actuator endpoints
management:
  endpoints:
    web:
      exposure:
        include: health,info
    enabled-by-default: true
  endpoint:
    health:
      enabled: true
      show-details: always
    metrics:
      enabled: false
    info:
      enabled: true

logging:
  level:
    com.notificationservice: DEBUG
    org.springframework.security: WARN
    org.springframework.web: WARN
    org.springframework: WARN
    org.hibernate: WARN
    org.hibernate.SQL: DEBUG
    org.hibernate.type.descriptor.sql.BasicBinder: TRACE

notification:
  email:
    test-mode: true
    from: test@notificationservice.com
  retry:
    max-attempts: 3
    delay: 1000
  async:
    enabled: true
    core-pool-size: 5
    max-pool-size: 10
    queue-capacity: 100

# Test-specific properties
test:
  timeout: 30

-- –°–æ–∑–¥–∞–Ω–∏–µ —Ç–∞–±–ª–∏—Ü –¥–ª—è —Ç–µ—Å—Ç–æ–≤
CREATE TABLE IF NOT EXISTS notifications (
    id VARCHAR(36) PRIMARY KEY,
    type VARCHAR(50) NOT NULL,
    status VARCHAR(50) NOT NULL DEFAULT 'PENDING',
    recipient VARCHAR(255) NOT NULL,
    subject VARCHAR(500),
    message TEXT,
    template_id VARCHAR(36),
    error_message TEXT,
    retry_count INTEGER DEFAULT 0,
    priority VARCHAR(20) DEFAULT 'NORMAL',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    sent_at TIMESTAMP
);

CREATE TABLE IF NOT EXISTS notification_templates (
    id VARCHAR(36) PRIMARY KEY,
    name VARCHAR(255) NOT NULL UNIQUE,
    type VARCHAR(50) NOT NULL,
    subject VARCHAR(500) NOT NULL,
    content TEXT NOT NULL,
    variables TEXT,
    version VARCHAR(20) DEFAULT '1.0',
    active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    created_by VARCHAR(255)
);

-- test-data.sql
-- Test data for unit and integration tests

-- Clean up existing test data
DELETE FROM provider_usage_log;
DELETE FROM template_audit_log;
DELETE FROM notification_logs;
DELETE FROM notifications;
DELETE FROM notification_templates;
DELETE FROM email_providers;
DELETE FROM users;

-- Insert test email providers
INSERT INTO email_providers (id, name, host, port, username, password, from_email, from_name, active, priority, daily_limit, current_usage, created_by) VALUES
('test-provider-1', 'Test SMTP Primary', 'smtp.test.com', 587, 'test-user', 'test-password', 'test@company.com', 'Test Company', true, 1, 1000, 150, 'test-system'),
('test-provider-2', 'Test SMTP Secondary', 'smtp2.test.com', 587, 'test-user2', 'test-password2', 'test@company.com', 'Test Company', true, 2, 500, 50, 'test-system'),
('test-provider-3', 'Test SMTP Inactive', 'smtp3.test.com', 587, 'test-user3', 'test-password3', 'test@company.com', 'Test Company', false, 3, 1000, 0, 'test-system');

-- Insert test notification templates
INSERT INTO notification_templates (id, name, type, subject, content, variables, version, active, created_by) VALUES
('test-template-1', 'Test Welcome Email', 'EMAIL', 'Welcome {{name}}!', '<html><body><h1>Welcome {{name}}!</h1><p>Your email: {{email}}</p></body></html>', '["name", "email"]', '1.0', true, 'test-user'),
('test-template-2', 'Test Password Reset', 'EMAIL', 'Password Reset Request', '<html><body><p>Click <a href="{{resetLink}}">here</a> to reset your password.</p></body></html>', '["resetLink"]', '1.0', true, 'test-user'),
('test-template-3', 'Test Push Notification', 'PUSH', '{{title}}', '{{message}}', '["title", "message"]', '1.0', true, 'test-user'),
('test-template-4', 'Test Inactive Template', 'EMAIL', 'Inactive Template', 'This template is inactive', '[]', '1.0', false, 'test-user');

-- Insert test users
INSERT INTO users (id, email, push_token, platform, device_id, active, preferences, timezone, language, notification_count, last_seen_at) VALUES
('test-user-1', 'john.doe@test.com', 'push-token-123', 'ANDROID', 'device-android-001', true, '{"email_notifications": true, "push_notifications": true}', 'UTC', 'en', 25, CURRENT_TIMESTAMP - INTERVAL '2 days'),
('test-user-2', 'jane.smith@test.com', 'push-token-456', 'IOS', 'device-ios-001', true, '{"email_notifications": true, "push_notifications": false}', 'EST', 'en', 10, CURRENT_TIMESTAMP - INTERVAL '1 day'),
('test-user-3', 'bob.wilson@test.com', NULL, 'WEB', 'device-web-001', true, '{"email_notifications": false, "push_notifications": true}', 'PST', 'en', 5, CURRENT_TIMESTAMP - INTERVAL '3 days'),
('test-user-4', 'inactive.user@test.com', 'push-token-789', 'ANDROID', 'device-android-002', false, '{}', 'UTC', 'en', 0, CURRENT_TIMESTAMP - INTERVAL '30 days');

-- Insert test notifications
INSERT INTO notifications (id, type, status, recipient, subject, message, template_id, retry_count, priority, created_at, sent_at, error_message) VALUES
-- Email notifications
('test-notification-1', 'EMAIL', 'SENT', 'success@test.com', 'Test Email Sent', 'This email was sent successfully', 'test-template-1', 0, 'NORMAL', CURRENT_TIMESTAMP - INTERVAL '2 hours', CURRENT_TIMESTAMP - INTERVAL '2 hours', NULL),
('test-notification-2', 'EMAIL', 'FAILED', 'failed@test.com', 'Test Email Failed', 'This email failed to send', 'test-template-1', 3, 'HIGH', CURRENT_TIMESTAMP - INTERVAL '3 hours', NULL, 'SMTP connection timeout'),
('test-notification-3', 'EMAIL', 'PENDING', 'pending@test.com', 'Test Email Pending', 'This email is pending', 'test-template-1', 0, 'NORMAL', CURRENT_TIMESTAMP - INTERVAL '30 minutes', NULL, NULL),
('test-notification-4', 'EMAIL', 'SENT', 'bulk1@test.com', 'Bulk Test 1', 'Bulk email 1', 'test-template-1', 0, 'LOW', CURRENT_TIMESTAMP - INTERVAL '1 hour', CURRENT_TIMESTAMP - INTERVAL '1 hour', NULL),
('test-notification-5', 'EMAIL', 'SENT', 'bulk2@test.com', 'Bulk Test 2', 'Bulk email 2', 'test-template-1', 0, 'LOW', CURRENT_TIMESTAMP - INTERVAL '1 hour', CURRENT_TIMESTAMP - INTERVAL '1 hour', NULL),

-- Push notifications
('test-notification-6', 'PUSH', 'SENT', 'test-user-1', 'Test Push Sent', 'This push was sent successfully', 'test-template-3', 0, 'HIGH', CURRENT_TIMESTAMP - INTERVAL '1 hour', CURRENT_TIMESTAMP - INTERVAL '1 hour', NULL),
('test-notification-7', 'PUSH', 'FAILED', 'test-user-2', 'Test Push Failed', 'This push failed to send', 'test-template-3', 2, 'NORMAL', CURRENT_TIMESTAMP - INTERVAL '2 hours', NULL, 'Invalid push token'),
('test-notification-8', 'PUSH', 'PENDING', 'test-user-1', 'Test Push Pending', 'This push is pending', 'test-template-3', 0, 'NORMAL', CURRENT_TIMESTAMP - INTERVAL '15 minutes', NULL, NULL),

-- Old notifications for testing cleanup and queries
('test-notification-9', 'EMAIL', 'SENT', 'old@test.com', 'Old Notification', 'This is an old notification', 'test-template-1', 0, 'NORMAL', CURRENT_TIMESTAMP - INTERVAL '10 days', CURRENT_TIMESTAMP - INTERVAL '10 days', NULL),
('test-notification-10', 'EMAIL', 'FAILED', 'very.old@test.com', 'Very Old Failed', 'This failed long ago', 'test-template-1', 5, 'HIGH', CURRENT_TIMESTAMP - INTERVAL '20 days', NULL, 'Permanent failure');

-- Insert test provider usage logs
INSERT INTO provider_usage_log (id, provider_id, notification_id, recipient_count, success, error_message, response_time, used_at) VALUES
('test-usage-1', 'test-provider-1', 'test-notification-1', 1, true, NULL, 1200, CURRENT_TIMESTAMP - INTERVAL '2 hours'),
('test-usage-2', 'test-provider-1', 'test-notification-2', 1, false, 'SMTP connection timeout', 5000, CURRENT_TIMESTAMP - INTERVAL '3 hours'),
('test-usage-3', 'test-provider-2', 'test-notification-2', 1, false, 'Invalid recipient', 800, CURRENT_TIMESTAMP - INTERVAL '2 hours'),
('test-usage-4', 'test-provider-1', 'test-notification-4', 1, true, NULL, 950, CURRENT_TIMESTAMP - INTERVAL '1 hour'),
('test-usage-5', 'test-provider-1', 'test-notification-5', 1, true, NULL, 1100, CURRENT_TIMESTAMP - INTERVAL '1 hour');

-- Insert test template audit logs
INSERT INTO template_audit_log (id, template_id, action, old_values, new_values, changed_by, changed_at) VALUES
('test-audit-1', 'test-template-1', 'UPDATE', '{"version": "1.0"}', '{"version": "1.1"}', 'test-admin', CURRENT_TIMESTAMP - INTERVAL '5 days'),
('test-audit-2', 'test-template-2', 'CREATE', NULL, '{"name": "Test Password Reset", "active": true}', 'test-system', CURRENT_TIMESTAMP - INTERVAL '3 days'),
('test-audit-3', 'test-template-4', 'DEACTIVATE', '{"active": true}', '{"active": false}', 'test-admin', CURRENT_TIMESTAMP - INTERVAL '1 day');

-- Insert test notification logs
INSERT INTO notification_logs (id, notification_id, action, details, created_at, created_by) VALUES
('test-nlog-1', 'test-notification-1', 'SENT', '{"provider": "test-provider-1", "responseTime": 1200}', CURRENT_TIMESTAMP - INTERVAL '2 hours', 'system'),
('test-nlog-2', 'test-notification-2', 'FAILED', '{"attempt": 1, "error": "SMTP connection timeout", "provider": "test-provider-1"}', CURRENT_TIMESTAMP - INTERVAL '3 hours', 'system'),
('test-nlog-3', 'test-notification-2', 'RETRY', '{"attempt": 2, "provider": "test-provider-2", "error": "Invalid recipient"}', CURRENT_TIMESTAMP - INTERVAL '2 hours', 'system'),
('test-nlog-4', 'test-notification-6', 'SENT', '{"platform": "ANDROID", "deviceId": "device-android-001"}', CURRENT_TIMESTAMP - INTERVAL '1 hour', 'system');

-- Update email provider usage counts to match test data
UPDATE email_providers SET current_usage = 3 WHERE id = 'test-provider-1';
UPDATE email_providers SET current_usage = 1 WHERE id = 'test-provider-2';

-- Print test data summary
DO $$
BEGIN
    RAISE NOTICE 'Test data inserted:';
    RAISE NOTICE '  - % email providers', (SELECT COUNT(*) FROM email_providers);
    RAISE NOTICE '  - % notification templates', (SELECT COUNT(*) FROM notification_templates);
    RAISE NOTICE '  - % users', (SELECT COUNT(*) FROM users);
    RAISE NOTICE '  - % notifications', (SELECT COUNT(*) FROM notifications);
    RAISE NOTICE '  - % provider usage logs', (SELECT COUNT(*) FROM provider_usage_log);
    RAISE NOTICE '  - % template audit logs', (SELECT COUNT(*) FROM template_audit_log);
    RAISE NOTICE '  - % notification logs', (SELECT COUNT(*) FROM notification_logs);
END $$;

<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
         http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.2.3</version>
        <relativePath/>
    </parent>

    <groupId>com.notificationservice</groupId>
    <artifactId>notification-service</artifactId>
    <version>1.0.0</version>
    <packaging>jar</packaging>

    <name>Notification Service</name>
    <description>Microservice for handling email and push notifications</description>

    <properties>
        <java.version>17</java.version>
        <maven.compiler.source>17</maven.compiler.source>
        <maven.compiler.target>17</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
        <resilience4j.version>2.1.0</resilience4j.version>
        <springdoc.version>2.3.0</springdoc.version>
        <jjwt.version>0.11.5</jjwt.version>
        <flyway.version>9.22.3</flyway.version>
        <testcontainers.version>1.19.3</testcontainers.version>
        <mockito.version>5.11.0</mockito.version>
        <byte-buddy.version>1.14.13</byte-buddy.version>
        <jacoco.version>0.8.11</jacoco.version>
        <awaitility.version>4.2.0</awaitility.version>
        <greenmail.version>2.0.0</greenmail.version>
    </properties>

    <dependencies>
        <!-- Spring Boot Starters -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-amqp</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-mail</artifactId>
        </dependency>

        <!-- Database -->
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>com.h2database</groupId>
            <artifactId>h2</artifactId>
            <scope>test</scope>
        </dependency>

        <!-- Redis -->
        <dependency>
            <groupId>redis.clients</groupId>
            <artifactId>jedis</artifactId>
        </dependency>

        <!-- Resilience4j -->
        <dependency>
            <groupId>io.github.resilience4j</groupId>
            <artifactId>resilience4j-spring-boot3</artifactId>
            <version>${resilience4j.version}</version>
        </dependency>
        <dependency>
            <groupId>io.github.resilience4j</groupId>
            <artifactId>resilience4j-circuitbreaker</artifactId>
            <version>${resilience4j.version}</version>
        </dependency>
        <dependency>
            <groupId>io.github.resilience4j</groupId>
            <artifactId>resilience4j-retry</artifactId>
            <version>${resilience4j.version}</version>
        </dependency>

        <!-- JWT -->
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-api</artifactId>
            <version>${jjwt.version}</version>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-impl</artifactId>
            <version>${jjwt.version}</version>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-jackson</artifactId>
            <version>${jjwt.version}</version>
            <scope>runtime</scope>
        </dependency>

        <!-- OpenAPI -->
        <dependency>
            <groupId>org.springdoc</groupId>
            <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
            <version>${springdoc.version}</version>
        </dependency>

        <!-- Monitoring -->
        <dependency>
            <groupId>io.micrometer</groupId>
            <artifactId>micrometer-registry-prometheus</artifactId>
        </dependency>

        <!-- Flyway Database Migration -->
        <dependency>
            <groupId>org.flywaydb</groupId>
            <artifactId>flyway-core</artifactId>
        </dependency>

        <!-- Utilities -->
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-lang3</artifactId>
        </dependency>
        <dependency>
            <groupId>commons-io</groupId>
            <artifactId>commons-io</artifactId>
            <version>2.14.0</version>
        </dependency>

        <!-- Lombok -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <scope>provided</scope>
        </dependency>

        <!-- Test Dependencies -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
            <exclusions>
                <exclusion>
                    <groupId>org.junit.vintage</groupId>
                    <artifactId>junit-vintage-engine</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
        <dependency>
            <groupId>org.springframework.amqp</groupId>
            <artifactId>spring-rabbit-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>testcontainers</artifactId>
            <version>${testcontainers.version}</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>junit-jupiter</artifactId>
            <version>${testcontainers.version}</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>postgresql</artifactId>
            <version>${testcontainers.version}</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>rabbitmq</artifactId>
            <version>${testcontainers.version}</version>
            <scope>test</scope>
        </dependency>

        <!-- GreenMail for email testing -->
        <dependency>
            <groupId>com.icegreen</groupId>
            <artifactId>greenmail</artifactId>
            <version>${greenmail.version}</version>
            <scope>test</scope>
        </dependency>

        <!-- Awaitility for async testing -->
        <dependency>
            <groupId>org.awaitility</groupId>
            <artifactId>awaitility</artifactId>
            <version>${awaitility.version}</version>
            <scope>test</scope>
        </dependency>

        <!-- Mockito -->
        <dependency>
            <groupId>org.mockito</groupId>
            <artifactId>mockito-core</artifactId>
            <version>${mockito.version}</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.mockito</groupId>
            <artifactId>mockito-junit-jupiter</artifactId>
            <version>${mockito.version}</version>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <excludes>
                        <exclude>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                        </exclude>
                    </excludes>
                    <mainClass>com.notificationservice.NotificationServiceApplication</mainClass>
                </configuration>
            </plugin>

            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.11.0</version>
                <configuration>
                    <source>17</source>
                    <target>17</target>
                    <annotationProcessorPaths>
                        <path>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                            <version>1.18.30</version>
                        </path>
                    </annotationProcessorPaths>
                </configuration>
            </plugin>

            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
                <version>3.1.2</version>
                <configuration>
                    <includes>
                        <include>**/*Test.java</include>
                        <include>**/*Tests.java</include>
                    </includes>
                    <excludes>
                        <exclude>**/*IT.java</exclude>
                    </excludes>
                    <argLine>-XX:+EnableDynamicAgentLoading</argLine>
                    <systemPropertyVariables>
                        <spring.profiles.active>test</spring.profiles.active>
                    </systemPropertyVariables>
                </configuration>
            </plugin>

            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-failsafe-plugin</artifactId>
                <version>3.1.2</version>
                <executions>
                    <execution>
                        <goals>
                            <goal>integration-test</goal>
                            <goal>verify</goal>
                        </goals>
                    </execution>
                </executions>
                <configuration>
                    <includes>
                        <include>**/*IT.java</include>
                    </includes>
                    <systemPropertyVariables>
                        <spring.profiles.active>test</spring.profiles.active>
                    </systemPropertyVariables>
                </configuration>
            </plugin>

            <plugin>
                <groupId>org.jacoco</groupId>
                <artifactId>jacoco-maven-plugin</artifactId>
                <version>${jacoco.version}</version>
                <executions>
                    <execution>
                        <goals>
                            <goal>prepare-agent</goal>
                        </goals>
                    </execution>
                    <execution>
                        <id>report</id>
                        <phase>test</phase>
                        <goals>
                            <goal>report</goal>
                        </goals>
                    </execution>
                    <execution>
                        <id>check</id>
                        <phase>verify</phase>
                        <goals>
                            <goal>check</goal>
                        </goals>
                        <configuration>
                            <rules>
                                <rule>
                                    <element>BUNDLE</element>
                                    <limits>
                                        <limit>
                                            <counter>INSTRUCTION</counter>
                                            <value>COVEREDRATIO</value>
                                            <minimum>0.80</minimum>
                                        </limit>
                                        <limit>
                                            <counter>BRANCH</counter>
                                            <value>COVEREDRATIO</value>
                                            <minimum>0.70</minimum>
                                        </limit>
                                        <limit>
                                            <counter>LINE</counter>
                                            <value>COVEREDRATIO</value>
                                            <minimum>0.80</minimum>
                                        </limit>
                                        <limit>
                                            <counter>METHOD</counter>
                                            <value>COVEREDRATIO</value>
                                            <minimum>0.80</minimum>
                                        </limit>
                                        <limit>
                                            <counter>CLASS</counter>
                                            <value>MISSEDCOUNT</value>
                                            <maximum>5</maximum>
                                        </limit>
                                    </limits>
                                </rule>
                            </rules>
                        </configuration>
                    </execution>
                </executions>
            </plugin>

            <plugin>
                <groupId>org.flywaydb</groupId>
                <artifactId>flyway-maven-plugin</artifactId>
                <version>${flyway.version}</version>
                <configuration>
                    <url>jdbc:postgresql://localhost:5432/notifications</url>
                    <user>postgres</user>
                    <password>password</password>
                    <locations>
                        <location>classpath:db/migration</location>
                    </locations>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>

# Notification Service

A high-performance, scalable microservice for handling email and push notifications asynchronously using RabbitMQ.

## Features

- üìß **Email Notifications**: Support for HTML and text emails with attachments
- üì± **Push Notifications**: Support for iOS, Android, and web push notifications
- üöÄ **Async Processing**: RabbitMQ-based message queue for reliable processing
- üîÑ **Retry Mechanism**: Automatic retry with exponential backoff for failed notifications
- üíæ **Template Management**: Dynamic email templates with variable substitution
- üìä **Monitoring**: Comprehensive metrics and health checks
- üîí **Security**: JWT authentication and RBAC authorization
- üê≥ **Containerized**: Docker and Kubernetes support
- üìà **Scalable**: Horizontal scaling support with load balancing

## Quick Start

### Prerequisites
- Java 17+
- Docker and Docker Compose
- Maven 3.6+

### Running with Docker Compose

1. **Clone the repository**
   ```bash
   git clone <repository-url>
   cd notification-service

–≤—Å—ë –ø—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–π, –ø—Ä–æ–≤–µ–¥–∏ –≥–ª—É–±–æ–∫–∏–π –∞–Ω–∞–ª–∏–∑, –Ω–µ —Ç–æ—Ä–æ–ø–∏—Å—å, –ø–µ—Ä–µ—Å–æ–±–µ—Ä–∏ –ø—Ä–æ–µ–∫—Ç. –ø—Ä–æ–≤–µ—Ä—å –≤—Å–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏. –≤—Å—ë –∏—Å–ø—Ä–∞–≤—å. –µ—Å–ª–∏ –µ—Å—Ç—å –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è, —Ñ–∞–π–ª—ã –ø–µ—Ä–µ–ø–∏—Å—ã–≤–∞–π –ø–æ–ª–Ω–æ—Å—Ç—å—é. –ø—Ä–æ–≤–µ–¥–∏ –≤—Å–µ –ø—Ä–æ–≤–µ—Ä–∫–∏, 80% –ø–æ–∫—Ä—ã—Ç–∏–µ.
–Ω–∞—Ä–∏—Å—É–π –¥–µ—Ä–µ–≤–æ –ø—Ä–æ–µ–∫—Ç–∞, —Å–æ—Å—Ç–∞–≤—å er –¥–∏–∞–≥—Ä–∞–º–º—É.
—Å–æ—Å—Ç–∞–≤—å –∫—Ä–∞—Ç–∫–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –ø—Ä–æ–µ–∫—Ç–∞ –¥–ª—è —Ä–µ–∑—é–º—ç.